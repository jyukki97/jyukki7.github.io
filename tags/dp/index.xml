<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>DP on 1 Day 1 Problem</title>
    <link>https://jyukki97.github.io/tags/dp/</link>
    <description>Recent content in DP on 1 Day 1 Problem</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>kr-ko</language>
    <lastBuildDate>Thu, 06 Jun 2019 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://jyukki97.github.io/tags/dp/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>[백준]12015 가장 긴 증가하는 부분 수열 2</title>
      <link>https://jyukki97.github.io/blog/2019-06-06-12015/</link>
      <pubDate>Thu, 06 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-06-06-12015/</guid>
      <description>https://www.acmicpc.net/problem/12015
풀이:  https://jyukki97.github.io/2352/ 와 같은 문제이므로 참고  코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std;vector&amp;lt;int&amp;gt;d;int main(void) {int n, s, l;cin &amp;gt;&amp;gt; n;while (n--) {cin &amp;gt;&amp;gt; s;l = lower_bound(d.begin(), d.end(), s) - d.begin();if (l == d.size())d.push_back(s);elsed[l] = s;}cout &amp;lt;&amp;lt; d.size() &amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
    <item>
      <title>[백준]2352 반도체 설계</title>
      <link>https://jyukki97.github.io/blog/2019-06-04-2352/</link>
      <pubDate>Tue, 04 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-06-04-2352/</guid>
      <description>https://www.acmicpc.net/problem/2352
풀이:  맨 처음 값부터 하나 하나 입력받는다. 입력받은 값이 벡터 안에 있는 값들 보다 크다면 벡터에 맨 뒤에 넣는다. 벡터의 처음부터 검색했을 때, 입력받은 값보다 큰 값이 있다면, 그 값과 교체한다. 벡터의 원소 갯수를 출력한다. 일반적으로 for문을 두개 쓴 O(n^2)의 코드는 시간초과가 나므로 주의하자  코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std;vector&amp;lt;int&amp;gt;d;int main(void) {int n, s, l;cin &amp;gt;&amp;gt; n;while(n--) {cin &amp;gt;&amp;gt; s;l = lower_bound(d.</description>
    </item>
    
    <item>
      <title>[백준]1495 기타리스트</title>
      <link>https://jyukki97.github.io/blog/2019-06-02-1495/</link>
      <pubDate>Sun, 02 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-06-02-1495/</guid>
      <description>https://www.acmicpc.net/problem/1495
풀이:  dp[a][b]를 a 번째 곡을 연주 할 때, b 볼륨으로 연주 할 수 있는가? 라고 하자. dp[0][S]는 0 번째 곡을 연주 할 때, S 볼륨으로 연주할 수 있으므로(시작지점) 1을 할당한다. 0번째 곡을 연주할 때, S볼륨으로 연주가 가능하다면, 1번째 곡을 연주할 때, S+s[1] or S-s[1] 볼륨도 연주 가능하다(0&amp;lt;=볼륨&amp;lt;=m 일때) 즉, dp[i][t + s[i]] = dp[i - 1][t] or dp[i][t - s[i]] = dp[i - 1][t] 마지막에 dp[N]값을 모두 순환하며, 가장 높은 값을 출력하고, 가능한 볼륨이 없다면 -1을 출력한다.</description>
    </item>
    
    <item>
      <title>[백준]4781 사탕 가게</title>
      <link>https://jyukki97.github.io/blog/2019-05-30-4781/</link>
      <pubDate>Thu, 30 May 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-05-30-4781/</guid>
      <description>https://www.acmicpc.net/problem/4781
풀이:  dp[a]를 a원으로 구매할 수 있는 가장 높은 칼로리라고 한다. 사탕의 칼로리를 s, 가격을 d라고 했을 때, 현제 a원으로 구매할 수 있는 가장 높은 칼로리와 a-d원 으로 구매할 수 있는 가장높을칼로리 + s 를 비교하여 높은 값으로 교체한다. 즉, dp[t] = max(dp[t], dp[t - d] + s) 를 반복하여 do[m]값을 구한다.  코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;double M1, d1;int N, M, s, d, dp[10002];int main(void) {while (1) {memset(dp, 0, sizeof(dp));cin &amp;gt;&amp;gt; N &amp;gt;&amp;gt; M1;if (N == 0)break;M = M1 * 100;for (int i = 0; i &amp;lt; N; i++) {cin &amp;gt;&amp;gt; s &amp;gt;&amp;gt; d1;d = d1 * 100;for (int t = d; t &amp;lt;= M; t++) dp[t] = max(dp[t], dp[t - d] + s);}cout &amp;lt;&amp;lt; dp[M] &amp;lt;&amp;lt; endl;}return 0;}</description>
    </item>
    
    <item>
      <title>[백준]2662 기업 투자</title>
      <link>https://jyukki97.github.io/blog/2019-05-29-2662/</link>
      <pubDate>Wed, 29 May 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-05-29-2662/</guid>
      <description>https://www.acmicpc.net/problem/2662
풀이:  dp[a][b]를 남은 금액이 a원 일 때, b번째 기업에 투자해서 얻을 수 있는 최대 이익이라고 하자. 첫번째 기업에 0원을 투자하는 것 부터 M번째 기업에 N원을 투자하는 것 까지 반복하여 최대 이익금을 구한다. 최대 이익금일 때 각 기업에 얼마를 투자했는지 구한 후 출력한다. 시간초과가 나기 쉬우므로 메모이제이션을 한다.  코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;cstring&amp;gt;using namespace std;int N, M, s[302][22], dp[302][22], x[302][22];int q(int a, int c) {if (c &amp;gt; M)return 0;int &amp;amp;m = dp[a][c];if (m !</description>
    </item>
    
    <item>
      <title>[백준]1937 욕심쟁이 판다</title>
      <link>https://jyukki97.github.io/blog/2019-05-28-1937/</link>
      <pubDate>Tue, 28 May 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-05-28-1937/</guid>
      <description>https://www.acmicpc.net/problem/1937
풀이:  k[a][b]를 (a , b)지점에서 시작한 판다가 살아남은 최대 일수라고 한다. (a, b) 주변 십자가 방향 지점( (1,0), (-1, 0), (0, 1), (0, -1)) 에서 대나무의 양이 (a, b) 보다 낮다면 그 지점에 최대 일수에서 +1 한 값이 k[a][b] 값이 된다. 높은 값에서 낮은값으로 찾아가면서 최대 일수를 구한다. 시간초과가 날 수 있으므로 메모이제이션을 통해 시행횟수를 제한해준다.  코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;int n, s[510][510], k[510][510];int dx[] = { 1,0,0,-1 };int dy[] = { 0,1,-1,0 };int panda(int a, int b){for (int y = 0; y &amp;lt; 4; y++)if (a + dy[y] &amp;gt;= 0 &amp;amp;&amp;amp; a + dy[y] &amp;lt; n &amp;amp;&amp;amp; b + dx[y] &amp;gt;= 0 &amp;amp;&amp;amp; b + dx[y] &amp;lt; n)if (s[a][b] &amp;lt; s[a + dy[y]][b + dx[y]]) {if(k[a + dy[y]][b + dx[y]] == 1)k[a][b] = max(k[a][b], panda(a + dy[y], b + dx[y]) + 1);elsek[a][b] = max(k[a][b], k[a + dy[y]][b + dx[y]] + 1);}return k[a][b];}int main(void) {cin &amp;gt;&amp;gt; n;int m = 1;fill(&amp;amp;k[0][0], &amp;amp;k[n][n], 1);for (int i = 0; i &amp;lt; n; i++)for (int t = 0; t &amp;lt; n; t++)cin &amp;gt;&amp;gt; s[i][t];for (int i = 0; i &amp;lt; n; i++)for (int t = 0; t &amp;lt; n; t++)m = max(m, panda(i, t));cout &amp;lt;&amp;lt; m &amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
    <item>
      <title>[백준]5069 미로에 갇힌 상근</title>
      <link>https://jyukki97.github.io/blog/2019-05-27-5069/</link>
      <pubDate>Mon, 27 May 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-05-27-5069/</guid>
      <description>https://www.acmicpc.net/problem/5069
풀이:  s[n][t][y]를 n번 이동해서 (t, y)인 방으로 다시 돌아오는 경우의 수라고 한다. 처음 상근이가 있는 방을 (10, 10)이라고 한다(n의 최대 수가 14 이므로 10칸을 넘어가지 않기 때문에) s[n][10][10] 은 n번 이동해서 상근이가 있는 방으로 돌아와야하므로 상근이의 근처에 있는 모든 n-1번 이동하여 돌아오는 경우의 수들의 합과 같다. 즉 s[n][10][10] = s[n-1][10][11] + s[n-1][10][9] + s[n-1][11][11] + s[n-1][11][10] + s[n-1][9][9] + s[n-1][9][10]  코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;using namespace std;int s[15][21][21];int dy[] = { 0,0,1,1,-1,-1 };int dx[] = { 1,-1,1,0,-1,0 };int main(void) {int T, a;cin &amp;gt;&amp;gt; T;s[0][10][10] = 1;for (int i = 1; i &amp;lt; 15; i++)for (int t = 1; t &amp;lt; 21; t++)for (int y = 1; y &amp;lt; 21; y++)for (int u = 0; u &amp;lt; 6; u++)if (t + dx[u] &amp;gt; 0 &amp;amp;&amp;amp; t + dx[u] &amp;lt; 21 &amp;amp;&amp;amp; y + dy[u] &amp;gt; 0 &amp;amp;&amp;amp; y + dy[u] &amp;lt; 21)s[i][t][y] += s[i - 1][t + dx[u]][y + dy[u]];while (T--) {cin &amp;gt;&amp;gt; a;cout &amp;lt;&amp;lt; s[a][10][10] &amp;lt;&amp;lt; endl;}return 0;}</description>
    </item>
    
    <item>
      <title>[백준]1351 무한 수열</title>
      <link>https://jyukki97.github.io/blog/2019-03-29-1351/</link>
      <pubDate>Fri, 29 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-03-29-1351/</guid>
      <description>https://www.acmicpc.net/problem/1351
풀이:  N번째 수열부터 차례대로 찾아나간다. N번째 수열이 map 에 존재한다면 그대로 리턴, 없다면 N = a/b + a/c 로 돌아가서 찾기 N이 0이라면 1을 리턴 각각의 값이 매우 크므로 long long 사용 실패 코드 예시처럼 map을 쓰지않고 리턴을 할 경우 같은 수열이 여러번 중복되어 계산되기 때문에 시간초과가 날 수 있다.  코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;map&amp;gt;using namespace std;long long a, b, c;map&amp;lt;long long, long long&amp;gt; n;long long infi(long long q) {if (q == 0)return 1;if (n.</description>
    </item>
    
    <item>
      <title>[백준]1309 동물원</title>
      <link>https://jyukki97.github.io/blog/2017-12-01-1309/</link>
      <pubDate>Fri, 01 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-12-01-1309/</guid>
      <description>https://www.acmicpc.net/problem/1309
풀이:  a[i] 가 2 x i 칸에 채울 수 있는 배치의 최댓값이라 하자. a[i] = 2 * a[i - 1] + a[i - 2] 로 구할 수 있다.  코드: #include &amp;lt;iostream&amp;gt;using namespace std;int main(void) {int n;cin &amp;gt;&amp;gt; n;int a[100001] = { 3,7,0 };for (int i = 2; i &amp;lt; n; i++) {a[i] = (2* a[i - 1] + a[i - 2]) % 9901;}cout &amp;lt;&amp;lt; a[n - 1] % 9901 &amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
    <item>
      <title>[백준]1520 내리막 길</title>
      <link>https://jyukki97.github.io/blog/2017-12-01-1520/</link>
      <pubDate>Fri, 01 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-12-01-1520/</guid>
      <description>https://www.acmicpc.net/problem/1520
풀이:  cnt[i][t] 가 i행 t열을 골랐을 때 최대 경로의 수 이다. 왼쪽 위 부터 차례대로 방문한다. 왼쪽, 오른쪽, 위, 아래 를 모두 검사하여 지금 계단의 지점보다 낮은 지점을 찾는다. 계속 검사하면서 가다가 오른쪽 끝 즉, (n,m) 을 만나면 return 1을 해준다. 시간초과 때문에 재방문을 피하기위해 cnt의 값을 모두 -1로 바꿔놓고 0이상이면 검사를 끝내도록 하였다.  코드: #include &amp;lt;iostream&amp;gt;using namespace std;int n, m;int a[501][501];int cnt[501][501];int downhill(int q, int w) {if (q == n &amp;amp;&amp;amp; w == m)return 1;if (cnt[q][w] &amp;gt;= 0)return cnt[q][w];cnt[q][w] = 0;int x[5] = { 0, 1, 0, -1, 0 };int y[5] = { 0, 0, 1, 0, -1 };for (int i = 0; i &amp;lt; 5; i++) {if (q + x[i] &amp;gt; 0 &amp;amp;&amp;amp; q + x[i] &amp;lt;= n &amp;amp;&amp;amp; w + y[i] &amp;gt; 0 &amp;amp;&amp;amp; w + y[i] &amp;lt;= m &amp;amp;&amp;amp; a[q + x[i]][w + y[i]] &amp;lt; a[q][w]) {cnt[q][w] += downhill(q + x[i], w + y[i]);}}return cnt[q][w];}int main(void) {cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;for (int i = 1; i &amp;lt;= n; i++) {for (int t = 1; t &amp;lt;= m; t++) {cin &amp;gt;&amp;gt; a[i][t];}}fill(cnt[0],cnt[500], -1);cout &amp;lt;&amp;lt; downhill(1,1) &amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
    <item>
      <title>[백준]1965 상자넣기</title>
      <link>https://jyukki97.github.io/blog/2017-12-01-1965/</link>
      <pubDate>Fri, 01 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-12-01-1965/</guid>
      <description>https://www.acmicpc.net/problem/1965
풀이:  b[i] 가 i 번째 상자를 골랐을 때의 상자의 최대 갯수라고 하자. b[i] = b[i] + 0~i 번째 까지 중 가장 큰 값 이다.  코드: #include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;int main(void) {int n,temp;cin &amp;gt;&amp;gt; n;int a[1001] = { 0 };int b[1001];for (int i = 0; i &amp;lt; n; i++) {cin &amp;gt;&amp;gt; a[i];b[i] = 1;}for (int i = 0; i &amp;lt; n; i++) {temp = 0;for (int t = 0; t &amp;lt;= i; t++) {if (a[i] &amp;gt; a[i - t])temp = max(b[i - t], temp);}b[i] += temp;}for (int i = 0; i &amp;lt; n; i++) {temp = max(b[i], temp);}cout &amp;lt;&amp;lt; temp &amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
    <item>
      <title>[백준]2133 타일 채우기</title>
      <link>https://jyukki97.github.io/blog/2017-12-01-2133/</link>
      <pubDate>Fri, 01 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-12-01-2133/</guid>
      <description>https://www.acmicpc.net/problem/2133
풀이:  N이 홀수라면 타일을 채울 수 없으므로 언제나 0을 출력한다. 짝수일경우 i를 N/2-1 로 생각하고 a[i] = 4 * a[i - 1] - a[i - 2] 로 구한다.  코드: #include &amp;lt;iostream&amp;gt;#include &amp;lt;math.h&amp;gt;using namespace std;int main(void) {int n;long long a[30] = { 3,11,0 };cin &amp;gt;&amp;gt; n;if (n % 2 == 1)cout &amp;lt;&amp;lt; &amp;#34;0&amp;#34; &amp;lt;&amp;lt; endl;else {for (int t = 2; t &amp;lt; n/2; t++) {a[t] = 4*a[t-1] - a[t-2];}cout &amp;lt;&amp;lt; a[n/2-1] &amp;lt;&amp;lt; endl;}return 0;}</description>
    </item>
    
    <item>
      <title>[백준]6359 만취한 상범</title>
      <link>https://jyukki97.github.io/blog/2017-12-01-6359/</link>
      <pubDate>Fri, 01 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-12-01-6359/</guid>
      <description>https://www.acmicpc.net/problem/6359
풀이:  n 개의 방이 있을 때 탈출할 수 있는 사람의 수는 sqrt(n)명이다.  코드: #include &amp;lt;iostream&amp;gt;#include &amp;lt;math.h&amp;gt;using namespace std;int main(void) {int n,T;cin &amp;gt;&amp;gt; T;for (int i = 0; i &amp;lt; T; i++) {cin &amp;gt;&amp;gt; n;cout &amp;lt;&amp;lt; (int)sqrt(n) &amp;lt;&amp;lt; endl;}return 0;}</description>
    </item>
    
    <item>
      <title>[백준]10844 쉬운 계단 수</title>
      <link>https://jyukki97.github.io/blog/2017-11-30-10844/</link>
      <pubDate>Thu, 30 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-11-30-10844/</guid>
      <description>https://www.acmicpc.net/problem/10844
풀이:  a[i][t] 는 길이가 i인 숫자에서 1의 자릿 수가 t일 때의 경우의 수 t가 0 이면 a[i][t] = a[i - 1][t + 1] t가 9 이면 a[i][t] = a[i - 1][t - 1] 둘다 아니면 a[i][t] = (a[i - 1][t - 1] + a[i - 1][t + 1]) 이 때 오버플로우가 발생하므로 각각의 계산에 1000000000을 나눠준다.  코드: #include &amp;lt;iostream&amp;gt;using namespace std;long long a[101][10] = { 0 };int main(void) {int n;cin &amp;gt;&amp;gt; n;long long cnt = 0;for (int i = 1; i &amp;lt; 10; i++) {a[0][i] = 1;}for (int i = 1; i &amp;lt; n; i++) {for (int t = 0; t &amp;lt; 10; t++) {if (t == 0)a[i][t] = a[i - 1][t + 1] % 1000000000;else if (t == 9)a[i][t] = a[i - 1][t - 1] % 1000000000;elsea[i][t] = (a[i - 1][t - 1] + a[i - 1][t + 1]) % 1000000000;}}for (int i = 0; i &amp;lt; 10; i++) {cnt += a[n - 1][i] % 1000000000;}cout &amp;lt;&amp;lt; cnt % 1000000000 &amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
    <item>
      <title>[백준]11057 오르막수</title>
      <link>https://jyukki97.github.io/blog/2017-11-30-11057/</link>
      <pubDate>Thu, 30 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-11-30-11057/</guid>
      <description>https://www.acmicpc.net/problem/11057
풀이:  a[i][t] 는 길이가 i인 수에서 1의 자리가 t인 수의 오르막 수의 개수 a[i][t] += max(a[i - 1][t], a[i][t - 1]);  코드: #include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;int a[1002][1002] = { 0 };int main(void) {int n, m;cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;for (int i = 1; i &amp;lt;= n; i++) {for (int t = 1; t &amp;lt;= m; t++) {cin &amp;gt;&amp;gt; a[i][t];}}for (int i = 1; i &amp;lt;= n; i++) {for (int t = 1; t &amp;lt;= m; t++) {a[i][t] += max(a[i - 1][t], a[i][t - 1]);}}cout &amp;lt;&amp;lt; a[n][m] &amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
    <item>
      <title>[백준]11727 2xN 타일링2</title>
      <link>https://jyukki97.github.io/blog/2017-11-30-11727/</link>
      <pubDate>Thu, 30 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-11-30-11727/</guid>
      <description>https://www.acmicpc.net/problem/11727
풀이:  a[i] 는 타일이 2xi 일때의 경우의 수 a[i] = (2 * a[i - 2] + a[i - 1] 주어진 조건에서 10007으로 나눈 나머지를 출력하라고 하였으므로 나눠줌.  코드: #include &amp;lt;iostream&amp;gt;using namespace std;int a[1001] = { 1,3,0 };int main(void) {int n;cin &amp;gt;&amp;gt; n;for (int i = 2; i &amp;lt; n; i++) {a[i] = (2 * a[i - 2] + a[i - 1])%10007;}cout &amp;lt;&amp;lt; a[n - 1] &amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
    <item>
      <title>[백준]1699 제곱수의 합</title>
      <link>https://jyukki97.github.io/blog/2017-11-30-1699/</link>
      <pubDate>Thu, 30 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-11-30-1699/</guid>
      <description>https://www.acmicpc.net/problem/1699
풀이:  q[i] 는 i 일 때 제곱수로 나타낼 수 있는 최소의 경우의 수 n 이 i + t^2 으로 나타내 질 때, 최소의 경우의 수를 찾음  코드: #include &amp;lt;iostream&amp;gt;#include &amp;lt;math.h&amp;gt;int q[100002] = { 0 };using namespace std;int main(void) {int n,a;cin &amp;gt;&amp;gt; n;a = sqrt(n);for (int i = 1; i &amp;lt;= n; i++){q[i] = 10001;for (int t = 1; t &amp;lt;= a; t++){if (i == t*t)q[i] = 1;}}for (int i = 1; i &amp;lt;= n; i++){for (int t = 1; t &amp;lt;= a; t++){if (i + (t*t) &amp;lt;= n &amp;amp;&amp;amp; q[i + (t*t)] &amp;gt; q[i] + 1)q[i + (t*t)] = q[i] + 1;}}cout &amp;lt;&amp;lt; q[n] &amp;lt;&amp;lt; endl;}</description>
    </item>
    
    <item>
      <title>[백준]1912 연속합</title>
      <link>https://jyukki97.github.io/blog/2017-11-30-1912/</link>
      <pubDate>Thu, 30 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-11-30-1912/</guid>
      <description>https://www.acmicpc.net/problem/1912
풀이:  a[i] 는 i번째를 골랐을 때, 최대값 만약 a[i-1] 이 0 보다 크다면, a[i] += a[i-1]  코드: #include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;int a[100001] = { 0 };int main(void) {int n;cin &amp;gt;&amp;gt; n;for (int i = 0; i &amp;lt; n; i++) {cin &amp;gt;&amp;gt; a[i];}int temp = a[0];for (int i = 1; i &amp;lt; n; i++) {if(a[i-1] &amp;gt; 0)a[i] += a[i - 1];temp = max(temp, a[i]);}cout &amp;lt;&amp;lt; temp &amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
    <item>
      <title>[백준]2163 초콜릿 자르기</title>
      <link>https://jyukki97.github.io/blog/2017-11-30-2163/</link>
      <pubDate>Thu, 30 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-11-30-2163/</guid>
      <description>https://www.acmicpc.net/problem/2163
풀이:  N x M 크기의 초콜릿을 자르는 최소의 경우의 수 N * M - 1  코드: #include &amp;lt;iostream&amp;gt;using namespace std;int main(void) {int n, m;cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;cout &amp;lt;&amp;lt; n*m - 1 &amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
    <item>
      <title>[백준]9461 파도반 수열</title>
      <link>https://jyukki97.github.io/blog/2017-11-30-9461/</link>
      <pubDate>Thu, 30 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-11-30-9461/</guid>
      <description>https://www.acmicpc.net/problem/9461
풀이:  a[i] 는 i 번째 수열 a[i] = a[i-1] + a[i-5]  코드: #include &amp;lt;iostream&amp;gt;using namespace std;long long a[101] = { 1,1,1,2,2,0 };int main(void) {int T,n;cin &amp;gt;&amp;gt; T;for (int i = 0; i &amp;lt; T; i++) {cin &amp;gt;&amp;gt; n;for (int t = 5; t &amp;lt; n; t++) {a[t] = a[t - 1] + a[t - 5];}cout &amp;lt;&amp;lt; a[n - 1] &amp;lt;&amp;lt; endl;}return 0;}</description>
    </item>
    
    <item>
      <title>[백준]2156 포도주 시식</title>
      <link>https://jyukki97.github.io/blog/2017-11-29-2156/</link>
      <pubDate>Wed, 29 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-11-29-2156/</guid>
      <description>https://www.acmicpc.net/problem/2156
풀이:  b[i][0] 은 i번째를 골랐을 때, i-1번째를 안고른 경우의 수 b[i][1] 은 i번째를 골랐을 때, i-1번째를 고른 경우의 수 b[i][2] 은 i번째를 골랐을 때, i-2번째를 안고른 경우의 수  코드: #include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;int main(void) {int n;cin &amp;gt;&amp;gt; n;int a[10001];for (int i = 0; i &amp;lt; n; i++) {cin &amp;gt;&amp;gt; a[i];}int b[10001][3] = { a[0],a[0],a[0],a[1],a[0] + a[1],a[1],0 };int temp;for (int i = 2; i &amp;lt; n; i++) {for (int t = 0; t &amp;lt; 3; t++) {if (t == 0) {temp = max(b[i - 2][0], b[i - 2][1]);b[i][t] = max(temp, b[i - 2][2]) + a[i];}if (t == 1)b[i][t] = max(b[i - 1][0], b[i - 1][2]) + a[i];if (t == 2)b[i][t] = b[i - 3][1] + a[i];}}temp = max(b[n - 1][0], b[n - 2][1]);temp = max(temp, b[n - 1][1]);cout &amp;lt;&amp;lt; max(temp, b[n - 1][2]) &amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
    <item>
      <title>[백준]11726 2×n 타일링</title>
      <link>https://jyukki97.github.io/blog/2017-11-28-11726/</link>
      <pubDate>Tue, 28 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-11-28-11726/</guid>
      <description>https://www.acmicpc.net/problem/11726
풀이:  정수 i를 1,2 의 조합으로 나타낼 수 있는 경우의 수 a[i-1] a[i] = a[i-1] + a[i-2] 으로 구할 수 있다.  코드: #include &amp;lt;iostream&amp;gt;using namespace std;int main(void) {int n;int a[1001] = { 1,2,0 };cin &amp;gt;&amp;gt; n;for (int t = 2; t &amp;lt; n; t++) {a[t] = (a[t - 1] + a[t - 2]) % 10007;}cout &amp;lt;&amp;lt; a[n - 1]&amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
    <item>
      <title>[백준]1463 1로 만들기</title>
      <link>https://jyukki97.github.io/blog/2017-11-28-1463/</link>
      <pubDate>Tue, 28 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-11-28-1463/</guid>
      <description>https://www.acmicpc.net/problem/1463
풀이:  i 일때 연산 횟수를 a[i] 라고 둔다. 2와 3으로 동시에 나눠질때, 따로 나눠질때, 나눠지지 않을때로 나눠서 계산한다. n번까지 연산 후 a[n]을 출력한다.  코드: #include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;int a[1000002] = { 0 };int main(void) {int n;cin &amp;gt;&amp;gt; n;for (int i = 2; i &amp;lt;= n; i++) {if (i % 2 == 0 &amp;amp;&amp;amp; i % 3 == 0) {int temp = min(a[i / 2], a[i / 3]);a[i] = min(temp, a[i - 1]) + 1;}else if(i % 2 == 0 &amp;amp;&amp;amp; i % 3 !</description>
    </item>
    
    <item>
      <title>[백준]9095 1, 2, 3 더하기</title>
      <link>https://jyukki97.github.io/blog/2017-11-28-9095/</link>
      <pubDate>Tue, 28 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-11-28-9095/</guid>
      <description>https://www.acmicpc.net/problem/9095
풀이:  정수 i를 1,2,3의 조합으로 나타낼 수 있는 경우의 수 a[i-1] a[i] = a[i-1] + a[i-2] + a[i-3] 으로 구할 수 있다.  코드: #include &amp;lt;iostream&amp;gt;using namespace std;int main(void) {int T,n;cin &amp;gt;&amp;gt; T;for (int i = 0; i &amp;lt; T; i++) {int a[11] = { 1,2,4,0 };cin &amp;gt;&amp;gt; n;for (int t = 3; t &amp;lt; n; t++) {a[t] = a[t - 1] + a[t - 2] + a[t - 3];}cout &amp;lt;&amp;lt; a[n - 1] &amp;lt;&amp;lt; endl;}return 0;}</description>
    </item>
    
    <item>
      <title>[백준]11052 붕어빵 판매하기</title>
      <link>https://jyukki97.github.io/blog/2017-11-26-11052/</link>
      <pubDate>Sun, 26 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-11-26-11052/</guid>
      <description>https://www.acmicpc.net/problem/11052
풀이:  붕어의 개수가 i개 일 때를 b[i] 라고 놓고 b[i] = (t개 일때 가격 + 남은 붕어 빵의 가격) 과 b[i] 개중 큰값을 넣음. 구하고자 하는 n개 즉 b[n]을 찾음.  코드: #include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;int main(void) {int n, m, w;int a[1002];int b[1002] = { 0 };cin &amp;gt;&amp;gt; n;for (int i = 1; i &amp;lt;= n; i++) {cin &amp;gt;&amp;gt; a[i];}for (int i = 1; i &amp;lt;= n; i++) {for (int t = 0; t &amp;lt; i; t++) {b[i] = max(b[i], b[t] + a[i - t]);}}cout &amp;lt;&amp;lt; b[n] &amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
    <item>
      <title>[백준]1010 다리놓기</title>
      <link>https://jyukki97.github.io/blog/2017-11-25-1010/</link>
      <pubDate>Sat, 25 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-11-25-1010/</guid>
      <description>https://www.acmicpc.net/problem/1010
풀이:  서쪽 다리(N)에서 동쪽 다리(M)로 연결 이므로 조합인 mCn 을 사용  코드: #include &amp;lt;iostream&amp;gt;using namespace std;int Comb(int n, int r) {if (r == 0 || r == n)return 1;else if (r == n - 1 || r == 1)return n;return Comb(n - 1, r) + Comb(n - 1, r - 1);}int main(void) {int T,n,m;cin &amp;gt;&amp;gt; T;for (int i = 0; i &amp;lt; T; i++) {cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;cout &amp;lt;&amp;lt; Comb(m, n) &amp;lt;&amp;lt; endl;}return 0;}</description>
    </item>
    
    <item>
      <title>[백준]1932 숫자삼각형</title>
      <link>https://jyukki97.github.io/blog/2017-11-24-1932/</link>
      <pubDate>Fri, 24 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-11-24-1932/</guid>
      <description>https://www.acmicpc.net/problem/1932
풀이:  첫 줄부터 밑에줄까지 내려가면서 값을 더해감 더한 값중 제일 큰 값을 찾음  코드: #include &amp;lt;iostream&amp;gt;using namespace std;int q[501][501];int good[501][501];int main(void){int num;int big = 0;cin &amp;gt;&amp;gt; num;for (int i = 0; i &amp;lt; num; i++){for (int t = 0; t &amp;lt; i + 1; t++){cin &amp;gt;&amp;gt; q[i][t];}}good[0][0] = q[0][0];for (int i = 1; i &amp;lt; num; i++){for (int t = 0; t &amp;lt; i+1; t++){if(t==0)good[i][t] = good[i - 1][t] + q[i][t];else if (i == t)good[i][t] = good[i - 1][t - 1] + q[i][t];else{if (good[i - 1][t - 1] &amp;gt; good[i - 1][t])good[i][t] = good[i - 1][t - 1] + q[i][t];elsegood[i][t] = good[i - 1][t] + q[i][t];}}}for (int i = 0; i &amp;lt; num; i++){if (good[num - 1][i] &amp;gt; big)big = good[num - 1][i];}cout &amp;lt;&amp;lt; big &amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
    <item>
      <title>[백준]2293 동전1</title>
      <link>https://jyukki97.github.io/blog/2017-11-23-2293/</link>
      <pubDate>Thu, 23 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-11-23-2293/</guid>
      <description>https://www.acmicpc.net/problem/2293
풀이:  첫번째 동전부터 경우의 수를 더해감.  코드: #include &amp;lt;iostream&amp;gt;using namespace std;int coin[10001] = { 0 };int main(void){int a;int num;cin &amp;gt;&amp;gt; a;cin &amp;gt;&amp;gt; num;int *q = new int[a];for (int i = 0; i &amp;lt; a; i++){cin &amp;gt;&amp;gt; q[i];}for (int i = 0; i &amp;lt;= num; i++){if (i%q[0] == 0)coin[i]++;}for (int i = 1; i &amp;lt; a; i++){for (int t = q[i]; t &amp;lt;= num; t++){coin[t] += coin[t - q[i]];}}cout &amp;lt;&amp;lt; coin[num] &amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
  </channel>
</rss>