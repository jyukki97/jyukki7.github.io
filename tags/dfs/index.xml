<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>DFS on 1 Day 1 Problem</title>
    <link>https://jyukki97.github.io/tags/dfs/</link>
    <description>Recent content in DFS on 1 Day 1 Problem</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>kr-ko</language>
    <lastBuildDate>Thu, 27 Feb 2020 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://jyukki97.github.io/tags/dfs/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>[백준]1260 DFS와 BFS</title>
      <link>https://jyukki97.github.io/blog/2020-02-27-1260/</link>
      <pubDate>Thu, 27 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-02-27-1260/</guid>
      <description>https://www.acmicpc.net/problem/1260
풀이: DFS 와 BFS를 출력한다.
코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;queue&amp;gt;#include &amp;lt;string.h&amp;gt;using namespace std;int n, m, v, q, w, a[1002][1002] = {};bool b[1002];void dfs(int x) {b[x] = true;cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &amp;#34;&amp;#34;;for (int i = 1; i &amp;lt;= n; i++)if (a[x][i] &amp;amp;&amp;amp; !b[i])	dfs(i);}int main() {cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m &amp;gt;&amp;gt; v;for (int i = 0; i &amp;lt; m; i++) {cin &amp;gt;&amp;gt; q &amp;gt;&amp;gt; w;a[q][w] = 1;a[w][q] = 1;}dfs(v);cout &amp;lt;&amp;lt; endl;memset(b, 0, n + 1);queue&amp;lt;int&amp;gt; c;c.</description>
    </item>
    
    <item>
      <title>[백준]2667 단지번호붙이기</title>
      <link>https://jyukki97.github.io/blog/2020-02-27-2667/</link>
      <pubDate>Thu, 27 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-02-27-2667/</guid>
      <description>https://www.acmicpc.net/problem/2667
풀이: 전체를 순회한다.
만약 집이있는 곳 ( 배열에 1인 곳 ) 을 찾았다면, 연결된 모든 단지를 찾아 단지 크기를 배열에 저장한다.
순회가 끝났다면, 배열의 사이즈 (총 단지수) 를 출력한다.
그 후 단지내 집의 수를 오름차순으로 정렬하여 출력하여야하므로
배열을 정렬한 후 배열의 원소를 출력한다.
코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;string&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;int n;bool b[26][26];vector&amp;lt;string&amp;gt; a;vector&amp;lt;int&amp;gt; c;void num(int x, int y) {b[x][y] = true;c.</description>
    </item>
    
    <item>
      <title>[프로그래머스]단어 변환</title>
      <link>https://jyukki97.github.io/blog/2020-02-17-wordtranslation/</link>
      <pubDate>Mon, 17 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-02-17-wordtranslation/</guid>
      <description>https://programmers.co.kr
문제: 두 개의 단어 begin, target과 단어의 집합 words가 있습니다. 아래와 같은 규칙을 이용하여 begin에서 target으로 변환하는 가장 짧은 변환 과정을 찾으려고 합니다.
1. 한 번에 한 개의 알파벳만 바꿀 수 있습니다.2. words에 있는 단어로만 변환할 수 있습니다.예를 들어 begin이 hit, target가 cog, words가 [hot,dot,dog,lot,log,cog]라면 hit -&amp;gt; hot -&amp;gt; dot -&amp;gt; dog -&amp;gt; cog와 같이 4단계를 거쳐 변환할 수 있습니다.
두 개의 단어 begin, target과 단어의 집합 words가 매개변수로 주어질 때, 최소 몇 단계의 과정을 거쳐 begin을 target으로 변환할 수 있는지 return 하도록 solution 함수를 작성해주세요.</description>
    </item>
    
    <item>
      <title>[프로그래머스]네트워크</title>
      <link>https://jyukki97.github.io/blog/2020-01-03-network/</link>
      <pubDate>Fri, 03 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-01-03-network/</guid>
      <description>https://programmers.co.kr
문제: 네트워크란 컴퓨터 상호 간에 정보를 교환할 수 있도록 연결된 형태를 의미합니다. 예를 들어, 컴퓨터 A와 컴퓨터 B가 직접적으로 연결되어있고, 컴퓨터 B와 컴퓨터 C가 직접적으로 연결되어 있을 때 컴퓨터 A와 컴퓨터 C도 간접적으로 연결되어 정보를 교환할 수 있습니다. 따라서 컴퓨터 A, B, C는 모두 같은 네트워크 상에 있다고 할 수 있습니다.
컴퓨터의 개수 n, 연결에 대한 정보가 담긴 2차원 배열 computers가 매개변수로 주어질 때, 네트워크의 개수를 return 하도록 solution 함수를 작성하시오.</description>
    </item>
    
    <item>
      <title>[프로그래머스]타겟 넘버</title>
      <link>https://jyukki97.github.io/blog/2019-12-30-targetnum/</link>
      <pubDate>Mon, 30 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-12-30-targetnum/</guid>
      <description>https://programmers.co.kr
문제: n개의 음이 아닌 정수가 있습니다. 이 수를 적절히 더하거나 빼서 타겟 넘버를 만들려고 합니다. 예를 들어 [1, 1, 1, 1, 1]로 숫자 3을 만들려면 다음 다섯 방법을 쓸 수 있습니다.
-1+1+1+1+1 = 3+1-1+1+1+1 = 3+1+1-1+1+1 = 3+1+1+1-1+1 = 3+1+1+1+1-1 = 3사용할 수 있는 숫자가 담긴 배열 numbers, 타겟 넘버 target이 매개변수로 주어질 때 숫자를 적절히 더하고 빼서 타겟 넘버를 만드는 방법의 수를 return 하도록 solution 함수를 작성해주세요.</description>
    </item>
    
    <item>
      <title>[백준]6603 로또</title>
      <link>https://jyukki97.github.io/blog/2017-12-12-6603/</link>
      <pubDate>Tue, 12 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-12-12-6603/</guid>
      <description>https://www.acmicpc.net/problem/6603
풀이:  N 개의 로또 번호 중 6개를 선택하여 로또를 만드는 프로그램 6개의 번호를 사전순으로 하나씩 선택하면서 출력한다. 출력 사이사이에 빈칸을 만들어주고, 하나의 테스트 케이스가 끝나면 빈 줄을 하나 출력한다. 0이 출력되면 끝나므로 while 문 안에 if문으로 제한을 넣어준다.  코드: #include &amp;lt;iostream&amp;gt;using namespace std;int a[13];int main(void) {while (true) {int n;cin &amp;gt;&amp;gt; n;if (n == 0)break;for (int i = 0; i &amp;lt; n; i++) {cin &amp;gt;&amp;gt; a[i];}int b[6] = { 0,1,2,3,4,5 };while (true) {cout &amp;lt;&amp;lt; a[b[0]] &amp;lt;&amp;lt; &amp;#34;&amp;#34; &amp;lt;&amp;lt; a[b[1]] &amp;lt;&amp;lt; &amp;#34;&amp;#34; &amp;lt;&amp;lt; a[b[2]] &amp;lt;&amp;lt; &amp;#34;&amp;#34; &amp;lt;&amp;lt; a[b[3]] &amp;lt;&amp;lt; &amp;#34;&amp;#34; &amp;lt;&amp;lt; a[b[4]] &amp;lt;&amp;lt; &amp;#34;&amp;#34; &amp;lt;&amp;lt; a[b[5]] &amp;lt;&amp;lt; endl;if (b[0] &amp;gt;= n - 6)break;else if (b[1] &amp;gt;= n - 5) {b[0]++;for (int i = 0; i &amp;lt; 5; i++) {b[i + 1] = b[i] + 1;}}else if (b[2] &amp;gt;= n - 4) {b[1]++;for (int i = 1; i &amp;lt; 5; i++) {b[i + 1] = b[i] + 1;}}else if (b[3] &amp;gt;= n - 3) {b[2]++;for (int i = 2; i &amp;lt; 5; i++) {b[i + 1] = b[i] + 1;}}else if (b[4] &amp;gt;= n - 2) {b[3]++;for (int i = 3; i &amp;lt; 5; i++) {b[i + 1] = b[i] + 1;}}else if (b[5] &amp;gt;= n - 1) {b[4]++;b[5] = b[4] + 1;}elseb[5]++;}cout &amp;lt;&amp;lt; endl;}return 0;}</description>
    </item>
    
  </channel>
</rss>