<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>C&#43;&#43; on 1 Day 1 Problem</title>
    <link>https://jyukki97.github.io/tags/c&#43;&#43;/</link>
    <description>Recent content in C&#43;&#43; on 1 Day 1 Problem</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>kr-ko</language>
    <lastBuildDate>Sun, 29 Dec 2019 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://jyukki97.github.io/tags/c++/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>[프로그래머스]숫자 야구</title>
      <link>https://jyukki97.github.io/blog/2019-12-29-numbaseball/</link>
      <pubDate>Sun, 29 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-12-29-numbaseball/</guid>
      <description>https://programmers.co.kr
문제: 숫자 야구 게임이란 2명이 서로가 생각한 숫자를 맞추는 게임입니다. 게임해보기
각자 서로 다른 1~9까지 3자리 임의의 숫자를 정한 뒤 서로에게 3자리의 숫자를 불러서 결과를 확인합니다. 그리고 그 결과를 토대로 상대가 정한 숫자를 예상한 뒤 맞힙니다.
* 숫자는 맞지만, 위치가 틀렸을 때는 볼* 숫자와 위치가 모두 맞을 때는 스트라이크* 숫자와 위치가 모두 틀렸을 때는 아웃예를 들어, 아래의 경우가 있으면
A : 123B : 1스트라이크 1볼.A : 356B : 1스트라이크 0볼.</description>
    </item>
    
    <item>
      <title>[프로그래머스]위장</title>
      <link>https://jyukki97.github.io/blog/2019-12-29-camouflage/</link>
      <pubDate>Sun, 29 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-12-29-camouflage/</guid>
      <description>https://programmers.co.kr
문제: 스파이들은 매일 다른 옷을 조합하여 입어 자신을 위장합니다.
예를 들어 스파이가 가진 옷이 아래와 같고 오늘 스파이가 동그란 안경, 긴 코트, 파란색 티셔츠를 입었다면 다음날은 청바지를 추가로 입거나 동그란 안경 대신 검정 선글라스를 착용하거나 해야 합니다.
   종류 이름     얼굴 동그란 안경, 검정 선글라스   상의 파란색 티셔츠   하의 청바지   겉옷 긴 코트    스파이가 가진 의상들이 담긴 2차원 배열 clothes가 주어질 때 서로 다른 옷의 조합의 수를 return 하도록 solution 함수를 작성해주세요.</description>
    </item>
    
    <item>
      <title>[프로그래머스]전화번호 목록</title>
      <link>https://jyukki97.github.io/blog/2019-12-28-phonebooklist/</link>
      <pubDate>Sat, 28 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-12-28-phonebooklist/</guid>
      <description>https://programmers.co.kr
문제: 전화번호부에 적힌 전화번호 중, 한 번호가 다른 번호의 접두어인 경우가 있는지 확인하려 합니다. 전화번호가 다음과 같을 경우, 구조대 전화번호는 영석이의 전화번호의 접두사입니다.
 구조대 : 119 박준영 : 97 674 223 지영석 : 11 9552 4421  전화번호부에 적힌 전화번호를 담은 배열 phone_book 이 solution 함수의 매개변수로 주어질 때, 어떤 번호가 다른 번호의 접두어인 경우가 있으면 false를 그렇지 않으면 true를 return 하도록 solution 함수를 작성해주세요.
풀이: phone_book 에 있는 전화번호들을 사전순으로 정렬해 놓는다.</description>
    </item>
    
    <item>
      <title>[프로그래머스]큰 수 만들기</title>
      <link>https://jyukki97.github.io/blog/2019-12-28-makebignum/</link>
      <pubDate>Sat, 28 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-12-28-makebignum/</guid>
      <description>https://programmers.co.kr
문제: 어떤 숫자에서 k개의 수를 제거했을 때 얻을 수 있는 가장 큰 숫자를 구하려 합니다.
예를 들어, 숫자 1924에서 수 두 개를 제거하면 [19, 12, 14, 92, 94, 24] 를 만들 수 있습니다. 이 중 가장 큰 숫자는 94 입니다.
문자열 형식으로 숫자 number와 제거할 수의 개수 k가 solution 함수의 매개변수로 주어집니다. number에서 k 개의 수를 제거했을 때 만들 수 있는 수 중 가장 큰 숫자를 문자열 형태로 return 하도록 solution 함수를 완성하세요.</description>
    </item>
    
    <item>
      <title>[프로그래머스]멀쩡한 사각형</title>
      <link>https://jyukki97.github.io/blog/2019-12-27-intactractangle/</link>
      <pubDate>Fri, 27 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-12-27-intactractangle/</guid>
      <description>https://programmers.co.kr
문제: 가로 길이가 Wcm, 세로 길이가 Hcm인 직사각형 종이가 있습니다. 종이에는 가로, 세로 방향과 평행하게 격자 형태로 선이 그어져 있으며, 모든 격자칸은 1cm x 1cm 크기입니다. 이 종이를 격자 선을 따라 1cm × 1cm의 정사각형으로 잘라 사용할 예정이었는데, 누군가가 이 종이를 대각선 꼭지점 2개를 잇는 방향으로 잘라 놓았습니다. 그러므로 현재 직사각형 종이는 크기가 같은 직각삼각형 2개로 나누어진 상태입니다. 새로운 종이를 구할 수 없는 상태이기 때문에, 이 종이에서 원래 종이의 가로, 세로 방향과 평행하게 1cm × 1cm로 잘라 사용할 수 있는 만큼만 사용하기로 하였습니다.</description>
    </item>
    
    <item>
      <title>[프로그래머스]주식가격</title>
      <link>https://jyukki97.github.io/blog/2019-12-27-stockprice/</link>
      <pubDate>Fri, 27 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-12-27-stockprice/</guid>
      <description>https://programmers.co.kr
문제: 초 단위로 기록된 주식가격이 담긴 배열 prices가 매개변수로 주어질 때, 가격이 떨어지지 않은 기간은 몇 초인지를 return 하도록 solution 함수를 완성하세요.
풀이: 초 단위로 시간을 흘러가게 한 후 주식가격이 떨어지면 그 시간을 기록하여 answer에 저장한다.
코드: 사용언어 : c++
#include &amp;lt;string&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std;vector&amp;lt;int&amp;gt; solution(vector&amp;lt;int&amp;gt; prices) {vector&amp;lt;int&amp;gt; answer;for (int i = 0;i &amp;lt; prices.size();i++) {answer.push_back(0);for (int t = i + 1;t &amp;lt; prices.</description>
    </item>
    
    <item>
      <title>[프로그래머스]프린터</title>
      <link>https://jyukki97.github.io/blog/2019-12-27-printer/</link>
      <pubDate>Fri, 27 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-12-27-printer/</guid>
      <description>https://programmers.co.kr
문제: 일반적인 프린터는 인쇄 요청이 들어온 순서대로 인쇄합니다. 그렇기 때문에 중요한 문서가 나중에 인쇄될 수 있습니다. 이런 문제를 보완하기 위해 중요도가 높은 문서를 먼저 인쇄하는 프린터를 개발했습니다. 이 새롭게 개발한 프린터는 아래와 같은 방식으로 인쇄 작업을 수행합니다.
1. 인쇄 대기목록의 가장 앞에 있는 문서(J)를 대기목록에서 꺼냅니다.2. 나머지 인쇄 대기목록에서 J보다 중요도가 높은 문서가 한 개라도 존재하면 J를 대기목록의 가장 마지막에 넣습니다.3. 그렇지 않으면 J를 인쇄합니다.예를 들어, 4개의 문서(A, B, C, D)가 순서대로 인쇄 대기목록에 있고 중요도가 2 1 3 2 라면 C D A B 순으로 인쇄하게 됩니다.</description>
    </item>
    
    <item>
      <title>[프로그래머스]기능개발</title>
      <link>https://jyukki97.github.io/blog/2019-12-26-fdevelopment/</link>
      <pubDate>Thu, 26 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-12-26-fdevelopment/</guid>
      <description>https://programmers.co.kr
문제: 프로그래머스 팀에서는 기능 개선 작업을 수행 중입니다. 각 기능은 진도가 100%일 때 서비스에 반영할 수 있습니다.
또, 각 기능의 개발속도는 모두 다르기 때문에 뒤에 있는 기능이 앞에 있는 기능보다 먼저 개발될 수 있고, 이때 뒤에 있는 기능은 앞에 있는 기능이 배포될 때 함께 배포됩니다.
먼저 배포되어야 하는 순서대로 작업의 진도가 적힌 정수 배열 progresses와 각 작업의 개발 속도가 적힌 정수 배열 speeds가 주어질 때 각 배포마다 몇 개의 기능이 배포되는지를 return 하도록 solution 함수를 완성하세요.</description>
    </item>
    
    <item>
      <title>[프로그래머스]다리를 지나는 트럭</title>
      <link>https://jyukki97.github.io/blog/2019-12-26-bridgetruck/</link>
      <pubDate>Thu, 26 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-12-26-bridgetruck/</guid>
      <description>https://programmers.co.kr
문제: 트럭 여러 대가 강을 가로지르는 일 차선 다리를 정해진 순으로 건너려 합니다. 모든 트럭이 다리를 건너려면 최소 몇 초가 걸리는지 알아내야 합니다. 트럭은 1초에 1만큼 움직이며, 다리 길이는 bridge_length이고 다리는 무게 weight까지 견딥니다. ※ 트럭이 다리에 완전히 오르지 않은 경우, 이 트럭의 무게는 고려하지 않습니다.
예를 들어, 길이가 2이고 10kg 무게를 견디는 다리가 있습니다. 무게가 [7, 4, 5, 6]kg인 트럭이 순서대로 최단 시간 안에 다리를 건너려면 다음과 같이 건너야 합니다.</description>
    </item>
    
    <item>
      <title>[프로그래머스]스킬트리</title>
      <link>https://jyukki97.github.io/blog/2019-12-26-skilltree/</link>
      <pubDate>Thu, 26 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-12-26-skilltree/</guid>
      <description>https://programmers.co.kr
문제: 선행 스킬이란 어떤 스킬을 배우기 전에 먼저 배워야 하는 스킬을 뜻합니다.
예를 들어 선행 스킬 순서가 스파크 → 라이트닝 볼트 → 썬더일때, 썬더를 배우려면 먼저 라이트닝 볼트를 배워야 하고, 라이트닝 볼트를 배우려면 먼저 스파크를 배워야 합니다.
위 순서에 없는 다른 스킬(힐링 등)은 순서에 상관없이 배울 수 있습니다. 따라서 스파크 → 힐링 → 라이트닝 볼트 → 썬더와 같은 스킬트리는 가능하지만, 썬더 → 스파크나 라이트닝 볼트 → 스파크 → 힐링 → 썬더와 같은 스킬트리는 불가능합니다.</description>
    </item>
    
    <item>
      <title>[프로그래머스]자연수 뒤집어 배열로 만들기</title>
      <link>https://jyukki97.github.io/blog/2019-12-25-turnnnum/</link>
      <pubDate>Wed, 25 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-12-25-turnnnum/</guid>
      <description>https://programmers.co.kr
풀이:  자연수 n을 뒤집어 각 자리 숫자를 원소로 가지는 배열을 리턴한다.  코드: 사용언어 : c++
#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;stdbool.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt;int* solution(long long n) {// 리턴할 값은 메모리를 동적 할당해주세요. int* answer = (int*)malloc(sizeof(int)*12 + 1);int c = 0;while (n) {answer[c] = n % 10;n /= 10;c++;}return answer;}</description>
    </item>
    
    <item>
      <title>[프로그래머스]자릿수 더하기</title>
      <link>https://jyukki97.github.io/blog/2019-12-24-sumpnum/</link>
      <pubDate>Tue, 24 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-12-24-sumpnum/</guid>
      <description>https://programmers.co.kr
풀이:  자연수 n의 각 자릿수의 합을 구해서 리턴한다.  코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;using namespace std;int solution(int n){int answer = 0;while (n != 0) {answer += n % 10;n /= 10;}return answer;}</description>
    </item>
    
    <item>
      <title>[프로그래머스]이상한 문자 만들기</title>
      <link>https://jyukki97.github.io/blog/2019-12-23-strangestring/</link>
      <pubDate>Mon, 23 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-12-23-strangestring/</guid>
      <description>https://programmers.co.kr
문제: 문자열 s는 한 개 이상의 단어로 구성되어 있습니다. 각 단어는 하나 이상의 공백문자로 구분되어 있습니다. 각 단어의 짝수번째 알파벳은 대문자로, 홀수번째 알파벳은 소문자로 바꾼 문자열을 리턴하는 함수, solution을 완성하세요.
풀이:  문자열 전체의 짝/홀수 인덱스가 아니라 각 단어 기준이므로 주의한다. 공백문자가 하나가 아닐 수도 있으므로 주의한다. 공백문자를 기준으로 단어를 나누므로, 공백문자가 나왔을 경우 카운트를 초기화하는 식으로 문자열을 나눈다.  코드: 사용언어 : c++
#include &amp;lt;string&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std;string solution(string s) {int c = 0;for (int i = 0;i &amp;lt; s.</description>
    </item>
    
    <item>
      <title>[프로그래머스]두 정수 사이의 합</title>
      <link>https://jyukki97.github.io/blog/2019-12-22-sumnums/</link>
      <pubDate>Sun, 22 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-12-22-sumnums/</guid>
      <description>https://programmers.co.kr
풀이:  두 수 a, b 사이에 속한 모든 정수의 합을 리턴한다. a와 b는 -10,000,000 이상 10,000,000 이하인 정수 이므로 주의한다. a와 b의 대소관계가 정해져 있지 않으므로 절댓값을 이용한다.  코드: 사용언어 : c++
#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;stdbool.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt;long long solution(int a, int b) {long long answer = ((long)a + (long)b) * (abs((long)b - (long)a) + 1) / 2;return answer;}</description>
    </item>
    
    <item>
      <title>[프로그래머스]약수의 합</title>
      <link>https://jyukki97.github.io/blog/2019-12-22-sumdivisor/</link>
      <pubDate>Sun, 22 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-12-22-sumdivisor/</guid>
      <description>https://programmers.co.kr
풀이:  정수 n의 모든 약수의 합을 리턴한다.  코드: 사용언어 : c++
#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;stdbool.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt;int solution(int n) {int answer = 0;for (int i = 1;i &amp;lt;= n;i++)if (n % i == 0)answer += i;return answer;}</description>
    </item>
    
    <item>
      <title>[프로그래머스]가운데 글자 가져오기</title>
      <link>https://jyukki97.github.io/blog/2019-12-21-middlenum/</link>
      <pubDate>Sat, 21 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-12-21-middlenum/</guid>
      <description>https://programmers.co.kr
풀이:  문자열 s의 가운데 글자를 리턴한다. 만약 문자열 s의 길이가 짝수라면 가운데 두 글자를 반환한다  코드: 사용언어 : c++
#include &amp;lt;string&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std;string solution(string s) {string answer;if (s.length() % 2 == 0) {answer = s[s.length() / 2 - 1];answer += s[s.length() / 2];}else {answer = s[s.length() / 2];}return answer;}</description>
    </item>
    
    <item>
      <title>[프로그래머스]시저 암호</title>
      <link>https://jyukki97.github.io/blog/2019-12-21-caesarcipher/</link>
      <pubDate>Sat, 21 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-12-21-caesarcipher/</guid>
      <description>https://programmers.co.kr
풀이:  문자열 s를 n만큼 밀어서 나온 다른 알파벳의 결과값을 리턴한다. 중간에 공백문자가 있을 수 있으니 주의한다. &amp;lsquo;z&#39;를 밀 경우 &amp;lsquo;A&#39;가 아니라 &amp;lsquo;a&#39;가 나와야 하므로 주의한다.  코드: 사용언어 : c++
#include &amp;lt;string&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std;string solution(string s, int n) {for (int i = 0;i &amp;lt; s.size();i++) {if (isalpha(s[i])) {if (s[i] + n &amp;gt; &amp;#39;z&amp;#39;) {s[i] = 96 + (s[i] + n) % &amp;#39;z&amp;#39;;}else if (s[i] &amp;lt;= &amp;#39;Z&amp;#39; &amp;amp;&amp;amp; s[i] + n &amp;gt; &amp;#39;Z&amp;#39;) {s[i] = 64 + (s[i] + n) % &amp;#39;Z&amp;#39;;}elses[i] += n;}}return s;}</description>
    </item>
    
    <item>
      <title>[프로그래머스]나누어 떨어지는 숫자 배열</title>
      <link>https://jyukki97.github.io/blog/2019-12-20-dividednum/</link>
      <pubDate>Fri, 20 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-12-20-dividednum/</guid>
      <description>https://programmers.co.kr
풀이:  arr의 각 원소 중 divisor로 나누어 떨어지는 값을 오름차순으로 정렬한 배열을 리턴한다. 만약 배열의 원소가 없다면 -1을 리턴한다.  코드: 사용언어 : c++
#include &amp;lt;string&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;vector&amp;lt;int&amp;gt; solution(vector&amp;lt;int&amp;gt; arr, int divisor) {vector&amp;lt;int&amp;gt; answer;for (int i : arr) {if (i % divisor == 0)answer.push_back(i);}sort(answer.begin(), answer.end());if(answer.size()==0)answer.push_back(-1);return answer;}</description>
    </item>
    
    <item>
      <title>[프로그래머스]문자열을 정수로 바꾸기</title>
      <link>https://jyukki97.github.io/blog/2019-12-20-stoi/</link>
      <pubDate>Fri, 20 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-12-20-stoi/</guid>
      <description>https://programmers.co.kr
풀이:  문자열 s를 숫자로 변환한 결과를 리턴한다.  코드: 사용언어 : c++
#include &amp;lt;string&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std;int solution(string s) {int answer = 0;return answer;}</description>
    </item>
    
    <item>
      <title>[프로그래머스]같은 숫자는 싫어</title>
      <link>https://jyukki97.github.io/blog/2019-12-19-samesum/</link>
      <pubDate>Thu, 19 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-12-19-samesum/</guid>
      <description>https://programmers.co.kr
풀이:  배열 arr에서 연속적인 숫자는 하나를 제외하고 모두 삭제한 배열을 리턴한다.  코드: 사용언어 : c++
#include &amp;lt;vector&amp;gt;#include &amp;lt;iostream&amp;gt;using namespace std;vector&amp;lt;int&amp;gt; solution(vector&amp;lt;int&amp;gt; arr) {vector&amp;lt;int&amp;gt; answer;for (int i : arr) {if (answer.size() &amp;gt; 0) {if (answer.back() != i) {answer.push_back(i);}}else {answer.push_back(i);}}return answer;}</description>
    </item>
    
    <item>
      <title>[프로그래머스]소수 찾기</title>
      <link>https://jyukki97.github.io/blog/2019-12-19-findpnum/</link>
      <pubDate>Thu, 19 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-12-19-findpnum/</guid>
      <description>https://programmers.co.kr
풀이:  2이상 n이하의 수들 중 소수의 갯수를 구하여 출력한다.  코드: 사용언어 : c++
#include &amp;lt;string&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;math.h&amp;gt;using namespace std;int solution(int n) {vector&amp;lt;int&amp;gt; q = { 2 };for (int i = 3;i &amp;lt;= n;i++) {bool w = true;for (int t : q) {if (t &amp;gt; sqrt(i)) {break;}if (i % t == 0) {w = false;break;}}if (w == true) {q.</description>
    </item>
    
    <item>
      <title>[프로그래머스]수박수박수박수박수박수?</title>
      <link>https://jyukki97.github.io/blog/2019-12-19-subaksubak/</link>
      <pubDate>Thu, 19 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-12-19-subaksubak/</guid>
      <description>https://programmers.co.kr
풀이:  &amp;ldquo;수박수박수&amp;hellip;&amp;rdquo; 의 패턴을 유지하는 n만큼의 길이의 문자열을 리턴한다.  코드: 사용언어 : c++
#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;stdbool.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt;#include &amp;lt;string.h&amp;gt;char* solution(int n) {bool c = true;char a[] = &amp;#34;수&amp;#34;;char b[] = &amp;#34;박&amp;#34;;char* answer = (char*)malloc(sizeof(char)*3*n + 1);for (int i = 0;i &amp;lt; 3*n;i+=3) {if (c) {strcpy(answer + i, a);c = false;}else {strcpy(answer + i, b);c = true;}}return answer;}</description>
    </item>
    
    <item>
      <title>[프로그래머스]서울에서 김서방 찾기</title>
      <link>https://jyukki97.github.io/blog/2019-12-18-findkim/</link>
      <pubDate>Wed, 18 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-12-18-findkim/</guid>
      <description>https://programmers.co.kr
풀이:  string 배열 seoul의 원소 중 &amp;ldquo;Kim&amp;quot;의 위치를 찾아 반환한다.  코드: 사용언어 : c++
#include &amp;lt;string&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std;string solution(vector&amp;lt;string&amp;gt; seoul) {for (int i = 0;i &amp;lt; seoul.size();i++)if (seoul[i] == &amp;#34;Kim&amp;#34;)return &amp;#34;김서방은 &amp;#34; + to_string(i) + &amp;#34;에 있다&amp;#34;;}</description>
    </item>
    
    <item>
      <title>[프로그래머스]문자열 다루기 기본</title>
      <link>https://jyukki97.github.io/blog/2019-12-17-stringbase/</link>
      <pubDate>Tue, 17 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-12-17-stringbase/</guid>
      <description>https://programmers.co.kr
풀이:  문자열 s의 길이가 4 또는 6 이고, 숫자로만 구성되어있는지 확인 후 아니라면 false를 리턴  코드: 사용언어 : c++
#include &amp;lt;string&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std;bool solution(string s) {bool answer = true;if (s.length() != 4 &amp;amp;&amp;amp; s.length() != 6) {answer = false;}else {for (int i = 0;i &amp;lt; s.length();i++) {if (s[i] &amp;gt; &amp;#39;9&amp;#39;) {answer = false;break;}}}return answer;}</description>
    </item>
    
    <item>
      <title>[프로그래머스]문자열 내 p와 y의 개수</title>
      <link>https://jyukki97.github.io/blog/2019-12-16-py/</link>
      <pubDate>Mon, 16 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-12-16-py/</guid>
      <description>https://programmers.co.kr
풀이:  문자열 s의 모든 원소를 보고 p,P 이면 p의 갯수를 올리고, y,Y이면 y의 갯수를 올린다. p의 갯수와 y의 갯수가 같다면 true 다르다면 false 를 리턴한다.  코드: 사용언어 : c++
#include &amp;lt;string&amp;gt;#include &amp;lt;iostream&amp;gt;using namespace std;bool solution(string s){bool answer = true;int p = 0;int y = 0;for (int i = 0;i &amp;lt; s.length();i++) {if (s[i] == &amp;#39;p&amp;#39; || s[i] == &amp;#39;P&amp;#39;) {p++;}if (s[i] == &amp;#39;y&amp;#39; || s[i] == &amp;#39;Y&amp;#39;) {y++;}}if (p !</description>
    </item>
    
    <item>
      <title>[프로그래머스]체육복</title>
      <link>https://jyukki97.github.io/blog/2019-12-15-gymclothes/</link>
      <pubDate>Sun, 15 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-12-15-gymclothes/</guid>
      <description>https://programmers.co.kr
풀이:   학생 전체 중 체육복을 잃어버린 학생과 체육복을 추가로 가져온 학생을 정리한다.(체육복을 추가로 가져온 학생들 중 체육복을 잃어버린 학생이 있을 수 있기 때문에)
  체육복이 없는 학생 중 양 옆에 여벌의 체육복을 가져온 학생이 있는경우 빌려입는다.
  전체 학생 중 체육복이 1개 이상 있는 학생들의 수를 리턴한다.
  주의 사항:   체육복을 추가로 가져온 학생들 중 체육복을 잃어버린 학생이 있을 수 있다.
  체육복을 추가로 가져오지 않았을 경우, 옆 사람에게 체육복을 추가로 얻어도 다른 사람에게 양도할 수 없다.</description>
    </item>
    
    <item>
      <title>[프로그래머스]k번째 수</title>
      <link>https://jyukki97.github.io/blog/2019-12-14-knum/</link>
      <pubDate>Sat, 14 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-12-14-knum/</guid>
      <description>https://programmers.co.kr
풀이:  array 배열의 commands[0]번째부터 commands[1]번째 까지 자른 후 정렬한다. 자른 배열의 commands[2] 번째 숫자를 출력한다. commands 배열의 길이만큼 반복한다.  코드: 사용언어 : c++
#include &amp;lt;string&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;vector&amp;lt;int&amp;gt; solution(vector&amp;lt;int&amp;gt; array, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; commands) {vector&amp;lt;int&amp;gt; answer;for(int i=0;i&amp;lt;commands.size();i++){vector&amp;lt;int&amp;gt; a = array;sort(a.begin()+commands[i][0]-1,a.begin()+commands[i][1]);answer.push_back(a[commands[i][0] + commands[i][2] - 2]); }return answer;}</description>
    </item>
    
    <item>
      <title>[프로그래머스]2016년</title>
      <link>https://jyukki97.github.io/blog/2019-12-13-2016%EB%85%84/</link>
      <pubDate>Fri, 13 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-12-13-2016%EB%85%84/</guid>
      <description>https://programmers.co.kr
풀이:  매 달 날짜를 계산하여 원하는 날짜의 요일을 구한다,  주의사항:  2016년은 윤년이다. 1월 1일은 금요일이다.  코드: 사용언어 : c++
#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;stdbool.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt;char* solution(int a, int b) {// 리턴할 값은 메모리를 동적 할당해주세요. int m[13] = { 0,31,29,31,30,31,30,31,31,30,31,30,31 };const char *d[8]= { &amp;#34;THU&amp;#34;,&amp;#34;FRI&amp;#34;,&amp;#34;SAT&amp;#34;,&amp;#34;SUN&amp;#34;,&amp;#34;MON&amp;#34;,&amp;#34;TUE&amp;#34;,&amp;#34;WED&amp;#34; };for(int i = 1;i &amp;lt; a;i++) {b += m[i];}b %= 7;return d[b];}</description>
    </item>
    
    <item>
      <title>[백준]11399 ATM</title>
      <link>https://jyukki97.github.io/blog/2019-06-20-11399/</link>
      <pubDate>Thu, 20 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-06-20-11399/</guid>
      <description>https://www.acmicpc.net/problem/11399
풀이:  돈을 인출하는데 필요한 시간을 입력받는다. 입력받은 시간을 정렬한다. 정렬한 값을 n-i를 곱해서 더해준다.  코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;int main() {int n,r=0,a[1001];cin &amp;gt;&amp;gt; n;for (int i = 0; i &amp;lt; n; i++)cin &amp;gt;&amp;gt; a[i];sort(&amp;amp;a[0], &amp;amp;a[n]);for (int i = 0; i &amp;lt; n; i++)r += a[i] * (n - i);cout &amp;lt;&amp;lt; r &amp;lt;&amp;lt; endl;}</description>
    </item>
    
    <item>
      <title>[백준]10971 외판원 순회 2</title>
      <link>https://jyukki97.github.io/blog/2019-06-09-10971/</link>
      <pubDate>Sun, 09 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-06-09-10971/</guid>
      <description>https://www.acmicpc.net/problem/10971
풀이:  [백준]2098 외판원순회 와 같으므로 참고  코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;int w[17][17],d[17][100000], n;int T(int a, int b) {if ((1 &amp;lt;&amp;lt; n) - 1 == b &amp;amp;&amp;amp; w[a][0] != 0)return w[a][0];int &amp;amp;r = d[a][b];if (r &amp;gt; 0)return r;r = 100000000;for (int i = 0; i &amp;lt; n; i++)if (w[a][i] != 0 &amp;amp;&amp;amp; (b &amp;amp; (1 &amp;lt;&amp;lt; i)) == 0)r = min(r, w[a][i] + T(i, b | (1 &amp;lt;&amp;lt; i)));return r;}int main(void) {cin &amp;gt;&amp;gt; n;for (int i = 0; i &amp;lt; n; i++)for (int t = 0; t &amp;lt; n; t++)cin &amp;gt;&amp;gt; w[i][t];cout &amp;lt;&amp;lt; T(0, 1) &amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
    <item>
      <title>[백준]11047 동전 0</title>
      <link>https://jyukki97.github.io/blog/2019-06-08-11047/</link>
      <pubDate>Sat, 08 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-06-08-11047/</guid>
      <description>https://www.acmicpc.net/problem/11047
풀이:  동전에 가격이 높은 것 부터 내가 필요한 가격에서 빼준다. 빼준 횟수만큼 카운트를 높여준다. 카운트를 출력한다. ( i ≥ 2인 경우에 Ai는 Ai-1의 배수) 조건으로 인해 그냥 높은 것 부터 빼줘도 문제가 생기지않는다.  코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;using namespace std;int main() {int n, k, s[12], c = 0;cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; k;while (n--)cin &amp;gt;&amp;gt; s[n];while (k) {c += k / s[++n]; k %= s[n];}cout &amp;lt;&amp;lt; c &amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
    <item>
      <title>[백준]12015 가장 긴 증가하는 부분 수열 2</title>
      <link>https://jyukki97.github.io/blog/2019-06-06-12015/</link>
      <pubDate>Thu, 06 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-06-06-12015/</guid>
      <description>https://www.acmicpc.net/problem/12015
풀이:  https://jyukki97.github.io/2352/ 와 같은 문제이므로 참고  코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std;vector&amp;lt;int&amp;gt;d;int main(void) {int n, s, l;cin &amp;gt;&amp;gt; n;while (n--) {cin &amp;gt;&amp;gt; s;l = lower_bound(d.begin(), d.end(), s) - d.begin();if (l == d.size())d.push_back(s);elsed[l] = s;}cout &amp;lt;&amp;lt; d.size() &amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
    <item>
      <title>[백준]1365 꼬인 전깃줄</title>
      <link>https://jyukki97.github.io/blog/2019-06-05-1365/</link>
      <pubDate>Wed, 05 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-06-05-1365/</guid>
      <description>https://www.acmicpc.net/problem/1365
풀이:  https://jyukki97.github.io/2352/ 와 같은 문제이므로 참고  코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std;vector&amp;lt;int&amp;gt;d;int main(void) {int n, s, l;cin &amp;gt;&amp;gt; n;for (int i = 0; i &amp;lt; n; i++) {cin &amp;gt;&amp;gt; s;l = lower_bound(d.begin(), d.end(), s) - d.begin();if (l == d.size())d.push_back(s);elsed[l] = s;}cout &amp;lt;&amp;lt; n - d.size() &amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
    <item>
      <title>[백준]2352 반도체 설계</title>
      <link>https://jyukki97.github.io/blog/2019-06-04-2352/</link>
      <pubDate>Tue, 04 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-06-04-2352/</guid>
      <description>https://www.acmicpc.net/problem/2352
풀이:  맨 처음 값부터 하나 하나 입력받는다. 입력받은 값이 벡터 안에 있는 값들 보다 크다면 벡터에 맨 뒤에 넣는다. 벡터의 처음부터 검색했을 때, 입력받은 값보다 큰 값이 있다면, 그 값과 교체한다. 벡터의 원소 갯수를 출력한다. 일반적으로 for문을 두개 쓴 O(n^2)의 코드는 시간초과가 나므로 주의하자  코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std;vector&amp;lt;int&amp;gt;d;int main(void) {int n, s, l;cin &amp;gt;&amp;gt; n;while(n--) {cin &amp;gt;&amp;gt; s;l = lower_bound(d.</description>
    </item>
    
    <item>
      <title>[백준]1495 기타리스트</title>
      <link>https://jyukki97.github.io/blog/2019-06-02-1495/</link>
      <pubDate>Sun, 02 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-06-02-1495/</guid>
      <description>https://www.acmicpc.net/problem/1495
풀이:  dp[a][b]를 a 번째 곡을 연주 할 때, b 볼륨으로 연주 할 수 있는가? 라고 하자. dp[0][S]는 0 번째 곡을 연주 할 때, S 볼륨으로 연주할 수 있으므로(시작지점) 1을 할당한다. 0번째 곡을 연주할 때, S볼륨으로 연주가 가능하다면, 1번째 곡을 연주할 때, S+s[1] or S-s[1] 볼륨도 연주 가능하다(0&amp;lt;=볼륨&amp;lt;=m 일때) 즉, dp[i][t + s[i]] = dp[i - 1][t] or dp[i][t - s[i]] = dp[i - 1][t] 마지막에 dp[N]값을 모두 순환하며, 가장 높은 값을 출력하고, 가능한 볼륨이 없다면 -1을 출력한다.</description>
    </item>
    
    <item>
      <title>[백준]4781 사탕 가게</title>
      <link>https://jyukki97.github.io/blog/2019-05-30-4781/</link>
      <pubDate>Thu, 30 May 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-05-30-4781/</guid>
      <description>https://www.acmicpc.net/problem/4781
풀이:  dp[a]를 a원으로 구매할 수 있는 가장 높은 칼로리라고 한다. 사탕의 칼로리를 s, 가격을 d라고 했을 때, 현제 a원으로 구매할 수 있는 가장 높은 칼로리와 a-d원 으로 구매할 수 있는 가장높을칼로리 + s 를 비교하여 높은 값으로 교체한다. 즉, dp[t] = max(dp[t], dp[t - d] + s) 를 반복하여 do[m]값을 구한다.  코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;double M1, d1;int N, M, s, d, dp[10002];int main(void) {while (1) {memset(dp, 0, sizeof(dp));cin &amp;gt;&amp;gt; N &amp;gt;&amp;gt; M1;if (N == 0)break;M = M1 * 100;for (int i = 0; i &amp;lt; N; i++) {cin &amp;gt;&amp;gt; s &amp;gt;&amp;gt; d1;d = d1 * 100;for (int t = d; t &amp;lt;= M; t++) dp[t] = max(dp[t], dp[t - d] + s);}cout &amp;lt;&amp;lt; dp[M] &amp;lt;&amp;lt; endl;}return 0;}</description>
    </item>
    
    <item>
      <title>[백준]2662 기업 투자</title>
      <link>https://jyukki97.github.io/blog/2019-05-29-2662/</link>
      <pubDate>Wed, 29 May 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-05-29-2662/</guid>
      <description>https://www.acmicpc.net/problem/2662
풀이:  dp[a][b]를 남은 금액이 a원 일 때, b번째 기업에 투자해서 얻을 수 있는 최대 이익이라고 하자. 첫번째 기업에 0원을 투자하는 것 부터 M번째 기업에 N원을 투자하는 것 까지 반복하여 최대 이익금을 구한다. 최대 이익금일 때 각 기업에 얼마를 투자했는지 구한 후 출력한다. 시간초과가 나기 쉬우므로 메모이제이션을 한다.  코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;cstring&amp;gt;using namespace std;int N, M, s[302][22], dp[302][22], x[302][22];int q(int a, int c) {if (c &amp;gt; M)return 0;int &amp;amp;m = dp[a][c];if (m !</description>
    </item>
    
    <item>
      <title>[백준]1937 욕심쟁이 판다</title>
      <link>https://jyukki97.github.io/blog/2019-05-28-1937/</link>
      <pubDate>Tue, 28 May 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-05-28-1937/</guid>
      <description>https://www.acmicpc.net/problem/1937
풀이:  k[a][b]를 (a , b)지점에서 시작한 판다가 살아남은 최대 일수라고 한다. (a, b) 주변 십자가 방향 지점( (1,0), (-1, 0), (0, 1), (0, -1)) 에서 대나무의 양이 (a, b) 보다 낮다면 그 지점에 최대 일수에서 +1 한 값이 k[a][b] 값이 된다. 높은 값에서 낮은값으로 찾아가면서 최대 일수를 구한다. 시간초과가 날 수 있으므로 메모이제이션을 통해 시행횟수를 제한해준다.  코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;int n, s[510][510], k[510][510];int dx[] = { 1,0,0,-1 };int dy[] = { 0,1,-1,0 };int panda(int a, int b){for (int y = 0; y &amp;lt; 4; y++)if (a + dy[y] &amp;gt;= 0 &amp;amp;&amp;amp; a + dy[y] &amp;lt; n &amp;amp;&amp;amp; b + dx[y] &amp;gt;= 0 &amp;amp;&amp;amp; b + dx[y] &amp;lt; n)if (s[a][b] &amp;lt; s[a + dy[y]][b + dx[y]]) {if(k[a + dy[y]][b + dx[y]] == 1)k[a][b] = max(k[a][b], panda(a + dy[y], b + dx[y]) + 1);elsek[a][b] = max(k[a][b], k[a + dy[y]][b + dx[y]] + 1);}return k[a][b];}int main(void) {cin &amp;gt;&amp;gt; n;int m = 1;fill(&amp;amp;k[0][0], &amp;amp;k[n][n], 1);for (int i = 0; i &amp;lt; n; i++)for (int t = 0; t &amp;lt; n; t++)cin &amp;gt;&amp;gt; s[i][t];for (int i = 0; i &amp;lt; n; i++)for (int t = 0; t &amp;lt; n; t++)m = max(m, panda(i, t));cout &amp;lt;&amp;lt; m &amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
    <item>
      <title>[백준]5069 미로에 갇힌 상근</title>
      <link>https://jyukki97.github.io/blog/2019-05-27-5069/</link>
      <pubDate>Mon, 27 May 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-05-27-5069/</guid>
      <description>https://www.acmicpc.net/problem/5069
풀이:  s[n][t][y]를 n번 이동해서 (t, y)인 방으로 다시 돌아오는 경우의 수라고 한다. 처음 상근이가 있는 방을 (10, 10)이라고 한다(n의 최대 수가 14 이므로 10칸을 넘어가지 않기 때문에) s[n][10][10] 은 n번 이동해서 상근이가 있는 방으로 돌아와야하므로 상근이의 근처에 있는 모든 n-1번 이동하여 돌아오는 경우의 수들의 합과 같다. 즉 s[n][10][10] = s[n-1][10][11] + s[n-1][10][9] + s[n-1][11][11] + s[n-1][11][10] + s[n-1][9][9] + s[n-1][9][10]  코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;using namespace std;int s[15][21][21];int dy[] = { 0,0,1,1,-1,-1 };int dx[] = { 1,-1,1,0,-1,0 };int main(void) {int T, a;cin &amp;gt;&amp;gt; T;s[0][10][10] = 1;for (int i = 1; i &amp;lt; 15; i++)for (int t = 1; t &amp;lt; 21; t++)for (int y = 1; y &amp;lt; 21; y++)for (int u = 0; u &amp;lt; 6; u++)if (t + dx[u] &amp;gt; 0 &amp;amp;&amp;amp; t + dx[u] &amp;lt; 21 &amp;amp;&amp;amp; y + dy[u] &amp;gt; 0 &amp;amp;&amp;amp; y + dy[u] &amp;lt; 21)s[i][t][y] += s[i - 1][t + dx[u]][y + dy[u]];while (T--) {cin &amp;gt;&amp;gt; a;cout &amp;lt;&amp;lt; s[a][10][10] &amp;lt;&amp;lt; endl;}return 0;}</description>
    </item>
    
    <item>
      <title>[백준]1351 무한 수열</title>
      <link>https://jyukki97.github.io/blog/2019-03-29-1351/</link>
      <pubDate>Fri, 29 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-03-29-1351/</guid>
      <description>https://www.acmicpc.net/problem/1351
풀이:  N번째 수열부터 차례대로 찾아나간다. N번째 수열이 map 에 존재한다면 그대로 리턴, 없다면 N = a/b + a/c 로 돌아가서 찾기 N이 0이라면 1을 리턴 각각의 값이 매우 크므로 long long 사용 실패 코드 예시처럼 map을 쓰지않고 리턴을 할 경우 같은 수열이 여러번 중복되어 계산되기 때문에 시간초과가 날 수 있다.  코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;map&amp;gt;using namespace std;long long a, b, c;map&amp;lt;long long, long long&amp;gt; n;long long infi(long long q) {if (q == 0)return 1;if (n.</description>
    </item>
    
    <item>
      <title>[백준]2338 긴자리 계산</title>
      <link>https://jyukki97.github.io/blog/2018-02-04-2338/</link>
      <pubDate>Sun, 04 Feb 2018 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2018-02-04-2338/</guid>
      <description>https://www.acmicpc.net/problem/2338
풀이:  두 수를 입력받는다. 두 수를 더한값, 뺀값, 곱한값을 각각 출력한다.  코드: 사용언어 : Python 3
a,b=int(input()),int(input())print(a+b,a-b,a*b,sep=&amp;#39;\n&amp;#39;)</description>
    </item>
    
    <item>
      <title>[백준]2154 수 이어 쓰기 3</title>
      <link>https://jyukki97.github.io/blog/2018-02-03-2154/</link>
      <pubDate>Sat, 03 Feb 2018 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2018-02-03-2154/</guid>
      <description>https://www.acmicpc.net/problem/2154
풀이:  전체 수를 string타입으로 나열한다. 그 숫자 중 제시된 숫자 n이 맨 처음으로 나오는 인덱스를 출력한다.  코드: 사용언어 : Python 3
n,s=int(input()),&amp;#34;&amp;#34;for i in range(1,n+1):s+=str(i)print(s.find(str(n))+1)</description>
    </item>
    
    <item>
      <title>[백준]2624 동전 바꿔주기</title>
      <link>https://jyukki97.github.io/blog/2018-01-11-2624/</link>
      <pubDate>Thu, 11 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2018-01-11-2624/</guid>
      <description>https://www.acmicpc.net/problem/2624
풀이:   coin[i] : i원의 지폐를 동전으로 교환할 수 있는 경우의 수
  지폐의 가격 + 동전의 가격 * 동전의 개수를 계속 쌓아간다.
  코드: #include &amp;lt;iostream&amp;gt;using namespace std;pair&amp;lt;int, int&amp;gt; a[101];int coin[10001] = { 0 };int main(void) {int T, k, n, m;cin &amp;gt;&amp;gt; T &amp;gt;&amp;gt; k;for (int i = 0; i &amp;lt; k; i++) {cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;a[i] = make_pair(n, m);}coin[0] = 1;for (int i = 0; i &amp;lt; k; i++)for (int t = T; t &amp;gt; 0 ; t--)for (int y = 1; y &amp;lt;= a[i].</description>
    </item>
    
    <item>
      <title>[백준]3908 서로 다른 소수의 합</title>
      <link>https://jyukki97.github.io/blog/2018-01-10-3908/</link>
      <pubDate>Wed, 10 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2018-01-10-3908/</guid>
      <description>https://www.acmicpc.net/problem/3908
풀이:  소수를 찾는다. 소수를 하나씩 추가해가면서 a[n][k]를 찾는다. a[n][k] : 양의 정수 n을 서로 다른 k개의 소수의 합으로 나타낼 수 있는 최대의 경우의 수  코드: #include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;math.h&amp;gt;#include &amp;lt;string.h&amp;gt;using namespace std;int	T, n, k, a[1122][16] = { 0 };bool isprime[1122];vector&amp;lt;int&amp;gt; b;int prime() {memset(isprime, 1, sizeof(isprime));isprime[0] = isprime[1] = false;for (int i = 2; i &amp;lt; sqrt(1122); i++)if(isprime[i])for (int t = i * i; t &amp;lt; 1122; t += i)isprime[t] = false;for (int i = 2; i &amp;lt; 1122; i++) if (isprime[i]) b.</description>
    </item>
    
    <item>
      <title>[백준]11568 민균이의 계략</title>
      <link>https://jyukki97.github.io/blog/2018-01-02-11568/</link>
      <pubDate>Tue, 02 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2018-01-02-11568/</guid>
      <description>https://www.acmicpc.net/problem/11568
풀이:  11053 가장 긴 증가하는 부분 수열 의 문제와 같으므로 링크를 참고  코드: #include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;long long a[1001] = { 0 }, b[1001];int main(void) {long long n, temp;cin &amp;gt;&amp;gt; n;for (int i = 0; i &amp;lt; n; i++) {cin &amp;gt;&amp;gt; a[i];b[i] = 1;}for (int i = 0; i &amp;lt; n; i++) {temp = 0;for (int t = 0; t &amp;lt;= i; t++) {if (a[i] &amp;gt; a[i - t])temp = max(b[i - t], temp);}b[i] += temp;}for (int i = 0; i &amp;lt; n; i++) {temp = max(b[i], temp);}cout &amp;lt;&amp;lt; temp &amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
    <item>
      <title>[백준]2228 구간 나누기</title>
      <link>https://jyukki97.github.io/blog/2017-12-26-2228/</link>
      <pubDate>Tue, 26 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-12-26-2228/</guid>
      <description>https://www.acmicpc.net/problem/2228
풀이:   dp[n][m] : n개의 숫자를 m개의 구간으로 나눈 최대 합
  dp[i][t] = dp[i - 1][t] : i번째 수를 포함하지 않는 경우
  dp[i][t] = max(dp[i][t], (t == 1 ? 0 : dp[y - 1][t - 1]) + a[i] - a[y]) : i번째 수를 포함하는 경우 i번째를 포함하므로 구간을 하나 빼고 그것에 i번째 수를 포함하는 구간을 더한다.
  max함수를 쓰므로 dp 초기화를 잘해줘야한다.
  코드: #include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;int a[101] = { 0 }, dp[101][52] = { 0 };int main(void) {int n, m, temp;cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;fill(dp[0] + 1, dp[0] + m + 1, -2147483646);for (int i = 1; i &amp;lt;= n; i++) {cin &amp;gt;&amp;gt; temp;a[i] = a[i - 1] + temp;for (int t = 1; t &amp;lt;= m; t++) {dp[i][t] = dp[i - 1][t];for (int y = i - 1; y / 2 &amp;gt;= t - 1; y--) {dp[i][t] = max(dp[i][t], (t == 1 ?</description>
    </item>
    
    <item>
      <title>[백준]7579 앱</title>
      <link>https://jyukki97.github.io/blog/2017-12-21-7579/</link>
      <pubDate>Thu, 21 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-12-21-7579/</guid>
      <description>https://www.acmicpc.net/problem/7579
풀이:  처음 문제를 풀때는 DP[메모리]로 풀었더니 시간초과가 났다. 그래서 DP[c]로 풀게되었다. 가격이 0이고 메모리가 0인 지점부터 하나하나 더해가면서 만들어나간다. 그 후 가격이 낮은 곳부터 검사하면서 메모리가 M값보다 높아지면 출력한다. iter = a.end(); 를 처음에 iter = a.begin(); 으로 했을 때 출력이 잘못되는 것을 발견하였다. 아마 작은 값부터 더해가는 과정에 겹치는 값이 생겼을 것이라고 본다.  코드: #include &amp;lt;iostream&amp;gt;#include &amp;lt;map&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;map&amp;lt;int, int&amp;gt; a;int k[101], c[101];int main(void) {int n, m, size, temp;cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;a[0] = 0;for (int i = 0; i &amp;lt; n; i++)cin &amp;gt;&amp;gt; k[i];for (int i = 0; i &amp;lt; n; i++)cin &amp;gt;&amp;gt; c[i];map&amp;lt;int, int&amp;gt;::iterator iter;for (int i = 0; i &amp;lt; n; i++) {size = a.</description>
    </item>
    
    <item>
      <title>[백준]1793 타일링</title>
      <link>https://jyukki97.github.io/blog/2017-12-17-1793/</link>
      <pubDate>Sun, 17 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-12-17-1793/</guid>
      <description>https://www.acmicpc.net/problem/1793
풀이: 11727 2XN 타일링2
 DP는 링크와 같으므로 링크를 참고 링크의 코드와 다르게 int 보다 큰 값을 출력해야하므로 어려움이 있다. vector를 사용하여 int를 한자리수 씩 계산하는 방법으로 풀었다. 만약 자릿수의 값이 10보다 커지면 다음 자릿수의 값을 그만큼 올려주는 식으로 풀었다.  코드: #include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std;vector&amp;lt;int&amp;gt; a[251];int main(void) {int	n, temp;int cnt = 3;a[0].push_back(1);a[1].push_back(1);a[2].push_back(3);while(cin &amp;gt;&amp;gt; n){if (a[n].size() == 0) {for (int t = cnt; t &amp;lt; n + 1; t++) {int carry = 0;for (int y = 0; y &amp;lt; a[t - 2].</description>
    </item>
    
    <item>
      <title>[백준]2718 타일 채우기</title>
      <link>https://jyukki97.github.io/blog/2017-12-16-2718/</link>
      <pubDate>Sat, 16 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-12-16-2718/</guid>
      <description>https://www.acmicpc.net/problem/2718
풀이:  a[t] 는 4 x t 크기의 타일을 채울 수 있는 경우의 수 a[t] = a[t - 1] + a[t - 2] * 5 + a[t - 3] - a[t - 4];  코드: #include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;int a[30] = { 1,5,11,36 };int main(void) {int T,n,cnt;cnt = 5;cin &amp;gt;&amp;gt; T;for (int i = 0; i &amp;lt; T; i++) {cin &amp;gt;&amp;gt; n;if (a[n - 1] == 0)for (int t = cnt-1; t &amp;lt; n; t++) {a[t] = a[t - 1] + a[t - 2] * 5 + a[t - 3] - a[t - 4];}cout &amp;lt;&amp;lt; a[n - 1] &amp;lt;&amp;lt; endl;cnt = max(cnt, n);}return 0;}</description>
    </item>
    
    <item>
      <title>[백준]11722 가장 긴 감소하는 부분 수열</title>
      <link>https://jyukki97.github.io/blog/2017-12-15-11722/</link>
      <pubDate>Fri, 15 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-12-15-11722/</guid>
      <description>https://www.acmicpc.net/problem/11722
풀이:  11053 가장 긴 증가하는 부분 수열의 문제와 똑같으므로 링크를 참고  코드: #include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;int main(void) {int n, temp;cin &amp;gt;&amp;gt; n;int a[1001] = { 0 };int b[1001];for (int i = 0; i &amp;lt; n; i++) {cin &amp;gt;&amp;gt; a[i];b[i] = 1;}for (int i = 0; i &amp;lt; n; i++) {temp = 0;for (int t = 0; t &amp;lt;= i; t++) {if (a[i] &amp;lt; a[i - t])temp = max(b[i - t], temp);}b[i] += temp;}for (int i = 0; i &amp;lt; n; i++) {temp = max(b[i], temp);}cout &amp;lt;&amp;lt; temp &amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
    <item>
      <title>[백준]4883 삼각 그래프</title>
      <link>https://jyukki97.github.io/blog/2017-12-14-4883/</link>
      <pubDate>Thu, 14 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-12-14-4883/</guid>
      <description>https://www.acmicpc.net/problem/4883
풀이:  N X 3 행렬에서 맨 위 중앙에서 출발하여 맨 아래 중앙까지 가는 경로 중 가장 최소 비용을 찾는 문제 각 i행의 1,2,3번째 열의 각각 최소비용은 i-1 번째 행에서의 최소 비용을 더해준 값이다. 맨 마지막 행의 2번째 열을 출력한다. 0이 출력되면 끝나므로 if문으로 while 문을 빠져나갈 수 있게한다. 하나의 테스트케이스마다 숫자를 출력해야하므로 count 값을 각 케이스마다 ++해준다.  코드: #include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;int a[100005][3], b[100005][3];int main(void) {int count = 1;while (true) {int n, temp, temp2;cin &amp;gt;&amp;gt; n;if (n == 0)break;for (int i = 0; i &amp;lt; n; i++) {for (int t = 0; t &amp;lt; 3; t++) {cin &amp;gt;&amp;gt; a[i][t];b[i][t] = a[i][t];}}b[0][2] += b[0][1];b[1][0] += b[0][1];b[1][1] += min(min(b[0][1],b[1][0]), b[0][2]);b[1][2] += min(min(b[1][1], b[0][1]), b[0][2]);for (int i = 2; i &amp;lt; n; i++) {for (int t = 0; t &amp;lt; 3; t++) {if (t == 0)b[i][t] += min(b[i - 1][t], b[i - 1][t + 1]);else if (t == 1)b[i][t] += min(min(b[i - 1][t], b[i - 1][t + 1]), min(b[i - 1][t - 1], b[i][t - 1]));else if (t == 2)b[i][t] += min(min(b[i - 1][t - 1], b[i - 1][t]), b[i][t - 1]);}}cout &amp;lt;&amp;lt; count &amp;lt;&amp;lt; &amp;#34;.</description>
    </item>
    
    <item>
      <title>[백준]10164 격자상의 경로</title>
      <link>https://jyukki97.github.io/blog/2017-12-13-10164/</link>
      <pubDate>Wed, 13 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-12-13-10164/</guid>
      <description>https://www.acmicpc.net/problem/10164
풀이:  N X M 행렬에서 K번째 수를 꼭 지나치면서 오른쪽 맨 아래까지 가는 최대 경우의 수 1~K 까지 가는 경우의 수 * K~M*N 까지 가는 경우의 수 DP[i][t] i행 t열로 갈 수 있는 경우의 수 DP[i][t] = DP[i-1][t] + DP[i][t-1]  코드: #include &amp;lt;iostream&amp;gt;using namespace std;int a[16][16] = { 0 };int b[16][16] = { 0 };int main(void) {int n, m, k, q, w, e, r;cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m &amp;gt;&amp;gt; k;q = k / m + 1;w = k%m;if (k !</description>
    </item>
    
    <item>
      <title>[백준]11053 가장 긴 증가하는 부분 수열</title>
      <link>https://jyukki97.github.io/blog/2017-12-12-11053/</link>
      <pubDate>Tue, 12 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-12-12-11053/</guid>
      <description>https://www.acmicpc.net/problem/11053
풀이:  1965 상자넣기의 문제와 똑같으므로 링크를 참고  코드: #include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;int main(void) {int n, temp;cin &amp;gt;&amp;gt; n;int a[1001] = { 0 };int b[1001];for (int i = 0; i &amp;lt; n; i++) {cin &amp;gt;&amp;gt; a[i];b[i] = 1;}for (int i = 0; i &amp;lt; n; i++) {temp = 0;for (int t = 0; t &amp;lt;= i; t++) {if (a[i] &amp;gt; a[i - t])temp = max(b[i - t], temp);}b[i] += temp;}for (int i = 0; i &amp;lt; n; i++) {temp = max(b[i], temp);}cout &amp;lt;&amp;lt; temp &amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
    <item>
      <title>[백준]6603 로또</title>
      <link>https://jyukki97.github.io/blog/2017-12-12-6603/</link>
      <pubDate>Tue, 12 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-12-12-6603/</guid>
      <description>https://www.acmicpc.net/problem/6603
풀이:  N 개의 로또 번호 중 6개를 선택하여 로또를 만드는 프로그램 6개의 번호를 사전순으로 하나씩 선택하면서 출력한다. 출력 사이사이에 빈칸을 만들어주고, 하나의 테스트 케이스가 끝나면 빈 줄을 하나 출력한다. 0이 출력되면 끝나므로 while 문 안에 if문으로 제한을 넣어준다.  코드: #include &amp;lt;iostream&amp;gt;using namespace std;int a[13];int main(void) {while (true) {int n;cin &amp;gt;&amp;gt; n;if (n == 0)break;for (int i = 0; i &amp;lt; n; i++) {cin &amp;gt;&amp;gt; a[i];}int b[6] = { 0,1,2,3,4,5 };while (true) {cout &amp;lt;&amp;lt; a[b[0]] &amp;lt;&amp;lt; &amp;#34;&amp;#34; &amp;lt;&amp;lt; a[b[1]] &amp;lt;&amp;lt; &amp;#34;&amp;#34; &amp;lt;&amp;lt; a[b[2]] &amp;lt;&amp;lt; &amp;#34;&amp;#34; &amp;lt;&amp;lt; a[b[3]] &amp;lt;&amp;lt; &amp;#34;&amp;#34; &amp;lt;&amp;lt; a[b[4]] &amp;lt;&amp;lt; &amp;#34;&amp;#34; &amp;lt;&amp;lt; a[b[5]] &amp;lt;&amp;lt; endl;if (b[0] &amp;gt;= n - 6)break;else if (b[1] &amp;gt;= n - 5) {b[0]++;for (int i = 0; i &amp;lt; 5; i++) {b[i + 1] = b[i] + 1;}}else if (b[2] &amp;gt;= n - 4) {b[1]++;for (int i = 1; i &amp;lt; 5; i++) {b[i + 1] = b[i] + 1;}}else if (b[3] &amp;gt;= n - 3) {b[2]++;for (int i = 2; i &amp;lt; 5; i++) {b[i + 1] = b[i] + 1;}}else if (b[4] &amp;gt;= n - 2) {b[3]++;for (int i = 3; i &amp;lt; 5; i++) {b[i + 1] = b[i] + 1;}}else if (b[5] &amp;gt;= n - 1) {b[4]++;b[5] = b[4] + 1;}elseb[5]++;}cout &amp;lt;&amp;lt; endl;}return 0;}</description>
    </item>
    
    <item>
      <title>[백준]11060 점프 점프</title>
      <link>https://jyukki97.github.io/blog/2017-12-10-11060/</link>
      <pubDate>Sun, 10 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-12-10-11060/</guid>
      <description>https://www.acmicpc.net/problem/11060
풀이:  cnt[i] 는 i번째 에서의 최소 가짓수 cnt를 모두 최댓값으로 채운 후 a[i] 이하의 값으로 점프할 때 마다 cnt[i + t] 값을 min(cnt[i + t], cnt[i] + 1) 로 해줌으로써 최소 가짓수를 찾는다 만약 도착점의 값이 처음 채운 1001과 같다면 갈 수 없는 경우이므로 -1을 출력한다.  코드: #include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;int a[1001], cnt[1001];int main(void) {int n;cin &amp;gt;&amp;gt; n;fill_n(cnt, n, 1001);for (int i = 0; i &amp;lt; n; i++) {cin &amp;gt;&amp;gt; a[i];}cnt[0] = 0;for (int i = 0; i &amp;lt; n; i++) {for (int t = 1; t &amp;lt;= a[i]; t++) {cnt[i + t] = min(cnt[i + t], cnt[i] + 1);}}if (cnt[n - 1] == 1001)cout &amp;lt;&amp;lt; &amp;#34;-1&amp;#34; &amp;lt;&amp;lt; endl;elsecout &amp;lt;&amp;lt; cnt[n - 1] &amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
    <item>
      <title>[백준]9084 동전</title>
      <link>https://jyukki97.github.io/blog/2017-12-09-9084/</link>
      <pubDate>Sat, 09 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-12-09-9084/</guid>
      <description>https://www.acmicpc.net/problem/9084
풀이:  첫번째 동전부터 경우의 수를 더해감.  코드: #include &amp;lt;iostream&amp;gt;using namespace std;int coin[10001] = { 0 };int main(void){int n, a, num;cin &amp;gt;&amp;gt; n;for (int t = 0; t &amp;lt; n; t++) {fill_n(coin, 10000, 0);cin &amp;gt;&amp;gt; a;int *q = new int[a];for (int i = 0; i &amp;lt; a; i++) {cin &amp;gt;&amp;gt; q[i];}cin &amp;gt;&amp;gt; num;for (int i = 0; i &amp;lt;= num; i++) {if (i%q[0] == 0)coin[i]++;}for (int i = 1; i &amp;lt; a; i++) {for (int t = q[i]; t &amp;lt;= num; t++) {coin[t] += coin[t - q[i]];}}cout &amp;lt;&amp;lt; coin[num] &amp;lt;&amp;lt; endl;}return 0;}</description>
    </item>
    
    <item>
      <title>[백준]1904 01타일</title>
      <link>https://jyukki97.github.io/blog/2017-12-08-1904/</link>
      <pubDate>Fri, 08 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-12-08-1904/</guid>
      <description>https://www.acmicpc.net/problem/1904
풀이:  a[i] 는 길이가 i인 모든 이진수열의 개수 a[i] = a[i - 1] + a[i - 2] 주어진 조건에 맞게 15746 으로 나눈 나머지를 출력  코드: #include &amp;lt;iostream&amp;gt;using namespace std;int a[1000001] = { 1,2 };int main(void) {int n;cin &amp;gt;&amp;gt; n;for (int i = 2; i &amp;lt; n; i++) {a[i] = (a[i - 1] % 15746 + a[i - 2] % 15746) % 15746;}cout &amp;lt;&amp;lt; a[n - 1] &amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
    <item>
      <title>[백준]11055 가장 큰 증가 부분 수열</title>
      <link>https://jyukki97.github.io/blog/2017-12-07-11055/</link>
      <pubDate>Thu, 07 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-12-07-11055/</guid>
      <description>https://www.acmicpc.net/problem/11055
풀이:  배열의 이전을 돌며 가장 합이 큰 값을 더함  코드: #include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;int a[1002], maxA[1002];int main(void) {int n;cin &amp;gt;&amp;gt; n;int maximum = 0;for (int i = 0; i &amp;lt; n; i++) {cin &amp;gt;&amp;gt; a[i];maxA[i] = a[i];}for (int i = 0; i &amp;lt; n; i++) {int temp = 0;for (int t = i-1; t &amp;gt;= 0; t--) {if (a[t] &amp;lt; a[i]) {temp = max(temp, maxA[t]);}}maxA[i] += temp;maximum = max(maximum, maxA[i]);}cout &amp;lt;&amp;lt; maximum &amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
    <item>
      <title>[백준]2957 이진 탐색 트리</title>
      <link>https://jyukki97.github.io/blog/2017-12-05-2957/</link>
      <pubDate>Tue, 05 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-12-05-2957/</guid>
      <description>https://www.acmicpc.net/problem/2957
풀이:  트리의 루트에서 부터 왼쪽 오른쪽에 삽입할때 마다 높이를 1씩 증가시켜 준다. cin , cout을 사용할 경우 시간초과가 나므로 scanf, printf 를 사용하도록 하자 출력의 사이즈가 int 사이즈를 넘어가므로 long long 을 사용하자  코드: #include &amp;lt;iostream&amp;gt;#include &amp;lt;map&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;stdio.h&amp;gt;using namespace std;int main(void) {int n, num;cin &amp;gt;&amp;gt; n;map&amp;lt;int, long long int&amp;gt; a;a[300001] = -1;a[0] = -1;long long temp = 0;for (int i = 0; i &amp;lt; n; i++) {scanf_s(&amp;#34;%d&amp;#34;, &amp;amp;num);a[num] = max((--a.</description>
    </item>
    
    <item>
      <title>[백준]2225 합분해</title>
      <link>https://jyukki97.github.io/blog/2017-12-03-2225/</link>
      <pubDate>Sun, 03 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-12-03-2225/</guid>
      <description>https://www.acmicpc.net/problem/2225
풀이:  a[i][t] 는 0~i+1 까지 정수 t+1 개를 더하여 그 합이 i+1 이 되는 경우의 수 이다. a[i][t] = a[i-1][t] + a[i][t-1] 로 나타낼 수 있다. 이때 수의 값이 너무 커져 오버플로우가 발생할 수 있으므로 1000000000으로 나눈 나머지를 출력한다.  코드: #include &amp;lt;iostream&amp;gt;using namespace std;long long a[201][201];int main(void) {int n, k;cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; k;for (int i = 0; i &amp;lt; n; i++) {a[i][0] = 1;for (int t = 1; t &amp;lt; k; t++) {if (i == 0)a[i][t] = t + 1;elsea[i][t] = ((a[i - 1][t]) % 1000000000 + (a[i][t - 1]) % 1000000000) % 1000000000;}}cout &amp;lt;&amp;lt; a[n - 1][k - 1] &amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
    <item>
      <title>[백준]11051 이항계수2</title>
      <link>https://jyukki97.github.io/blog/2017-12-02-11051/</link>
      <pubDate>Sat, 02 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-12-02-11051/</guid>
      <description>https://www.acmicpc.net/problem/11051
풀이:  nCk 를 나타내는 함수 Comb() 를 만든다. 재귀함수의 특성상 시간초과 때문에 배열에 값을 저장해놓는다.  참고: 1010 다리놓기 코드: #include &amp;lt;iostream&amp;gt;using namespace std;long long cnt[1001][1001] = { 0 };int Comb(int n, int r) {if (r == 0 || r == n)return 1;else if (r == n - 1 || r == 1)return n;if (cnt[n - 1][r] == 0)cnt[n - 1][r] = Comb(n - 1, r);if (cnt[n - 1][r - 1] == 0)cnt[n - 1][r - 1] = Comb(n - 1, r - 1);return (cnt[n - 1][r] % 10007 + cnt[n - 1][r - 1] % 10007) % 100007;}int main(void) {int n, k;cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; k;cout &amp;lt;&amp;lt; Comb(n, k) % 10007&amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
    <item>
      <title>[백준]1890 점프</title>
      <link>https://jyukki97.github.io/blog/2017-12-02-1890/</link>
      <pubDate>Sat, 02 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-12-02-1890/</guid>
      <description>https://www.acmicpc.net/problem/1890
풀이:  cnt[[x][y] 는 x열 y행 에서의 최대 경로의 개수 시간초과를 막기위해 if (cnt[x][y] &amp;gt;= 0) 를 넣어 중복을 피함  코드: #include &amp;lt;iostream&amp;gt;using namespace std;int n, a[101][101];long long cnt[101][101];long long jump(int x, int y) {if (x == n - 1 &amp;amp;&amp;amp; y == n - 1)return 1;if (cnt[x][y] &amp;gt;= 0)return cnt[x][y];cnt[x][y] = 0;if (a[x][y] + x &amp;lt; n)cnt[x][y] += jump(a[x][y] + x, y);if (a[x][y] + y &amp;lt; n)cnt[x][y] += jump(x, a[x][y] + y);return cnt[x][y];}int main(void) {cin &amp;gt;&amp;gt; n;for (int i = 0; i &amp;lt; n; i++) {for (int t = 0; t &amp;lt; n; t++) {cin &amp;gt;&amp;gt; a[i][t];}}fill(cnt[0], cnt[100], -1);cout &amp;lt;&amp;lt; jump(0, 0) &amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
    <item>
      <title>[백준]2096 내려가기</title>
      <link>https://jyukki97.github.io/blog/2017-12-02-2096/</link>
      <pubDate>Sat, 02 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-12-02-2096/</guid>
      <description>https://www.acmicpc.net/problem/2096
풀이:  b[i][0] 은 i번째 수를 골랐을 때의 최댓값 b[i][0] 은 i번째 수를 골랐을 때의 최솟값  참고: 1149 RGB거리 코드: #include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;int a[3],c[3];int main(void) {int n,temp;cin &amp;gt;&amp;gt; n;int b[2][3] = { 0 };for (int i = 0; i &amp;lt; n; i++) {cin &amp;gt;&amp;gt; a[0] &amp;gt;&amp;gt; a[1] &amp;gt;&amp;gt; a[2];c[0] = b[0][0];c[1] = b[0][1];c[2] = b[0][2];temp = max(c[1], c[0]);b[0][0] = a[0] + temp;b[0][1] = a[1] + max(temp, c[2]);b[0][2] = a[2] + max(c[1], c[2]);c[0] = b[1][0];c[1] = b[1][1];c[2] = b[1][2];temp = min(c[1], c[0]);b[1][0] = a[0] + temp;b[1][1] = a[1] + min(temp, c[2]);b[1][2] = a[2] + min(c[1], c[2]);}temp = max(b[0][1], b[0][0]);cout &amp;lt;&amp;lt; max(temp, b[0][2]) &amp;lt;&amp;lt; &amp;#34;&amp;#34;;temp = min(b[1][1], b[1][0]);cout &amp;lt;&amp;lt; min(temp, b[1][2]) &amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
    <item>
      <title>[백준]1309 동물원</title>
      <link>https://jyukki97.github.io/blog/2017-12-01-1309/</link>
      <pubDate>Fri, 01 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-12-01-1309/</guid>
      <description>https://www.acmicpc.net/problem/1309
풀이:  a[i] 가 2 x i 칸에 채울 수 있는 배치의 최댓값이라 하자. a[i] = 2 * a[i - 1] + a[i - 2] 로 구할 수 있다.  코드: #include &amp;lt;iostream&amp;gt;using namespace std;int main(void) {int n;cin &amp;gt;&amp;gt; n;int a[100001] = { 3,7,0 };for (int i = 2; i &amp;lt; n; i++) {a[i] = (2* a[i - 1] + a[i - 2]) % 9901;}cout &amp;lt;&amp;lt; a[n - 1] % 9901 &amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
    <item>
      <title>[백준]1520 내리막 길</title>
      <link>https://jyukki97.github.io/blog/2017-12-01-1520/</link>
      <pubDate>Fri, 01 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-12-01-1520/</guid>
      <description>https://www.acmicpc.net/problem/1520
풀이:  cnt[i][t] 가 i행 t열을 골랐을 때 최대 경로의 수 이다. 왼쪽 위 부터 차례대로 방문한다. 왼쪽, 오른쪽, 위, 아래 를 모두 검사하여 지금 계단의 지점보다 낮은 지점을 찾는다. 계속 검사하면서 가다가 오른쪽 끝 즉, (n,m) 을 만나면 return 1을 해준다. 시간초과 때문에 재방문을 피하기위해 cnt의 값을 모두 -1로 바꿔놓고 0이상이면 검사를 끝내도록 하였다.  코드: #include &amp;lt;iostream&amp;gt;using namespace std;int n, m;int a[501][501];int cnt[501][501];int downhill(int q, int w) {if (q == n &amp;amp;&amp;amp; w == m)return 1;if (cnt[q][w] &amp;gt;= 0)return cnt[q][w];cnt[q][w] = 0;int x[5] = { 0, 1, 0, -1, 0 };int y[5] = { 0, 0, 1, 0, -1 };for (int i = 0; i &amp;lt; 5; i++) {if (q + x[i] &amp;gt; 0 &amp;amp;&amp;amp; q + x[i] &amp;lt;= n &amp;amp;&amp;amp; w + y[i] &amp;gt; 0 &amp;amp;&amp;amp; w + y[i] &amp;lt;= m &amp;amp;&amp;amp; a[q + x[i]][w + y[i]] &amp;lt; a[q][w]) {cnt[q][w] += downhill(q + x[i], w + y[i]);}}return cnt[q][w];}int main(void) {cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;for (int i = 1; i &amp;lt;= n; i++) {for (int t = 1; t &amp;lt;= m; t++) {cin &amp;gt;&amp;gt; a[i][t];}}fill(cnt[0],cnt[500], -1);cout &amp;lt;&amp;lt; downhill(1,1) &amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
    <item>
      <title>[백준]1965 상자넣기</title>
      <link>https://jyukki97.github.io/blog/2017-12-01-1965/</link>
      <pubDate>Fri, 01 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-12-01-1965/</guid>
      <description>https://www.acmicpc.net/problem/1965
풀이:  b[i] 가 i 번째 상자를 골랐을 때의 상자의 최대 갯수라고 하자. b[i] = b[i] + 0~i 번째 까지 중 가장 큰 값 이다.  코드: #include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;int main(void) {int n,temp;cin &amp;gt;&amp;gt; n;int a[1001] = { 0 };int b[1001];for (int i = 0; i &amp;lt; n; i++) {cin &amp;gt;&amp;gt; a[i];b[i] = 1;}for (int i = 0; i &amp;lt; n; i++) {temp = 0;for (int t = 0; t &amp;lt;= i; t++) {if (a[i] &amp;gt; a[i - t])temp = max(b[i - t], temp);}b[i] += temp;}for (int i = 0; i &amp;lt; n; i++) {temp = max(b[i], temp);}cout &amp;lt;&amp;lt; temp &amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
    <item>
      <title>[백준]2133 타일 채우기</title>
      <link>https://jyukki97.github.io/blog/2017-12-01-2133/</link>
      <pubDate>Fri, 01 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-12-01-2133/</guid>
      <description>https://www.acmicpc.net/problem/2133
풀이:  N이 홀수라면 타일을 채울 수 없으므로 언제나 0을 출력한다. 짝수일경우 i를 N/2-1 로 생각하고 a[i] = 4 * a[i - 1] - a[i - 2] 로 구한다.  코드: #include &amp;lt;iostream&amp;gt;#include &amp;lt;math.h&amp;gt;using namespace std;int main(void) {int n;long long a[30] = { 3,11,0 };cin &amp;gt;&amp;gt; n;if (n % 2 == 1)cout &amp;lt;&amp;lt; &amp;#34;0&amp;#34; &amp;lt;&amp;lt; endl;else {for (int t = 2; t &amp;lt; n/2; t++) {a[t] = 4*a[t-1] - a[t-2];}cout &amp;lt;&amp;lt; a[n/2-1] &amp;lt;&amp;lt; endl;}return 0;}</description>
    </item>
    
    <item>
      <title>[백준]6359 만취한 상범</title>
      <link>https://jyukki97.github.io/blog/2017-12-01-6359/</link>
      <pubDate>Fri, 01 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-12-01-6359/</guid>
      <description>https://www.acmicpc.net/problem/6359
풀이:  n 개의 방이 있을 때 탈출할 수 있는 사람의 수는 sqrt(n)명이다.  코드: #include &amp;lt;iostream&amp;gt;#include &amp;lt;math.h&amp;gt;using namespace std;int main(void) {int n,T;cin &amp;gt;&amp;gt; T;for (int i = 0; i &amp;lt; T; i++) {cin &amp;gt;&amp;gt; n;cout &amp;lt;&amp;lt; (int)sqrt(n) &amp;lt;&amp;lt; endl;}return 0;}</description>
    </item>
    
    <item>
      <title>[백준]10844 쉬운 계단 수</title>
      <link>https://jyukki97.github.io/blog/2017-11-30-10844/</link>
      <pubDate>Thu, 30 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-11-30-10844/</guid>
      <description>https://www.acmicpc.net/problem/10844
풀이:  a[i][t] 는 길이가 i인 숫자에서 1의 자릿 수가 t일 때의 경우의 수 t가 0 이면 a[i][t] = a[i - 1][t + 1] t가 9 이면 a[i][t] = a[i - 1][t - 1] 둘다 아니면 a[i][t] = (a[i - 1][t - 1] + a[i - 1][t + 1]) 이 때 오버플로우가 발생하므로 각각의 계산에 1000000000을 나눠준다.  코드: #include &amp;lt;iostream&amp;gt;using namespace std;long long a[101][10] = { 0 };int main(void) {int n;cin &amp;gt;&amp;gt; n;long long cnt = 0;for (int i = 1; i &amp;lt; 10; i++) {a[0][i] = 1;}for (int i = 1; i &amp;lt; n; i++) {for (int t = 0; t &amp;lt; 10; t++) {if (t == 0)a[i][t] = a[i - 1][t + 1] % 1000000000;else if (t == 9)a[i][t] = a[i - 1][t - 1] % 1000000000;elsea[i][t] = (a[i - 1][t - 1] + a[i - 1][t + 1]) % 1000000000;}}for (int i = 0; i &amp;lt; 10; i++) {cnt += a[n - 1][i] % 1000000000;}cout &amp;lt;&amp;lt; cnt % 1000000000 &amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
    <item>
      <title>[백준]11057 오르막수</title>
      <link>https://jyukki97.github.io/blog/2017-11-30-11057/</link>
      <pubDate>Thu, 30 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-11-30-11057/</guid>
      <description>https://www.acmicpc.net/problem/11057
풀이:  a[i][t] 는 길이가 i인 수에서 1의 자리가 t인 수의 오르막 수의 개수 a[i][t] += max(a[i - 1][t], a[i][t - 1]);  코드: #include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;int a[1002][1002] = { 0 };int main(void) {int n, m;cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;for (int i = 1; i &amp;lt;= n; i++) {for (int t = 1; t &amp;lt;= m; t++) {cin &amp;gt;&amp;gt; a[i][t];}}for (int i = 1; i &amp;lt;= n; i++) {for (int t = 1; t &amp;lt;= m; t++) {a[i][t] += max(a[i - 1][t], a[i][t - 1]);}}cout &amp;lt;&amp;lt; a[n][m] &amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
    <item>
      <title>[백준]11727 2xN 타일링2</title>
      <link>https://jyukki97.github.io/blog/2017-11-30-11727/</link>
      <pubDate>Thu, 30 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-11-30-11727/</guid>
      <description>https://www.acmicpc.net/problem/11727
풀이:  a[i] 는 타일이 2xi 일때의 경우의 수 a[i] = (2 * a[i - 2] + a[i - 1] 주어진 조건에서 10007으로 나눈 나머지를 출력하라고 하였으므로 나눠줌.  코드: #include &amp;lt;iostream&amp;gt;using namespace std;int a[1001] = { 1,3,0 };int main(void) {int n;cin &amp;gt;&amp;gt; n;for (int i = 2; i &amp;lt; n; i++) {a[i] = (2 * a[i - 2] + a[i - 1])%10007;}cout &amp;lt;&amp;lt; a[n - 1] &amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
    <item>
      <title>[백준]1699 제곱수의 합</title>
      <link>https://jyukki97.github.io/blog/2017-11-30-1699/</link>
      <pubDate>Thu, 30 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-11-30-1699/</guid>
      <description>https://www.acmicpc.net/problem/1699
풀이:  q[i] 는 i 일 때 제곱수로 나타낼 수 있는 최소의 경우의 수 n 이 i + t^2 으로 나타내 질 때, 최소의 경우의 수를 찾음  코드: #include &amp;lt;iostream&amp;gt;#include &amp;lt;math.h&amp;gt;int q[100002] = { 0 };using namespace std;int main(void) {int n,a;cin &amp;gt;&amp;gt; n;a = sqrt(n);for (int i = 1; i &amp;lt;= n; i++){q[i] = 10001;for (int t = 1; t &amp;lt;= a; t++){if (i == t*t)q[i] = 1;}}for (int i = 1; i &amp;lt;= n; i++){for (int t = 1; t &amp;lt;= a; t++){if (i + (t*t) &amp;lt;= n &amp;amp;&amp;amp; q[i + (t*t)] &amp;gt; q[i] + 1)q[i + (t*t)] = q[i] + 1;}}cout &amp;lt;&amp;lt; q[n] &amp;lt;&amp;lt; endl;}</description>
    </item>
    
    <item>
      <title>[백준]1912 연속합</title>
      <link>https://jyukki97.github.io/blog/2017-11-30-1912/</link>
      <pubDate>Thu, 30 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-11-30-1912/</guid>
      <description>https://www.acmicpc.net/problem/1912
풀이:  a[i] 는 i번째를 골랐을 때, 최대값 만약 a[i-1] 이 0 보다 크다면, a[i] += a[i-1]  코드: #include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;int a[100001] = { 0 };int main(void) {int n;cin &amp;gt;&amp;gt; n;for (int i = 0; i &amp;lt; n; i++) {cin &amp;gt;&amp;gt; a[i];}int temp = a[0];for (int i = 1; i &amp;lt; n; i++) {if(a[i-1] &amp;gt; 0)a[i] += a[i - 1];temp = max(temp, a[i]);}cout &amp;lt;&amp;lt; temp &amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
    <item>
      <title>[백준]2163 초콜릿 자르기</title>
      <link>https://jyukki97.github.io/blog/2017-11-30-2163/</link>
      <pubDate>Thu, 30 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-11-30-2163/</guid>
      <description>https://www.acmicpc.net/problem/2163
풀이:  N x M 크기의 초콜릿을 자르는 최소의 경우의 수 N * M - 1  코드: #include &amp;lt;iostream&amp;gt;using namespace std;int main(void) {int n, m;cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;cout &amp;lt;&amp;lt; n*m - 1 &amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
    <item>
      <title>[백준]9461 파도반 수열</title>
      <link>https://jyukki97.github.io/blog/2017-11-30-9461/</link>
      <pubDate>Thu, 30 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-11-30-9461/</guid>
      <description>https://www.acmicpc.net/problem/9461
풀이:  a[i] 는 i 번째 수열 a[i] = a[i-1] + a[i-5]  코드: #include &amp;lt;iostream&amp;gt;using namespace std;long long a[101] = { 1,1,1,2,2,0 };int main(void) {int T,n;cin &amp;gt;&amp;gt; T;for (int i = 0; i &amp;lt; T; i++) {cin &amp;gt;&amp;gt; n;for (int t = 5; t &amp;lt; n; t++) {a[t] = a[t - 1] + a[t - 5];}cout &amp;lt;&amp;lt; a[n - 1] &amp;lt;&amp;lt; endl;}return 0;}</description>
    </item>
    
    <item>
      <title>[백준]2156 포도주 시식</title>
      <link>https://jyukki97.github.io/blog/2017-11-29-2156/</link>
      <pubDate>Wed, 29 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-11-29-2156/</guid>
      <description>https://www.acmicpc.net/problem/2156
풀이:  b[i][0] 은 i번째를 골랐을 때, i-1번째를 안고른 경우의 수 b[i][1] 은 i번째를 골랐을 때, i-1번째를 고른 경우의 수 b[i][2] 은 i번째를 골랐을 때, i-2번째를 안고른 경우의 수  코드: #include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;int main(void) {int n;cin &amp;gt;&amp;gt; n;int a[10001];for (int i = 0; i &amp;lt; n; i++) {cin &amp;gt;&amp;gt; a[i];}int b[10001][3] = { a[0],a[0],a[0],a[1],a[0] + a[1],a[1],0 };int temp;for (int i = 2; i &amp;lt; n; i++) {for (int t = 0; t &amp;lt; 3; t++) {if (t == 0) {temp = max(b[i - 2][0], b[i - 2][1]);b[i][t] = max(temp, b[i - 2][2]) + a[i];}if (t == 1)b[i][t] = max(b[i - 1][0], b[i - 1][2]) + a[i];if (t == 2)b[i][t] = b[i - 3][1] + a[i];}}temp = max(b[n - 1][0], b[n - 2][1]);temp = max(temp, b[n - 1][1]);cout &amp;lt;&amp;lt; max(temp, b[n - 1][2]) &amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
    <item>
      <title>[백준]11726 2×n 타일링</title>
      <link>https://jyukki97.github.io/blog/2017-11-28-11726/</link>
      <pubDate>Tue, 28 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-11-28-11726/</guid>
      <description>https://www.acmicpc.net/problem/11726
풀이:  정수 i를 1,2 의 조합으로 나타낼 수 있는 경우의 수 a[i-1] a[i] = a[i-1] + a[i-2] 으로 구할 수 있다.  코드: #include &amp;lt;iostream&amp;gt;using namespace std;int main(void) {int n;int a[1001] = { 1,2,0 };cin &amp;gt;&amp;gt; n;for (int t = 2; t &amp;lt; n; t++) {a[t] = (a[t - 1] + a[t - 2]) % 10007;}cout &amp;lt;&amp;lt; a[n - 1]&amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
    <item>
      <title>[백준]1463 1로 만들기</title>
      <link>https://jyukki97.github.io/blog/2017-11-28-1463/</link>
      <pubDate>Tue, 28 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-11-28-1463/</guid>
      <description>https://www.acmicpc.net/problem/1463
풀이:  i 일때 연산 횟수를 a[i] 라고 둔다. 2와 3으로 동시에 나눠질때, 따로 나눠질때, 나눠지지 않을때로 나눠서 계산한다. n번까지 연산 후 a[n]을 출력한다.  코드: #include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;int a[1000002] = { 0 };int main(void) {int n;cin &amp;gt;&amp;gt; n;for (int i = 2; i &amp;lt;= n; i++) {if (i % 2 == 0 &amp;amp;&amp;amp; i % 3 == 0) {int temp = min(a[i / 2], a[i / 3]);a[i] = min(temp, a[i - 1]) + 1;}else if(i % 2 == 0 &amp;amp;&amp;amp; i % 3 !</description>
    </item>
    
    <item>
      <title>[백준]9095 1, 2, 3 더하기</title>
      <link>https://jyukki97.github.io/blog/2017-11-28-9095/</link>
      <pubDate>Tue, 28 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-11-28-9095/</guid>
      <description>https://www.acmicpc.net/problem/9095
풀이:  정수 i를 1,2,3의 조합으로 나타낼 수 있는 경우의 수 a[i-1] a[i] = a[i-1] + a[i-2] + a[i-3] 으로 구할 수 있다.  코드: #include &amp;lt;iostream&amp;gt;using namespace std;int main(void) {int T,n;cin &amp;gt;&amp;gt; T;for (int i = 0; i &amp;lt; T; i++) {int a[11] = { 1,2,4,0 };cin &amp;gt;&amp;gt; n;for (int t = 3; t &amp;lt; n; t++) {a[t] = a[t - 1] + a[t - 2] + a[t - 3];}cout &amp;lt;&amp;lt; a[n - 1] &amp;lt;&amp;lt; endl;}return 0;}</description>
    </item>
    
    <item>
      <title>[백준]1149 RGB거리</title>
      <link>https://jyukki97.github.io/blog/2017-11-27-1149/</link>
      <pubDate>Mon, 27 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-11-27-1149/</guid>
      <description>https://www.acmicpc.net/problem/1149
풀이:  r,g,b를 각각 b[0], b[1], b[2] 로 둠. r을 선택했다면 이전에서 g,b 중 작은값에 이번에 r값을 더하는 식으로 r,g,b 반복 r,g,b 최종값에서 가장 최소값 출력  코드: #include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;int main(void) {int n;cin &amp;gt;&amp;gt; n;int a[3001];int b[3];for (int i = 0; i &amp;lt; n*3; i++) {cin &amp;gt;&amp;gt; a[i];}for (int i = 1; i &amp;lt; n; i++) {b[0] = a[0];b[1] = a[1];b[2] = a[2];a[0] = min(b[1], b[2]) + a[i * 3];a[1] = min(b[0], b[2]) + a[(i * 3) + 1];a[2] = min(b[0], b[1]) + a[(i * 3) + 2];}int temp = min(a[0], a[1]);cout &amp;lt;&amp;lt; min(temp, a[2]) &amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
    <item>
      <title>[백준]11052 붕어빵 판매하기</title>
      <link>https://jyukki97.github.io/blog/2017-11-26-11052/</link>
      <pubDate>Sun, 26 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-11-26-11052/</guid>
      <description>https://www.acmicpc.net/problem/11052
풀이:  붕어의 개수가 i개 일 때를 b[i] 라고 놓고 b[i] = (t개 일때 가격 + 남은 붕어 빵의 가격) 과 b[i] 개중 큰값을 넣음. 구하고자 하는 n개 즉 b[n]을 찾음.  코드: #include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;int main(void) {int n, m, w;int a[1002];int b[1002] = { 0 };cin &amp;gt;&amp;gt; n;for (int i = 1; i &amp;lt;= n; i++) {cin &amp;gt;&amp;gt; a[i];}for (int i = 1; i &amp;lt;= n; i++) {for (int t = 0; t &amp;lt; i; t++) {b[i] = max(b[i], b[t] + a[i - t]);}}cout &amp;lt;&amp;lt; b[n] &amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
    <item>
      <title>[백준]1004 어린왕자</title>
      <link>https://jyukki97.github.io/blog/2017-11-25-1004/</link>
      <pubDate>Sat, 25 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-11-25-1004/</guid>
      <description>https://www.acmicpc.net/problem/1004
풀이:  시작점과 도착점이 같이 원안에 있지않을 때, 시작점, 도착점이 원 안에 있다면 카운트를 ++  코드: #include &amp;lt;iostream&amp;gt;#include &amp;lt;math.h&amp;gt;using namespace std;int main(void) {int T;cin &amp;gt;&amp;gt; T;for (int i = 0; i &amp;lt; T; i++) {int n, x1, x2, y1, y2;int x[50];int y[50];int r[50];int count = 0;cin &amp;gt;&amp;gt; x1 &amp;gt;&amp;gt; y1 &amp;gt;&amp;gt; x2 &amp;gt;&amp;gt; y2 &amp;gt;&amp;gt; n;for (int t = 0; t &amp;lt; n; t++) {cin &amp;gt;&amp;gt; x[t] &amp;gt;&amp;gt; y[t] &amp;gt;&amp;gt; r[t];}for (int t = 0; t &amp;lt; n; t++) {if (sqrt((x1 - x[t])*(x1 - x[t]) + (y1 - y[t])*(y1 - y[t])) &amp;lt; r[t]) {if (sqrt((x2 - x[t])*(x2 - x[t]) + (y2 - y[t])*(y2 - y[t])) &amp;gt;= r[t])count++;}if (sqrt((x2 - x[t])*(x2 - x[t]) + (y2 - y[t])*(y2 - y[t])) &amp;lt; r[t]) {if (sqrt((x1 - x[t])*(x1 - x[t]) + (y1 - y[t])*(y1 - y[t])) &amp;gt;= r[t])count++;}}cout &amp;lt;&amp;lt; count &amp;lt;&amp;lt; endl;}return 0;}</description>
    </item>
    
    <item>
      <title>[백준]1010 다리놓기</title>
      <link>https://jyukki97.github.io/blog/2017-11-25-1010/</link>
      <pubDate>Sat, 25 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-11-25-1010/</guid>
      <description>https://www.acmicpc.net/problem/1010
풀이:  서쪽 다리(N)에서 동쪽 다리(M)로 연결 이므로 조합인 mCn 을 사용  코드: #include &amp;lt;iostream&amp;gt;using namespace std;int Comb(int n, int r) {if (r == 0 || r == n)return 1;else if (r == n - 1 || r == 1)return n;return Comb(n - 1, r) + Comb(n - 1, r - 1);}int main(void) {int T,n,m;cin &amp;gt;&amp;gt; T;for (int i = 0; i &amp;lt; T; i++) {cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;cout &amp;lt;&amp;lt; Comb(m, n) &amp;lt;&amp;lt; endl;}return 0;}</description>
    </item>
    
    <item>
      <title>[백준]1718 암호</title>
      <link>https://jyukki97.github.io/blog/2017-11-25-1718/</link>
      <pubDate>Sat, 25 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-11-25-1718/</guid>
      <description>https://www.acmicpc.net/problem/1718
풀이:  평문에서 암호문을 뺀다. 만약 뺀 값이 0 이하일경우 z로 돌아간다.  코드: #include &amp;lt;iostream&amp;gt;#include &amp;lt;string&amp;gt;using namespace std;int main(void) {string a;getline(cin, a);string key;cin &amp;gt;&amp;gt; key;char cy[30001] = { NULL };for (int i = 0; i &amp;lt; a.length(); i++) {if (a[i] == &amp;#39;&amp;#39;)cy[i] = &amp;#39;&amp;#39;;else if ((int)a[i] - (int)key[i%key.length()] &amp;lt;= 0)cy[i] = (char)((int)a[i] - (int)key[i%key.length()] + 122);elsecy[i] = (char)((int)a[i] - (int)key[i%key.</description>
    </item>
    
    <item>
      <title>[백준]2578 빙고</title>
      <link>https://jyukki97.github.io/blog/2017-11-25-2578/</link>
      <pubDate>Sat, 25 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-11-25-2578/</guid>
      <description>https://www.acmicpc.net/problem/2578
풀이:  빙고를 저장 사회자가 말하는 번호에 빙고판에 1 저장 빙고판 가로 세로 대각선 2개 판별 빙고가 3개 넘어가면 끝  코드: #include &amp;lt;iostream&amp;gt;#include &amp;lt;map&amp;gt;using namespace std;int main(void) {map&amp;lt;int, int&amp;gt; a;int b[25] = { 0 };int c[25];int num;int count = 0;for (int i = 0; i &amp;lt; 25; i++) {cin &amp;gt;&amp;gt; num;a[num] = i;}for (int i = 0; i &amp;lt; 25; i++) {cin &amp;gt;&amp;gt; num;b[a[num]] = 1;if (b[(a[num] / 5) * 5] == 1 &amp;amp;&amp;amp; b[((a[num] / 5) * 5) + 1] == 1 &amp;amp;&amp;amp; b[((a[num] / 5) * 5) + 2] == 1 &amp;amp;&amp;amp; b[((a[num] / 5) * 5) + 3] == 1 &amp;amp;&amp;amp; b[((a[num] / 5) * 5) + 4] == 1)count++;if (b[a[num] % 5] == 1 &amp;amp;&amp;amp; b[a[num] % 5 + 5] == 1 &amp;amp;&amp;amp; b[a[num] % 5 + 10] == 1 &amp;amp;&amp;amp; b[a[num] % 5 + 15] == 1 &amp;amp;&amp;amp; b[a[num] % 5 + 20] == 1)count++;if ((a[num] % 4 == 0 &amp;amp;&amp;amp; a[num] !</description>
    </item>
    
    <item>
      <title>[백준]1932 숫자삼각형</title>
      <link>https://jyukki97.github.io/blog/2017-11-24-1932/</link>
      <pubDate>Fri, 24 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-11-24-1932/</guid>
      <description>https://www.acmicpc.net/problem/1932
풀이:  첫 줄부터 밑에줄까지 내려가면서 값을 더해감 더한 값중 제일 큰 값을 찾음  코드: #include &amp;lt;iostream&amp;gt;using namespace std;int q[501][501];int good[501][501];int main(void){int num;int big = 0;cin &amp;gt;&amp;gt; num;for (int i = 0; i &amp;lt; num; i++){for (int t = 0; t &amp;lt; i + 1; t++){cin &amp;gt;&amp;gt; q[i][t];}}good[0][0] = q[0][0];for (int i = 1; i &amp;lt; num; i++){for (int t = 0; t &amp;lt; i+1; t++){if(t==0)good[i][t] = good[i - 1][t] + q[i][t];else if (i == t)good[i][t] = good[i - 1][t - 1] + q[i][t];else{if (good[i - 1][t - 1] &amp;gt; good[i - 1][t])good[i][t] = good[i - 1][t - 1] + q[i][t];elsegood[i][t] = good[i - 1][t] + q[i][t];}}}for (int i = 0; i &amp;lt; num; i++){if (good[num - 1][i] &amp;gt; big)big = good[num - 1][i];}cout &amp;lt;&amp;lt; big &amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
    <item>
      <title>[백준]2293 동전1</title>
      <link>https://jyukki97.github.io/blog/2017-11-23-2293/</link>
      <pubDate>Thu, 23 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-11-23-2293/</guid>
      <description>https://www.acmicpc.net/problem/2293
풀이:  첫번째 동전부터 경우의 수를 더해감.  코드: #include &amp;lt;iostream&amp;gt;using namespace std;int coin[10001] = { 0 };int main(void){int a;int num;cin &amp;gt;&amp;gt; a;cin &amp;gt;&amp;gt; num;int *q = new int[a];for (int i = 0; i &amp;lt; a; i++){cin &amp;gt;&amp;gt; q[i];}for (int i = 0; i &amp;lt;= num; i++){if (i%q[0] == 0)coin[i]++;}for (int i = 1; i &amp;lt; a; i++){for (int t = q[i]; t &amp;lt;= num; t++){coin[t] += coin[t - q[i]];}}cout &amp;lt;&amp;lt; coin[num] &amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
    <item>
      <title>[백준]3613 Java vs C&#43;&#43;</title>
      <link>https://jyukki97.github.io/blog/2017-11-22-3613/</link>
      <pubDate>Wed, 22 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-11-22-3613/</guid>
      <description>https://www.acmicpc.net/problem/3613
풀이:  java 변수면 c++로 c++ 이면 java로 변경 예외처리  코드: #include &amp;lt;iostream&amp;gt;#include &amp;lt;string.h&amp;gt;using namespace std;int main(void) {char a[201];char b[201] = {&amp;#39;\n&amp;#39;};bool java = false;bool cplus = false;bool ero = true;cin &amp;gt;&amp;gt; a;int t = 0;for (int i = 0; i &amp;lt; strlen(a); i++) {if (65 &amp;lt;= (int)a[i] &amp;amp;&amp;amp; (int)a[i] &amp;lt;= 90) {if (i == 0 || cplus == true) {ero = false;break;}b[t] = &amp;#39;_&amp;#39;;t++;b[t] = a[i] + 32;java = true;}else if (a[i] == &amp;#39;_&amp;#39;) {if (i == 0 || i == strlen(a)-1 || a[i + 1] == &amp;#39;_&amp;#39; || java == true || (65 &amp;lt;= (int)a[i + 1] &amp;amp;&amp;amp; (int)a[i + 1] &amp;lt;= 90)) {ero = false;break;}b[t] = a[i + 1] - 32;i++;cplus = true;}else b[t] = a[i];t++;}if (ero == false)cout &amp;lt;&amp;lt; &amp;#34;Error!</description>
    </item>
    
    <item>
      <title>[sw]사다리</title>
      <link>https://jyukki97.github.io/blog/2017-11-21-sw-1210/</link>
      <pubDate>Tue, 21 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-11-21-sw-1210/</guid>
      <description>https://www.swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AV14ABYKADACFAYh&amp;amp;
풀이:  int[100][100] 배열에 사다리를 저장 사다리 끝에 있는 도착점을 찾음 사다리 위로 올라가며 옆에 길이 있나 확인 맨 위에 x값을 출력  코드: #include &amp;lt;iostream&amp;gt;#include &amp;lt;string&amp;gt;using namespace std;int lineup(int n[100][100], int yc, int xc, bool left, bool right) {if (yc == 0)return xc;if (xc &amp;gt; 0 &amp;amp;&amp;amp; right == false &amp;amp;&amp;amp; n[yc][xc - 1] == 1)return lineup(n, yc, xc - 1,true,false);else if (xc &amp;lt; 99 &amp;amp;&amp;amp; left==false &amp;amp;&amp;amp; n[yc][xc + 1] == 1)return lineup(n, yc, xc + 1,false,true);elsereturn lineup(n, yc - 1, xc,false,false);}int main(void) {for (int t = 1; t &amp;lt; 11; t++) {int a;cin &amp;gt;&amp;gt; a;int line[100][100];int count;for (int i = 0; i &amp;lt; 100; i++) {for (int y = 0; y &amp;lt; 100; y++) {cin &amp;gt;&amp;gt; line[i][y];}}for (int i = 0; i &amp;lt; 100; i++) {if (line[99][i] == 2) {count = i;break;}}cout &amp;lt;&amp;lt; &amp;#34;#&amp;#34; &amp;lt;&amp;lt; t &amp;lt;&amp;lt; &amp;#34;&amp;#34; &amp;lt;&amp;lt; lineup(line, 98, count, false, false) &amp;lt;&amp;lt; endl;}return 0;}}</description>
    </item>
    
    <item>
      <title>[백준]1065 한수</title>
      <link>https://jyukki97.github.io/blog/2017-11-20-1065/</link>
      <pubDate>Mon, 20 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-11-20-1065/</guid>
      <description>https://www.acmicpc.net/problem/1065
풀이: 한수이면 카운트를 ++ 하는 함수를 만듦
코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;using namespace std;int hannum(int n, int c) {int b = (n % 1000) / 100;int d = ((n % 1000) % 100) / 10;int f = ((n % 1000) % 100) % 10;if (n &amp;gt; 99) {if ((b - d == d - f) &amp;amp;&amp;amp; n != 1000)c++;}elsec++;if (n == 1)return c;elsereturn hannum(n - 1, c);}int main(void) {int a;cin &amp;gt;&amp;gt; a;cout &amp;lt;&amp;lt; hannum(a, 0);return 0;}</description>
    </item>
    
    <item>
      <title>[백준]1475 방번호</title>
      <link>https://jyukki97.github.io/blog/2017-11-20-1475/</link>
      <pubDate>Mon, 20 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-11-20-1475/</guid>
      <description>https://www.acmicpc.net/problem/1475
풀이:  방번호를 string에 저장 string 첫번째 자릿수부터 숫자를 확인 숫자에 맞는 배열에 ++ 배열에서 가장 큰 숫자를 가지고 있는 값을 출력  코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;string&amp;gt;using namespace std;int main(void) {string a;int b[10] = { 0 };cin &amp;gt;&amp;gt; a;for (int i = 0; i &amp;lt; a.length(); i++) {if (((int)a[i] - 48) == 6 &amp;amp;&amp;amp; b[6] &amp;gt; b[9])b[9] ++;else if (((int)a[i] - 48) == 9 &amp;amp;&amp;amp; b[6] &amp;lt; b[9])b[6] ++;elseb[(int)a[i] - 48]++;}int count = 0;for (int i = 0; i &amp;lt; 10; i++) {if (b[i] &amp;gt; count)count = b[i];}cout &amp;lt;&amp;lt; count &amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
    <item>
      <title>start</title>
      <link>https://jyukki97.github.io/blog/2017-11-19-start/</link>
      <pubDate>Sun, 19 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-11-19-start/</guid>
      <description>안녕하세요.</description>
    </item>
    
  </channel>
</rss>