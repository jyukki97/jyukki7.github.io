<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>정렬 on 1 Day 1 Problem</title>
    <link>https://jyukki97.github.io/tags/%EC%A0%95%EB%A0%AC/</link>
    <description>Recent content in 정렬 on 1 Day 1 Problem</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>kr-ko</language>
    <lastBuildDate>Sat, 14 Dec 2019 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://jyukki97.github.io/tags/%EC%A0%95%EB%A0%AC/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>[프로그래머스]k번째 수</title>
      <link>https://jyukki97.github.io/blog/2019-12-14-knum/</link>
      <pubDate>Sat, 14 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-12-14-knum/</guid>
      <description>https://programmers.co.kr
풀이:  array 배열의 commands[0]번째부터 commands[1]번째 까지 자른 후 정렬한다. 자른 배열의 commands[2] 번째 숫자를 출력한다. commands 배열의 길이만큼 반복한다.  코드: 사용언어 : c++
#include &amp;lt;string&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;vector&amp;lt;int&amp;gt; solution(vector&amp;lt;int&amp;gt; array, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; commands) {vector&amp;lt;int&amp;gt; answer;for(int i=0;i&amp;lt;commands.size();i++){vector&amp;lt;int&amp;gt; a = array;sort(a.begin()+commands[i][0]-1,a.begin()+commands[i][1]);answer.push_back(a[commands[i][0] + commands[i][2] - 2]); }return answer;}</description>
    </item>
    
    <item>
      <title>[백준]1937 욕심쟁이 판다</title>
      <link>https://jyukki97.github.io/blog/2019-05-28-1937/</link>
      <pubDate>Tue, 28 May 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-05-28-1937/</guid>
      <description>https://www.acmicpc.net/problem/1937
풀이:  k[a][b]를 (a , b)지점에서 시작한 판다가 살아남은 최대 일수라고 한다. (a, b) 주변 십자가 방향 지점( (1,0), (-1, 0), (0, 1), (0, -1)) 에서 대나무의 양이 (a, b) 보다 낮다면 그 지점에 최대 일수에서 +1 한 값이 k[a][b] 값이 된다. 높은 값에서 낮은값으로 찾아가면서 최대 일수를 구한다. 시간초과가 날 수 있으므로 메모이제이션을 통해 시행횟수를 제한해준다.  코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;int n, s[510][510], k[510][510];int dx[] = { 1,0,0,-1 };int dy[] = { 0,1,-1,0 };int panda(int a, int b){for (int y = 0; y &amp;lt; 4; y++)if (a + dy[y] &amp;gt;= 0 &amp;amp;&amp;amp; a + dy[y] &amp;lt; n &amp;amp;&amp;amp; b + dx[y] &amp;gt;= 0 &amp;amp;&amp;amp; b + dx[y] &amp;lt; n)if (s[a][b] &amp;lt; s[a + dy[y]][b + dx[y]]) {if(k[a + dy[y]][b + dx[y]] == 1)k[a][b] = max(k[a][b], panda(a + dy[y], b + dx[y]) + 1);elsek[a][b] = max(k[a][b], k[a + dy[y]][b + dx[y]] + 1);}return k[a][b];}int main(void) {cin &amp;gt;&amp;gt; n;int m = 1;fill(&amp;amp;k[0][0], &amp;amp;k[n][n], 1);for (int i = 0; i &amp;lt; n; i++)for (int t = 0; t &amp;lt; n; t++)cin &amp;gt;&amp;gt; s[i][t];for (int i = 0; i &amp;lt; n; i++)for (int t = 0; t &amp;lt; n; t++)m = max(m, panda(i, t));cout &amp;lt;&amp;lt; m &amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
  </channel>
</rss>