<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>브루트 포스 on 1 Day 1 Problem</title>
    <link>https://jyukki97.github.io/tags/%EB%B8%8C%EB%A3%A8%ED%8A%B8-%ED%8F%AC%EC%8A%A4/</link>
    <description>Recent content in 브루트 포스 on 1 Day 1 Problem</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>kr-ko</language>
    <lastBuildDate>Sat, 07 Mar 2020 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://jyukki97.github.io/tags/%EB%B8%8C%EB%A3%A8%ED%8A%B8-%ED%8F%AC%EC%8A%A4/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>[백준]1120 문자열</title>
      <link>https://jyukki97.github.io/blog/2020-03-07-1120/</link>
      <pubDate>Sat, 07 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-03-07-1120/</guid>
      <description>https://www.acmicpc.net/problem/1120
풀이: a 와 b의 (0번째 ~ a의 길이) 의 차이의 개수
a 와 b의 (1번째 ~ a의 길이) 의 차이의 개수
.
.
.
a 와 b의 ()(b의 길이 - a의 길이)번째 ~ a의 길이) 의 차이의 개수
중 가장 작은것을 출력한다.
코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;using namespace std;int main() {int c = 51;string a, b;cin &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b;for (int i = 0; i &amp;lt;= b.</description>
    </item>
    
    <item>
      <title>[백준]1051 숫자 정사각형</title>
      <link>https://jyukki97.github.io/blog/2020-03-06-1051/</link>
      <pubDate>Fri, 06 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-03-06-1051/</guid>
      <description>https://www.acmicpc.net/problem/1051
풀이: N, M 중 더 작은 값이 정사각형의 한 변의 길이의 최댓값이 된다.
최댓값을 1씩 줄여 가면서, 만들 수 있는 정사각형이 있는지 확인한다.
만들 수 있다면, 반복을 중지하고, 변을 제곱한 넓이를 출력한다.
코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std;int N, M, b, c = 1;int main(void) {cin &amp;gt;&amp;gt; N &amp;gt;&amp;gt; M;vector&amp;lt;string&amp;gt; a(N);for (int i = 0; i &amp;lt; N; i++)cin &amp;gt;&amp;gt; a[i];b = N &amp;gt; M ?</description>
    </item>
    
    <item>
      <title>[백준]1062 가르침</title>
      <link>https://jyukki97.github.io/blog/2020-03-06-1062/</link>
      <pubDate>Fri, 06 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-03-06-1062/</guid>
      <description>https://www.acmicpc.net/problem/1062
풀이: a ~ z 중에 K개의 글자를 배웠을 떄,
N개의 단어 중 몇개의 단어를 읽을 수 있는지 구한 후 그것들 중 최댓값을 출력한다.
a, c, i, n, t 다섯개의 글자는 무조건 들어가므로 넣고 시작하자. 코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;int N, K, b, c = 0, d, f;vector&amp;lt;string&amp;gt; a;void T(int x, int y) {if (y == K) {d = 0;for (int i = 0; i &amp;lt; N; i++) {f = 1;for (char s : a[i])	if (!</description>
    </item>
    
    <item>
      <title>[백준]14888 연산자 끼워넣기</title>
      <link>https://jyukki97.github.io/blog/2020-02-24-14888/</link>
      <pubDate>Mon, 24 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-02-24-14888/</guid>
      <description>https://www.acmicpc.net/problem/14888
풀이: 각 숫자를 순서대로 배열에 넣어놓는다.
+, -, *, / 를 갯수만큼 각 숫자사이의 끼워넣어 식을 만든다.
만들 식의 값들을 배열에 저장해놓는다.
배열에 들어있는 수 중 최댓값, 최솟값을 출력한다.
코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;int n, num[101], op[4];vector&amp;lt;int&amp;gt; sumn;void o(int a, int b) {if (a == n - 1) {sumn.push_back(b);return;}if (op[0] &amp;gt; 0) {op[0]--;o(a + 1, b + num[a + 1]);op[0]++;}if (op[1] &amp;gt; 0) {op[1]--;o(a + 1, b - num[a + 1]);op[1]++;}if (op[2] &amp;gt; 0) {op[2]--;o(a + 1, b * num[a + 1]);op[2]++;}if (op[3] &amp;gt; 0) {op[3]--;o(a + 1, b / num[a + 1]);op[3]++;}}int main() {cin &amp;gt;&amp;gt; n;for (int i = 0; i &amp;lt; n; i++)cin &amp;gt;&amp;gt; num[i];cin &amp;gt;&amp;gt; op[0] &amp;gt;&amp;gt; op[1] &amp;gt;&amp;gt; op[2] &amp;gt;&amp;gt; op[3];o(0, num[0]);sort(sumn.</description>
    </item>
    
    <item>
      <title>[백준]14889 스타트와 링크</title>
      <link>https://jyukki97.github.io/blog/2020-02-24-14889/</link>
      <pubDate>Mon, 24 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-02-24-14889/</guid>
      <description>https://www.acmicpc.net/problem/14889
풀이: n / 2 명의 스타트 팀과 n / 2 팀의 링크팀을 만든다.
스타트팀만 만든다면, 자동적으로 남는 사람들은 링크팀이된다.
구하는 팀에 1은 무조건 들어가도록한다. (1을 포함한 팀을 전부 구한다면, 1을 포함하지 않는 팀은 상대팀에 모두 있기 때문에)
스타트팀의 모든 Sij 값의 합과 링크팀의 모든 Sij 값의 합의 차이를 구한다.
구한 차이들 중 가장 작은 값을 출력한다.
코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;int n, m[21][21], mn = 100000, start, link;bool s[21];void st(int a, int b) {if (a == n / 2) {start = 0;link = 0;for (int i = 0; i &amp;lt; n; i++)if (s[i]) {for (int t = i + 1; t &amp;lt; n; t++)if (s[t])start += m[i][t] + m[t][i];}elsefor (int t = i + 1; t &amp;lt; n; t++)if (!</description>
    </item>
    
    <item>
      <title>[백준]1018 체스판 다시 칠하기</title>
      <link>https://jyukki97.github.io/blog/2020-02-21-1018/</link>
      <pubDate>Fri, 21 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-02-21-1018/</guid>
      <description>https://www.acmicpc.net/problem/1018
풀이: (0, 0) ~ (8, 8) &amp;hellip;.. (n - 8, m - 8) ~ (n, m) 까지의 모든 8 X 8 체스판을 서치한다.
체스판이 WBWBWB&amp;hellip; 순서로 되어있는지 확인 후 안되어 있는 칸이 몇 칸인지 찾는다.
찾아낸 수를 C라고 할 때, 64 - C와 C 중 더 작은 값을 저장한다.
저장된 값들 중 가장 작은 값을 출력한다.
코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;string&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;int main() { int n, m, c, ma = 64;cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;vector&amp;lt;string&amp;gt; a(n);for (int i = 0; i &amp;lt; n; i++)cin &amp;gt;&amp;gt; a[i];for (int i = 0; i &amp;lt; n - 7; i++) {for (int t = 0; t &amp;lt; m - 7; t++) {c = 0;for (int y = 0; y &amp;lt; 8; y++)for (int u = 0; u &amp;lt; 8; u++) {bool b = (y % 2) ^ (u % 2) ^ (a[i + y][t + u] == &amp;#39;B&amp;#39; ?</description>
    </item>
    
  </channel>
</rss>