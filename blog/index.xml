<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Blog on 1 Day 1 Problem</title>
    <link>https://jyukki97.github.io/blog/</link>
    <description>Recent content in Blog on 1 Day 1 Problem</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>kr-ko</language>
    <lastBuildDate>Wed, 18 Mar 2020 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://jyukki97.github.io/blog/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>[백준]2864 5와 6의 차이</title>
      <link>https://jyukki97.github.io/blog/2020-03-18-2864/</link>
      <pubDate>Wed, 18 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-03-18-2864/</guid>
      <description>https://www.acmicpc.net/problem/2864
풀이: 두 정수 A 와 B 의 숫자 중
5 와 6 을 전부 5 로 바꾼 값들을 더한 값이 최솟값,
6 으로 바꾼 값들을 더한 값이 최댓값이 된다.
코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;string&amp;gt;using namespace std;int main() {string a, b, c, d, e, f;cin &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b;for (char i : a)if (i == 54 || i == 53)	c += &amp;#39;6&amp;#39;, d += &amp;#39;5&amp;#39;;else c += i, d += i;for (char i : b)if (i == 54 || i == 53)	e += &amp;#39;6&amp;#39;, f += &amp;#39;5&amp;#39;;else e += i, f += i;printf(&amp;#34;%d %d\n&amp;#34;, stoi(d) + stoi(f), stoi(c) + stoi(e));}</description>
    </item>
    
    <item>
      <title>[백준]10156 과자</title>
      <link>https://jyukki97.github.io/blog/2020-03-17-10156/</link>
      <pubDate>Tue, 17 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-03-17-10156/</guid>
      <description>https://www.acmicpc.net/problem/10156
풀이: 과자 한개의 가격 * 과자의 개수 - 현재 가진 돈 을 출력한다.
만약 출력값이 음수라면 0을 출력한다. (필요한 돈보다 가진돈이 많은 것이므로 부모님께 받을 필요없음.)
코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;using namespace std;int k, n, m;int main() {cin &amp;gt;&amp;gt; k &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;k = k * n - m;if (k &amp;lt; 0)	k = 0;cout &amp;lt;&amp;lt; k &amp;lt;&amp;lt; endl;}</description>
    </item>
    
    <item>
      <title>[백준]10707 수도요금</title>
      <link>https://jyukki97.github.io/blog/2020-03-17-10707/</link>
      <pubDate>Tue, 17 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-03-17-10707/</guid>
      <description>https://www.acmicpc.net/problem/10707
풀이: X사의 1리터당 요금 * 한 달간의 수도의 양
Y사의 기본요금 + (Y사의 1리터당 추가요금 * (한 달간의 수도의 양 - 기본요금이 되는 사용량의 상한))
둘 중 더 싼 금액을 출력한다.
코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;using namespace std;int a, b, c, d ,p;int main() {cin &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b &amp;gt;&amp;gt; c &amp;gt;&amp;gt; d &amp;gt;&amp;gt; p;a *= p, b += p &amp;lt; c ? 0 : (p - c) * d;printf(&amp;#34;%d\n&amp;#34;, a &amp;lt; b ?</description>
    </item>
    
    <item>
      <title>[백준]10833 사과</title>
      <link>https://jyukki97.github.io/blog/2020-03-17-10833/</link>
      <pubDate>Tue, 17 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-03-17-10833/</guid>
      <description>https://www.acmicpc.net/problem/10833
풀이: 배정된 사과 수를 학생수로 나눈 나머지를 모두 더해 출력한다.
코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;using namespace std;int N, a, b, c = 0;int main() {cin &amp;gt;&amp;gt; N;while (N--) {cin &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b;c += b % a;}cout &amp;lt;&amp;lt; c &amp;lt;&amp;lt; endl;}</description>
    </item>
    
    <item>
      <title>[백준]11655 ROT13</title>
      <link>https://jyukki97.github.io/blog/2020-03-17-11655/</link>
      <pubDate>Tue, 17 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-03-17-11655/</guid>
      <description>https://www.acmicpc.net/problem/11655
풀이: ROT13으로 암호화한 내용을 출력한다.
코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;string&amp;gt;using namespace std;int main() {string s;getline(cin, s);for (char c : s)	printf(&amp;#34;%c&amp;#34;, c &amp;lt; 65 ? c : (c &amp;lt; 97 &amp;amp;&amp;amp; c &amp;gt; 77) || c &amp;gt; 109 ? c - 13 : c + 13);cout &amp;lt;&amp;lt; endl;}</description>
    </item>
    
    <item>
      <title>[백준]2566 최댓값</title>
      <link>https://jyukki97.github.io/blog/2020-03-17-2566/</link>
      <pubDate>Tue, 17 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-03-17-2566/</guid>
      <description>https://www.acmicpc.net/problem/2566
풀이: 9 * 9 칸에 있는 숫자들 중 최댓값과 그 위치를 출력한다.
코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;using namespace std;int i, a, x, c = 0;int main() {for (i = 0; i &amp;lt; 81; i++){cin &amp;gt;&amp;gt; a;if (a &amp;gt; c)	c = a, x = i;}printf(&amp;#34;%d %d %d&amp;#34;, c, x / 9 + 1, x % 9 + 1);}</description>
    </item>
    
    <item>
      <title>[백준]2953 나는 요리사다</title>
      <link>https://jyukki97.github.io/blog/2020-03-17-2953/</link>
      <pubDate>Tue, 17 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-03-17-2953/</guid>
      <description>https://www.acmicpc.net/problem/2953
풀이: 첫째 줄부터 다섯번쨰 줄까지의 사람 중 점수의 합이 가장 높은 사람과 그 점수를 출력한다.
코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;using namespace std;int i, a, b, c, d, s, t = 0;int main() {for (i = 1; i &amp;lt; 6; i++) {cin &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b &amp;gt;&amp;gt; c &amp;gt;&amp;gt; d;a += b + c + d;if (a &amp;gt; t)	t = a, s = i;}printf(&amp;#34;%d %d&amp;#34;, s, t);}</description>
    </item>
    
    <item>
      <title>[백준]5063 TGN</title>
      <link>https://jyukki97.github.io/blog/2020-03-17-5063/</link>
      <pubDate>Tue, 17 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-03-17-5063/</guid>
      <description>https://www.acmicpc.net/problem/5063
풀이: 광고를 했을 때의 수익 - 광고 비용 이 광고를 했을 떄 얻을 수 있는 순이익이다.
즉, 광고를 하지않았을 때의 수익과 광고를 했을 때 얻을 수 있는 순 이익을 비교하여,
해야 하면 &amp;ldquo;advertise&amp;rdquo;, 하지 않아야 하면 &amp;ldquo;do not advertise&amp;rdquo;, 광고를 해도 수익이 차이가 없다면 &amp;ldquo;does not matter&amp;quot;를 출력한다.
코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;using namespace std;int T, k, n, m;int main() {cin &amp;gt;&amp;gt; T;while (T--) {cin &amp;gt;&amp;gt; k &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;n -= m;if (k == n)	cout &amp;lt;&amp;lt; &amp;#34;does not matter&amp;#34; &amp;lt;&amp;lt; endl;else if (k &amp;lt; n) cout &amp;lt;&amp;lt; &amp;#34;advertise&amp;#34; &amp;lt;&amp;lt; endl;else cout &amp;lt;&amp;lt; &amp;#34;do not advertise&amp;#34; &amp;lt;&amp;lt; endl;}}</description>
    </item>
    
    <item>
      <title>[백준]10820 문자열 분석</title>
      <link>https://jyukki97.github.io/blog/2020-03-16-10820/</link>
      <pubDate>Mon, 16 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-03-16-10820/</guid>
      <description>https://www.acmicpc.net/problem/10820
풀이: [C++]대소문자, 숫자 구분함수  참고
따로 종료 조건이 없으므로 EOF 처리를 해주자. 코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;string&amp;gt;using namespace std;int main() {string s;while (getline(cin, s)) {int a = 0, b = 0, c = 0, d = 0;for (char i : s)if (islower(i)) a++;else if (isupper(i)) b++;else if (isdigit(i)) c++;else d++;printf(&amp;#34;%d %d %d %d\n&amp;#34;, a, b, c, d);}}</description>
    </item>
    
    <item>
      <title>[백준]10988 팰린드롬인지 확인하기</title>
      <link>https://jyukki97.github.io/blog/2020-03-16-10988/</link>
      <pubDate>Mon, 16 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-03-16-10988/</guid>
      <description>https://www.acmicpc.net/problem/10988
풀이: 팰린드롬 : 기러기, 토마토 등 뒤집어도 같은단어 주어진 단어가 팰린드롬이라면 1, 아니라면 0을 출력한다.
코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;using namespace std;int main() {string a; bool b = true;cin &amp;gt;&amp;gt; a;for (int i = 0; i &amp;lt; a.size() / 2; i++)	if (a[i] != a[a.size() - i - 1]) b = false;if (b)	cout &amp;lt;&amp;lt; &amp;#34;1&amp;#34; &amp;lt;&amp;lt; endl;else cout &amp;lt;&amp;lt; &amp;#34;0&amp;#34; &amp;lt;&amp;lt; endl;}</description>
    </item>
    
    <item>
      <title>[백준]10991 별 찍기 - 16</title>
      <link>https://jyukki97.github.io/blog/2020-03-16-10991/</link>
      <pubDate>Mon, 16 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-03-16-10991/</guid>
      <description>https://www.acmicpc.net/problem/10991
풀이: N개의 줄에 N개의 글자를 출력한다.
첫 줄에는 N-1개의 &amp;quot; &amp;ldquo;와 1개의 &amp;ldquo;* &amp;ldquo;을
두 번째 줄에는 N-2개의 &amp;quot; &amp;ldquo;와 2개의 &amp;ldquo;* &amp;ldquo;을
.
.
.
i번째 줄에는 N-i개의 &amp;quot; &amp;ldquo;와 i개의 &amp;ldquo;* &amp;ldquo;을
출력한다.
코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;using namespace std;int N, i, t;int main() {cin &amp;gt;&amp;gt; N;for (i = 0; i &amp;lt; N; i++) {for (t = 1; t &amp;lt; N - i; t++)	cout &amp;lt;&amp;lt; &amp;#34;&amp;#34;;for (; t &amp;lt;= N; t++) cout &amp;lt;&amp;lt; &amp;#34;* &amp;#34;;cout &amp;lt;&amp;lt; endl;}}</description>
    </item>
    
    <item>
      <title>[백준]10992 별 찍기 - 17</title>
      <link>https://jyukki97.github.io/blog/2020-03-16-10992/</link>
      <pubDate>Mon, 16 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-03-16-10992/</guid>
      <description>https://www.acmicpc.net/problem/10992
풀이: 첫줄에 1개, 마지막줄에 2 * N - 1개
i번째 줄에는 N - i 칸 띄고, &amp;ldquo;&amp;rdquo; 한개, 2 * i - 1 칸 띄고, &amp;ldquo;&amp;rdquo; 한개
출력한다.
코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;using namespace std;int N, i, t;int main() {cin &amp;gt;&amp;gt; N;for (i = 0; i &amp;lt; N; i++) {for (t = 1; t &amp;lt; N - i; t++)	cout &amp;lt;&amp;lt; &amp;#34;&amp;#34;;cout &amp;lt;&amp;lt; &amp;#34;*&amp;#34;;for (t = 0; t &amp;lt; 2 * i - 1; t++) printf(&amp;#34;%s&amp;#34;, i == N - 1 ?</description>
    </item>
    
    <item>
      <title>[백준]11659 구간 합 구하기</title>
      <link>https://jyukki97.github.io/blog/2020-03-16-11659/</link>
      <pubDate>Mon, 16 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-03-16-11659/</guid>
      <description>https://www.acmicpc.net/problem/11659
풀이: a[i] : 1 ~ i 까지의 구간 합
i ~ j 까지의 구간 합 = 1 ~ j 까지의 구간 합 - 1 ~ i - 1 까지의 구간 합
cin, cout 은 시간초과가 나므로 주의하자. 코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;using namespace std;int N, M, q, w, i, a[100002];int main() {scanf(&amp;#34;%d%d&amp;#34;,&amp;amp;N,&amp;amp;M);for (i = 1; i &amp;lt;= N; i++){scanf(&amp;#34;%d&amp;#34;,&amp;amp;q);a[i] = a[i - 1] + q;}	while (M--) {scanf(&amp;#34;%d%d&amp;#34;,&amp;amp;q,&amp;amp;w);printf(&amp;#34;%d\n&amp;#34;, a[w] - a[q - 1]);}}</description>
    </item>
    
    <item>
      <title>[백준]11728 배열 합치기</title>
      <link>https://jyukki97.github.io/blog/2020-03-16-11728/</link>
      <pubDate>Mon, 16 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-03-16-11728/</guid>
      <description>https://www.acmicpc.net/problem/11728
풀이: n + m 만큼의 숫자를 받아온다.
받아온 숫자를 정렬하여 출력한다.
cin, cout 은 시간초과가 나므로 주의하자. 코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;queue&amp;gt;using namespace std;int n, m;int main() {scanf(&amp;#34;%d%d&amp;#34;,&amp;amp;n,&amp;amp;m);n += m;priority_queue&amp;lt;int, vector&amp;lt;int&amp;gt;, greater&amp;lt;int&amp;gt;&amp;gt; a;while (n--) {scanf(&amp;#34;%d&amp;#34;,&amp;amp;m);a.push(m);}while (!a.empty())	printf(&amp;#34;%d &amp;#34;,a.top()), a.pop();printf(&amp;#34;\n&amp;#34;);}</description>
    </item>
    
    <item>
      <title>[백준]1915 가장 큰 정사각형</title>
      <link>https://jyukki97.github.io/blog/2020-03-16-1915/</link>
      <pubDate>Mon, 16 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-03-16-1915/</guid>
      <description>https://www.acmicpc.net/problem/1915
풀이: b[i][t] : i , t 가 오른쪽 아래 꼭짓점인 정사각형의 한 변의 길이
i, t가 0이라면, 정사각형을 만들 수 없으므로 0
i, t 의 수가 1이라면,
b[i][t] = (b[i - 1][t], b[i][t - 1], b[i - 1][t - 1] 의 최솟값) + 1
넓이 이므로 b[i][t] 중 가장 큰 값을 제곱하여 출력한다.
코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;using namespace std;int n, m, i, t, a, b[1002][1002], s = 0;int main() {cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;for (i = 0; i &amp;lt; n; i++)	for (t = 0; t &amp;lt; m; t++) {scanf_s(&amp;#34;%1d&amp;#34;,&amp;amp;a);if (a) {if (i &amp;amp;&amp;amp; t) {b[i][t] = b[i - 1][t] &amp;gt; b[i][t - 1] ?</description>
    </item>
    
    <item>
      <title>[백준]1922 네트워크 연결</title>
      <link>https://jyukki97.github.io/blog/2020-03-16-1922/</link>
      <pubDate>Mon, 16 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-03-16-1922/</guid>
      <description>https://www.acmicpc.net/problem/1922
풀이: [백준]1197 최소 스패닝 트리 참고
코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;queue&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std;typedef pair&amp;lt;int, int&amp;gt; P;int N, E, q, w, e, b[1002] = { 1,1 };int main() {cin &amp;gt;&amp;gt; N &amp;gt;&amp;gt; E;vector&amp;lt;priority_queue&amp;lt;P, vector&amp;lt;P&amp;gt;, greater&amp;lt;P&amp;gt;&amp;gt;&amp;gt; a(N + 1);vector&amp;lt;int&amp;gt; v = { 1 };for (int i = 0; i &amp;lt; E; i++) {cin &amp;gt;&amp;gt; q &amp;gt;&amp;gt; w &amp;gt;&amp;gt; e;a[q].</description>
    </item>
    
    <item>
      <title>[백준]2252 줄 세우기</title>
      <link>https://jyukki97.github.io/blog/2020-03-16-2252/</link>
      <pubDate>Mon, 16 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-03-16-2252/</guid>
      <description>https://www.acmicpc.net/problem/2252
풀이: b[i] : i 보다 작은 사람들의 수
b[i] 가 0인 i를 맨 앞에 세운다.
i보다 큰 학생들을 t라고 할 때, b[t] 값을 각각 -1 해준다.
모든 학생들을 세울때까지 반복한다.
코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std;int n, m, i, q, w, b[32002], c[32002];int main() {cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; a(n + 1);vector&amp;lt;int&amp;gt; v;for (i = 0; i &amp;lt; m; i++) {cin &amp;gt;&amp;gt; q &amp;gt;&amp;gt; w;a[q].</description>
    </item>
    
    <item>
      <title>[백준]2420 사파리월드</title>
      <link>https://jyukki97.github.io/blog/2020-03-16-2420/</link>
      <pubDate>Mon, 16 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-03-16-2420/</guid>
      <description>https://www.acmicpc.net/problem/2420
풀이: 두 유명도의 차이를 절댓값으로 출력한다.
두 도메인의 크기가 매우 크므로 long long 으로 받자. long long 형으로 받았으므로 abs 가 아닌 llabs를 쓰자 코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;using namespace std;long long a, b;int main() {cin &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b;cout &amp;lt;&amp;lt; llabs(a - b) &amp;lt;&amp;lt; endl;}</description>
    </item>
    
    <item>
      <title>[백준]2530 인공지능 시계</title>
      <link>https://jyukki97.github.io/blog/2020-03-16-2530/</link>
      <pubDate>Mon, 16 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-03-16-2530/</guid>
      <description>https://www.acmicpc.net/problem/2530
풀이: 요리에 필요한 시간 D를 초에 더한다.
초 C를 60으로 나눈 몫을 분에 더한다.	초는 나눈 나머지가 된다.
분 B를 60으로 나눈 몫을 시에 더하다.	분은 나눈 나머지가 된다.
시를 24로 나눈 나머지로 바꾼다.
코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;using namespace std;int a, b, c, d;int main() {cin &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b &amp;gt;&amp;gt; c &amp;gt;&amp;gt; d;c += d, b += c / 60, c %= 60, a += b / 60, b %= 60, a %= 24;printf(&amp;#34;%d %d %d&amp;#34;, a, b, c);}</description>
    </item>
    
    <item>
      <title>[백준]5597 과제 안 내신 분..?</title>
      <link>https://jyukki97.github.io/blog/2020-03-16-5597/</link>
      <pubDate>Mon, 16 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-03-16-5597/</guid>
      <description>https://www.acmicpc.net/problem/5597
풀이: 과제를 낸 28 명을 기록한다.
30 명 중 기록이 안돼어있는 학생 2명을 출력한다.
코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;using namespace std;int a[31], i = 28, b;int main() {while (i--) {cin &amp;gt;&amp;gt; b;a[b] = 1;}for (i = 1; i &amp;lt;= 30; i++)	if (!a[i])	cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; endl;}</description>
    </item>
    
    <item>
      <title>[백준]10824 네 수</title>
      <link>https://jyukki97.github.io/blog/2020-03-15-10824/</link>
      <pubDate>Sun, 15 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-03-15-10824/</guid>
      <description>https://www.acmicpc.net/problem/10824
풀이: A, B, C, D 를 각각 string으로 받아 붙힌 후
숫자로 변환하여 더해 출력한다.
stoi 는 int형식으로 각각 1,000,000 까지 가능 한 두 수를 붙힌다면 넘어가므로 stoll을 사용하자. 코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;string&amp;gt;using namespace std;string a,b,c,d;int main() {cin &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b &amp;gt;&amp;gt; c &amp;gt;&amp;gt; d;cout &amp;lt;&amp;lt; stoll(a + b) + stoll(c + d) &amp;lt;&amp;lt; endl;}</description>
    </item>
    
    <item>
      <title>[백준]2644 촌수계산</title>
      <link>https://jyukki97.github.io/blog/2020-03-15-2644/</link>
      <pubDate>Sun, 15 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-03-15-2644/</guid>
      <description>https://www.acmicpc.net/problem/2644
풀이: [C++]다익스트라 알고리즘(Dijkstra Algorithm) 참고
코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;queue&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std;int n, k, e, q, w, m, d[102], b[102];int main() {cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; k &amp;gt;&amp;gt; e &amp;gt;&amp;gt; m;vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; a(n + 1);priority_queue&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; p;while(m--) {cin &amp;gt;&amp;gt; q &amp;gt;&amp;gt; w;a[q].push_back(w), a[w].push_back(q);}fill(d, d + n + 1, 101);d[k] = 0;p.push({ 0, k });while (!</description>
    </item>
    
    <item>
      <title>[백준]10797 10부제</title>
      <link>https://jyukki97.github.io/blog/2020-03-14-10797/</link>
      <pubDate>Sat, 14 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-03-14-10797/</guid>
      <description>https://www.acmicpc.net/problem/10797
풀이: 날짜의 일의 자리 숫자와 자동차의 일의 자리 숫자가 같다면 차량의 대수를 +1 해준다.
코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;using namespace std;int n, m, i, s = 0;int main() {cin &amp;gt;&amp;gt; n;for (i = 0; i &amp;lt; 5; i++) {cin &amp;gt;&amp;gt; m;if (n == m)	s++;}cout &amp;lt;&amp;lt; s &amp;lt;&amp;lt; endl;}</description>
    </item>
    
    <item>
      <title>[백준]10815 숫자 카드</title>
      <link>https://jyukki97.github.io/blog/2020-03-14-10815/</link>
      <pubDate>Sat, 14 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-03-14-10815/</guid>
      <description>https://www.acmicpc.net/problem/10815
풀이: [C++]lower_bound, upper_bound 참고
cin, cout 은 시간초과가 날 수 있으므로 주의하자. 코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;int n, m, i, k, a[500002];int main() {cin &amp;gt;&amp;gt; n;for (i = 0; i &amp;lt; n; i++)	cin &amp;gt;&amp;gt; a[i];sort(a, a + n);cin &amp;gt;&amp;gt; m;while (m--) {cin &amp;gt;&amp;gt; k;if (*lower_bound(a, a + n, k) == k)	cout &amp;lt;&amp;lt; &amp;#34;1 &amp;#34;;else	cout &amp;lt;&amp;lt; &amp;#34;0 &amp;#34;;}cout &amp;lt;&amp;lt; endl;}</description>
    </item>
    
    <item>
      <title>[백준]10974 모든 순열</title>
      <link>https://jyukki97.github.io/blog/2020-03-14-10974/</link>
      <pubDate>Sat, 14 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-03-14-10974/</guid>
      <description>https://www.acmicpc.net/problem/10974
풀이: [C++]순열  참고
cin, cout 은 시간초과가 날 수 있으므로 주의하자. 코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;int n, i; vector&amp;lt;int&amp;gt; v;int main() {scanf(&amp;#34;%d&amp;#34;,&amp;amp;n);for (i = 1; i &amp;lt;= n; i++) v.push_back(i);do {for (int i : v) printf(&amp;#34;%d &amp;#34;,i);printf(&amp;#34;\n&amp;#34;);} while (next_permutation(v.begin(), v.end()));}</description>
    </item>
    
    <item>
      <title>[백준]1916 최소비용 구하기</title>
      <link>https://jyukki97.github.io/blog/2020-03-14-1916/</link>
      <pubDate>Sat, 14 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-03-14-1916/</guid>
      <description>https://www.acmicpc.net/problem/1916
풀이: [C++]다익스트라 알고리즘(Dijkstra Algorithm) 참고
코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;queue&amp;gt;using namespace std;int n, m, u, d[1002], s, e, c, b[1002];int main() {cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;priority_queue&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; p;vector&amp;lt;vector&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt;&amp;gt; a(n + 1);while (m--) {cin &amp;gt;&amp;gt; s &amp;gt;&amp;gt; e &amp;gt;&amp;gt; c;a[s].push_back({ e,c });}cin &amp;gt;&amp;gt; s &amp;gt;&amp;gt; e;fill(d, d + n + 1, 987654321);d[s] = 0;p.</description>
    </item>
    
    <item>
      <title>[백준]2003 수들의 합 2</title>
      <link>https://jyukki97.github.io/blog/2020-03-14-2003/</link>
      <pubDate>Sat, 14 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-03-14-2003/</guid>
      <description>https://www.acmicpc.net/problem/2003
풀이: A[i] 부터 A[j] 까지 하나씩 더해가는 값을 s라고 하자.
만약, s가 m과 같다면, 경우의 수를 +1 해준다.
만약, s가 m보다 크다면, i를 1 더해주고, 다시 반복한다.
i가 n이 될때까지 반복 후 경우의 수를 출력해준다.
코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;using namespace std;int n, m, i, t, a[10002], s, c = 0;int main() {scanf(&amp;#34;%d%d&amp;#34;,&amp;amp;n,&amp;amp;m);for (i = 0; i &amp;lt; n; i++)	scanf(&amp;#34;%d&amp;#34;,&amp;amp;a[i]);for (i = 0; i &amp;lt; n; i++) {s = 0;for (t = i; t &amp;lt; n; t++) {s += a[t];if (s == m) c++;if (s &amp;gt;= m)	break;}}printf(&amp;#34;%d\n&amp;#34;,c);}</description>
    </item>
    
    <item>
      <title>[백준]2446 별 찍기 - 9</title>
      <link>https://jyukki97.github.io/blog/2020-03-14-2446/</link>
      <pubDate>Sat, 14 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-03-14-2446/</guid>
      <description>https://www.acmicpc.net/problem/2446
풀이: [백준]2442 별찍기 - 5 에 나온 삼각형을 방향을 반대로 2번 출력한다.
코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;using namespace std;int n;int main() {cin &amp;gt;&amp;gt; n;for (int i = 0; i &amp;lt; n - 1; i++) {for (int t = 0; t &amp;lt; i; t++) cout &amp;lt;&amp;lt; &amp;#34;&amp;#34;;for (int t = 1; t &amp;lt; (n -i) * 2; t++) cout &amp;lt;&amp;lt; &amp;#34;*&amp;#34;;cout &amp;lt;&amp;lt; endl;}for (int i = 0; i &amp;lt; n; i++) {for (int t = 1; t &amp;lt; n - i; t++) cout &amp;lt;&amp;lt; &amp;#34;&amp;#34;;for (int t = 0; t &amp;lt; i * 2 + 1; t++) cout &amp;lt;&amp;lt; &amp;#34;*&amp;#34;;cout &amp;lt;&amp;lt; endl;}}</description>
    </item>
    
    <item>
      <title>[백준]2583 영역 구하기</title>
      <link>https://jyukki97.github.io/blog/2020-03-14-2583/</link>
      <pubDate>Sat, 14 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-03-14-2583/</guid>
      <description>https://www.acmicpc.net/problem/2583
풀이: 직사각형이 들어있는 곳을 1,
없는곳을 0으로 해놓은 배열을 만든다.
배열을 순회하며, 현재 값이 0 이라면, 영역의 개수를 +1 해주고,
연결된 모든 영역을 순회하여 1로 바꿔주고, 영역의 넓이를 배열에 저장한다.
배열의 모든 숫자가 1이라면,
영역의 개수를 출력하고,
각 영역의 넓이를 오름차순으로 출력한다.
코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;int n, m, k, i, t, a[102][102], x1, x2, yl, y2, s = 0, b[5002];void A(int x, int y) {a[x][y] = 1, b[s - 1]++;if (x &amp;gt; 0 &amp;amp;&amp;amp; !</description>
    </item>
    
    <item>
      <title>[프로그래머스]카카오프렌즈 컬러링북</title>
      <link>https://jyukki97.github.io/blog/2020-03-14-coloringbook/</link>
      <pubDate>Sat, 14 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-03-14-coloringbook/</guid>
      <description>https://programmers.co.kr
문제: 카카오 프렌즈 컬러링북 출판사의 편집자인 어피치는 네오에게 컬러링북에 들어갈 원화를 그려달라고 부탁하여 여러 장의 그림을 받았다. 여러 장의 그림을 난이도 순으로 컬러링북에 넣고 싶었던 어피치는 영역이 많으면 색칠하기가 까다로워 어려워진다는 사실을 발견하고 그림의 난이도를 영역의 수로 정의하였다. (영역이란 상하좌우로 연결된 같은 색상의 공간을 의미한다.)
그림에 몇 개의 영역이 있는지와 가장 큰 영역의 넓이는 얼마인지 계산하는 프로그램을 작성해보자.
위의 그림은 총 12개 영역으로 이루어져 있으며, 가장 넓은 영역은 어피치의 얼굴면으로 넓이는 120이다.</description>
    </item>
    
    <item>
      <title>[백준]10799 쇠막대기</title>
      <link>https://jyukki97.github.io/blog/2020-03-13-10799/</link>
      <pubDate>Fri, 13 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-03-13-10799/</guid>
      <description>https://www.acmicpc.net/problem/10799
풀이: [프로그래머스]쇠막대기 참고
코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;stack&amp;gt;using namespace std;int n, i, b = 0; stack&amp;lt;char&amp;gt; a;	string s;int main() {cin &amp;gt;&amp;gt; s;for (i = 0; i &amp;lt; s.size() - 1; i++)if (s[i] == &amp;#39;(&amp;#39;)if (s[i + 1] == &amp;#39;)&amp;#39;)	b += a.size(), i++;else a.push(s[i]);else	a.pop(), b++;cout &amp;lt;&amp;lt; b + 1 &amp;lt;&amp;lt; endl;}</description>
    </item>
    
    <item>
      <title>[백준]11403 경로 찾기</title>
      <link>https://jyukki97.github.io/blog/2020-03-13-11403/</link>
      <pubDate>Fri, 13 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-03-13-11403/</guid>
      <description>https://www.acmicpc.net/problem/11403
풀이: [C++]플로이드-와샬 알고리즘(Floyd-Warshall Algorithm) 참고
코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#define F(i,n)for(int i=0;i&amp;lt;n;i++)using namespace std;int n, a[102][102];int main() {cin &amp;gt;&amp;gt; n;F(i, n)	F(t, n)	cin &amp;gt;&amp;gt; a[i][t];F(u, 2) F(i, n)	F(t, n)	F(y, n) if(!a[i][t]) a[i][t] = a[i][y] &amp;amp; a[y][t];F(i, n) {F(t, n) cout &amp;lt;&amp;lt; a[i][t] &amp;lt;&amp;lt; &amp;#34;&amp;#34;;cout &amp;lt;&amp;lt; endl;}}</description>
    </item>
    
    <item>
      <title>[백준]2468 안전 영역</title>
      <link>https://jyukki97.github.io/blog/2020-03-13-2468/</link>
      <pubDate>Fri, 13 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-03-13-2468/</guid>
      <description>https://www.acmicpc.net/problem/2468
풀이: 물의 높이가 h 일 때,
지역의 높이가 h보다 작거나 같다면 잠겨있는 지역이라고 한다.
모든 지역을 순회하며,
현재 지역이 잠겨있지 않다면, 방문 표시를 해두고,
왼쪽, 오른쪽, 위, 아래 에 잠겨있지 않은 곳을 순회하며 방문표시를 한다.
연결된 모든 곳을 방문했다면, 안전한 영역을 +1 해준다.
물의 높이를 0 ~ (지역 중 최대 높이) 까지 순회한 후
안전한 영역의 최대치를 출력한다.
코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#define F(i,n)for(int i=0;i&amp;lt;n;i++)using namespace std;int n, m = 0, a[102][102], b[102][102], s, r = 0;void A(int x, int y) {b[x][y] = 0;if (x &amp;gt; 0 &amp;amp;&amp;amp; b[x - 1][y])	A(x - 1, y);if (y &amp;gt; 0 &amp;amp;&amp;amp; b[x][y - 1])	A(x, y - 1);if (x + 1 &amp;lt; n &amp;amp;&amp;amp; b[x + 1][y])	A(x + 1, y);if (y + 1 &amp;lt; n &amp;amp;&amp;amp; b[x][y + 1])	A(x, y + 1);}int main() {cin &amp;gt;&amp;gt; n;F(i,n)F(t,n){cin &amp;gt;&amp;gt; a[i][t];m = m &amp;lt; a[i][t] ?</description>
    </item>
    
    <item>
      <title>[백준]11724 연결 요소의 개수</title>
      <link>https://jyukki97.github.io/blog/2020-03-12-11724/</link>
      <pubDate>Thu, 12 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-03-12-11724/</guid>
      <description>https://www.acmicpc.net/problem/11724
풀이: 방문하지 않은 정점과 연결된 모든 정점을 방문표시하고, 요소의 개수를 +1 해준다.
더이상 방문할 정점이 없을때까지 반복한다.
코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std;int n, m, i, t, c = 0, b[1002];vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; a;void T(int x) {if (b[x]) return;b[x] = 1;for (int o : a[x])	T(o);}int main() {cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;a.resize(n + 1);while (m--) {cin &amp;gt;&amp;gt; i &amp;gt;&amp;gt; t;a[i].</description>
    </item>
    
    <item>
      <title>[백준]13458 시험 감독</title>
      <link>https://jyukki97.github.io/blog/2020-03-12-13458/</link>
      <pubDate>Thu, 12 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-03-12-13458/</guid>
      <description>https://www.acmicpc.net/problem/13458
풀이: 각 시험장에 총감독관 1명씩이 꼭 들어간다.
즉 각 시험장에 있는 응시자의 수에서 총감독관이 감시할 수 있는 응시자의 수 B를 빼준다.
빼준 값에서 부감독관이 감시할 수 있는 응시자의 수 C를 나눈 값을 올림해 준다면,
부감독관의 수가 나온다.
감독관들의 수를 모두 더한값을 출력한다.
코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;math.h&amp;gt;using namespace std;long long n, i, b, c, a[1000002], s = 0;int main() {cin &amp;gt;&amp;gt; n;for (i = 0; i &amp;lt; n; i++)	cin &amp;gt;&amp;gt; a[i];cin &amp;gt;&amp;gt; b &amp;gt;&amp;gt; c;for (i = 0; i &amp;lt; n; i++) {a[i] -= b;if (a[i] &amp;gt; 0)	s += ceil((double)a[i] / c);s++;}cout &amp;lt;&amp;lt; s &amp;lt;&amp;lt; endl;}</description>
    </item>
    
    <item>
      <title>[백준]2309 일곱 난쟁이</title>
      <link>https://jyukki97.github.io/blog/2020-03-12-2309/</link>
      <pubDate>Thu, 12 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-03-12-2309/</guid>
      <description>https://www.acmicpc.net/problem/2309
풀이: 아홉 난쟁이의 키의 합을 S라고 하자.
아홉 난쟁이 중 랜덤으로 뽑은 두 명의 키의 합을 T라고 하자.
S - T = 100 이라면
뽑은 두 난쟁이를 제외하고 오름차순으로 출력한다.
코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;int a[9], i, t, s = 0;int main() {for (i = 0; i &amp;lt; 9; i++) {cin &amp;gt;&amp;gt; a[i];s += a[i];}sort(a, a + 9);for (i = 0; i &amp;lt; 9; i++) {for (t = i + 1; t &amp;lt; 9; t++)	if (s - a[i] - a[t] == 100)	break;if (s - a[i] - a[t] == 100)	break;}for (s = 0; s &amp;lt; 9; s++)	if (s !</description>
    </item>
    
    <item>
      <title>[백준]2442 별 찍기 - 5</title>
      <link>https://jyukki97.github.io/blog/2020-03-12-2442/</link>
      <pubDate>Thu, 12 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-03-12-2442/</guid>
      <description>https://www.acmicpc.net/problem/2442
풀이: 1 번째 줄부터 차례대로
1개
3개
5개
.
.
.
i * 2 - 1 개
의 별을 출력한다.
코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;using namespace std;int n, i, t;int main() {cin &amp;gt;&amp;gt; n;for (i = 1; i &amp;lt;= n; i++) {for (t = 0; t &amp;lt; n - i; t++)	cout &amp;lt;&amp;lt; &amp;#34;&amp;#34;;for (t = 0; t &amp;lt; 2 * i - 1; t++) cout &amp;lt;&amp;lt; &amp;#34;*&amp;#34;;cout &amp;lt;&amp;lt; endl;}}</description>
    </item>
    
    <item>
      <title>[백준]4963 섬의 개수</title>
      <link>https://jyukki97.github.io/blog/2020-03-12-4963/</link>
      <pubDate>Thu, 12 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-03-12-4963/</guid>
      <description>https://www.acmicpc.net/problem/4963
풀이: 모든 지도를 순회한다.
만약 지도의 한 부분이 땅이라면,
연결된 모든 땅을 바다로 바꾼 후 섬의 개수를 +1 해준다.
지도의 모든 부분이 바다로 바뀔때까지 반복한다.
섬의 개수를 출력한다.
코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;using namespace std;int n, m, i, t, a[52][52], c;void I(int x, int y) {a[x][y] = 0;if (x &amp;gt; 0 &amp;amp;&amp;amp; y &amp;gt; 0 &amp;amp;&amp;amp; a[x - 1][y - 1]) I(x - 1, y - 1);if (x &amp;gt; 0 &amp;amp;&amp;amp; a[x - 1][y]) I(x - 1, y);if (x &amp;gt; 0 &amp;amp;&amp;amp; y + 1 &amp;lt; n &amp;amp;&amp;amp; a[x - 1][y + 1]) I(x - 1, y + 1);if (y &amp;gt; 0 &amp;amp;&amp;amp; a[x][y - 1]) I(x, y - 1);if (y + 1 &amp;lt; n &amp;amp;&amp;amp; a[x][y + 1]) I(x, y + 1);if (x + 1 &amp;lt; m &amp;amp;&amp;amp; y &amp;gt; 0 &amp;amp;&amp;amp; a[x + 1][y - 1]) I(x + 1, y - 1);if (x + 1 &amp;lt; m &amp;amp;&amp;amp; a[x + 1][y]) I(x + 1, y);if (x + 1 &amp;lt; m &amp;amp;&amp;amp; y + 1 &amp;lt; n &amp;amp;&amp;amp; a[x + 1][y + 1]) I(x + 1, y + 1);}int main() {while (1) {cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;c = 0;if (!</description>
    </item>
    
    <item>
      <title>[백준]5543 상근날드</title>
      <link>https://jyukki97.github.io/blog/2020-03-12-5543/</link>
      <pubDate>Thu, 12 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-03-12-5543/</guid>
      <description>https://www.acmicpc.net/problem/5543
풀이: 햅버거 중 가장 싼 것 + 음료 중 가장 싼 것 - 50원
코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;using namespace std;int a,b,c,d,e;int main() {cin &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b &amp;gt;&amp;gt; c &amp;gt;&amp;gt; d &amp;gt;&amp;gt; e;a = a &amp;lt; b ? a : b;a = a &amp;lt; c ? a : c;d = d &amp;lt; e ? d : e;cout &amp;lt;&amp;lt; a + d - 50 &amp;lt;&amp;lt; endl;}</description>
    </item>
    
    <item>
      <title>[백준]1225 이상한 곱셈</title>
      <link>https://jyukki97.github.io/blog/2020-03-11-1225/</link>
      <pubDate>Wed, 11 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-03-11-1225/</guid>
      <description>https://www.acmicpc.net/problem/1225
풀이: 123 * 45
-&amp;gt; 1*4 + 1*5 + 2*4 + 2*5 + 3*4 + 3*4
-&amp;gt; 1(4 + 5) + 2(4 + 5) + 3(4 + 5)
-&amp;gt; (1 + 2 + 3)(4 + 5)
즉, (왼쪽 숫자의 각 자릿수의 합) * (오른쪽 숫자의 각 자릿수의 합) 이다.
코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;using namespace std;long long q = 0, w = 0, i;int main() {string a, b;cin &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b;for (i = 0; i &amp;lt; a.</description>
    </item>
    
    <item>
      <title>[백준]1373 2진수 8진수</title>
      <link>https://jyukki97.github.io/blog/2020-03-11-1373/</link>
      <pubDate>Wed, 11 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-03-11-1373/</guid>
      <description>https://www.acmicpc.net/problem/1373
풀이: 2진수를 8진수로 변환하여 출력.
변환하는 방법은
11001100(2) 일때,
뒤에서 부터 3자리로 끊어서 생각한다.
011 001 100
-&amp;gt; 3	1	4
주어진 수의 &amp;lsquo;길이&amp;rsquo; 가 1,000,000 까지 갈 수 있으므로 주의하자.
(수가 1,000,000 이 아니다. 수의 길이 이므로 엄청나게 큰 수가 들어온다.)
코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;string&amp;gt;using namespace std;int b, c, i, t;int main() {string s, a;cin &amp;gt;&amp;gt; s;for (i = s.</description>
    </item>
    
    <item>
      <title>[백준]1389 케빈 베이컨의 6단계 법칙</title>
      <link>https://jyukki97.github.io/blog/2020-03-10-1389/</link>
      <pubDate>Tue, 10 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-03-10-1389/</guid>
      <description>https://www.acmicpc.net/problem/1389
풀이: [C++]플로이드-와샬 알고리즘(Floyd-Warshall Algorithm) 참고
코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;int N, M, q, w, d[102][102], a, s = 987654321, c, i, t, y;int main() {cin &amp;gt;&amp;gt; N &amp;gt;&amp;gt; M;for (i = 0; i &amp;lt; M; i++) {cin &amp;gt;&amp;gt; q &amp;gt;&amp;gt; w;d[q][w] = 1;d[w][q] = 1;}for (i = 1; i &amp;lt;= N; i++)for (t = 1; t &amp;lt;= N; t++)if (i !</description>
    </item>
    
    <item>
      <title>[백준]1238 파티</title>
      <link>https://jyukki97.github.io/blog/2020-03-09-1238/</link>
      <pubDate>Mon, 09 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-03-09-1238/</guid>
      <description>https://www.acmicpc.net/problem/1238
풀이: [C++]다익스트라 알고리즘(Dijkstra Algorithm) 참고
코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;queue&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;int V, E, k, u, v, w, i, t, d1[1002], d2[1002], b[1002], s = 0;int main() {cin &amp;gt;&amp;gt; V &amp;gt;&amp;gt; E &amp;gt;&amp;gt; k;priority_queue&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; p;vector&amp;lt;vector&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt;&amp;gt;a(V + 1);for (i = 0; i &amp;lt; E; i++) {cin &amp;gt;&amp;gt; u &amp;gt;&amp;gt; v &amp;gt;&amp;gt; w;a[u].push_back({ v,w });}fill(d2, d2 + V + 1, 987654321);d2[k] = 0;p.</description>
    </item>
    
    <item>
      <title>[백준]1261 알고스팟</title>
      <link>https://jyukki97.github.io/blog/2020-03-08-1261/</link>
      <pubDate>Sun, 08 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-03-08-1261/</guid>
      <description>https://www.acmicpc.net/problem/1261
풀이: [C++]다익스트라 알고리즘(Dijkstra Algorithm) 참고
코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;queue&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;int N, M, b[102][102], q, w, e, dp[102][102];int main() {cin &amp;gt;&amp;gt; M &amp;gt;&amp;gt; N;fill(dp[0], dp[0] + 10201, 987654321);vector&amp;lt;string&amp;gt; v(N);priority_queue&amp;lt;pair&amp;lt;int, pair&amp;lt;int, int&amp;gt;&amp;gt;&amp;gt; p;p.push({ 0,{0,0} });dp[0][0] = 0;for (int i = 0; i &amp;lt; N; i++)	cin &amp;gt;&amp;gt; v[i];while (!p.empty()) {q = p.</description>
    </item>
    
    <item>
      <title>[백준]1120 문자열</title>
      <link>https://jyukki97.github.io/blog/2020-03-07-1120/</link>
      <pubDate>Sat, 07 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-03-07-1120/</guid>
      <description>https://www.acmicpc.net/problem/1120
풀이: a 와 b의 (0번째 ~ a의 길이) 의 차이의 개수
a 와 b의 (1번째 ~ a의 길이) 의 차이의 개수
.
.
.
a 와 b의 ()(b의 길이 - a의 길이)번째 ~ a의 길이) 의 차이의 개수
중 가장 작은것을 출력한다.
코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;using namespace std;int main() {int c = 51;string a, b;cin &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b;for (int i = 0; i &amp;lt;= b.</description>
    </item>
    
    <item>
      <title>[백준]1158 요세푸스 문제</title>
      <link>https://jyukki97.github.io/blog/2020-03-07-1158/</link>
      <pubDate>Sat, 07 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-03-07-1158/</guid>
      <description>https://www.acmicpc.net/problem/1158
풀이: K번째 사람을 출력한다.
K번째 사람을 배열에서 삭제한다.
삭제한 지점을 기준으로 K번째 사람을 출력한다.
반복한다.
코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std;int N, K, c;int main() {cin &amp;gt;&amp;gt; N &amp;gt;&amp;gt; K;vector&amp;lt;int&amp;gt; a;for (int i = 1; i &amp;lt;= N; i++)	a.push_back(i);c = K - 1;cout &amp;lt;&amp;lt; &amp;#34;&amp;lt;&amp;#34;;while (a.size() != 1) {if (c &amp;gt;= a.size())	c %= a.</description>
    </item>
    
    <item>
      <title>[백준]1159 농구 경기</title>
      <link>https://jyukki97.github.io/blog/2020-03-07-1159/</link>
      <pubDate>Sat, 07 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-03-07-1159/</guid>
      <description>https://www.acmicpc.net/problem/1159
풀이: 각 선수의 성의 첫글자를 확인한다.
a ~ z 까지의 배열 에서 첫글자에 해당하는 배열을 +1 해준다.
a~ z 까지 확인한다.
5명 이상인 글자는 출력한다.
만약, 출력한 글자가 없다면, &amp;ldquo;PREDAJA&amp;rdquo; 를 출력한다.
코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;using namespace std;int N, a[26], b = 0, i = 26;int main() {cin &amp;gt;&amp;gt; N;while(N--) {string s;cin &amp;gt;&amp;gt; s;a[122 - s[0]]++;}while(i--)if (a[i] &amp;gt; 4) {b = 1;cout &amp;lt;&amp;lt; char(122 - i);}if (!</description>
    </item>
    
    <item>
      <title>[백준]1182 부분수열의 합</title>
      <link>https://jyukki97.github.io/blog/2020-03-07-1182/</link>
      <pubDate>Sat, 07 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-03-07-1182/</guid>
      <description>https://www.acmicpc.net/problem/1182
풀이: N개의 정수로 이루어진 수열을 a라고 했을 때,
a의 부분수열을 모두 탐색하여 그 합이 S가 되는 갯수를 출력한다.
코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;using namespace std;int N, S, a[22], s = 0;void B(int x, int y) {if (x &amp;gt; -1 &amp;amp;&amp;amp; y == S)	s++;while(++x &amp;lt; N)	B(x, y + a[x]);}int main() {cin &amp;gt;&amp;gt; N &amp;gt;&amp;gt; S;for (int i = 0; i &amp;lt; N; i++)	cin &amp;gt;&amp;gt; a[i];B(-1, 0);cout &amp;lt;&amp;lt; s &amp;lt;&amp;lt; endl;}</description>
    </item>
    
    <item>
      <title>[백준]1197 최소 스패닝 트리</title>
      <link>https://jyukki97.github.io/blog/2020-03-07-1197/</link>
      <pubDate>Sat, 07 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-03-07-1197/</guid>
      <description>https://www.acmicpc.net/problem/1197
풀이: 배열 v를 현재 만들어진 트리에 들어있는 노드들의 집합 이라고 하자.
시작할 때 배열 v에 1 하나만 넣고 시작한다.
배열 v를 모두 순회하여 현재 트리에서 뻗어갈 수 있고, 가중치가 가장 작은 간선을 찾는다.
간선을 연결 한 후 연결된 노드를 배열 v에 저장한다.
배열 v에 모든 정점이 들어올때까지 반복한다.
트리에 모든 가중치를 더해 출력한다.
코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;queue&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std;typedef pair&amp;lt;int, int&amp;gt; P;int N, E, q, w, e, b[10002] = { 1,1 };vector&amp;lt;priority_queue&amp;lt;P, vector&amp;lt;P&amp;gt;, greater&amp;lt;P&amp;gt;&amp;gt;&amp;gt; a;int main() {cin &amp;gt;&amp;gt; N &amp;gt;&amp;gt; E;a.</description>
    </item>
    
    <item>
      <title>[백준]1015 수열 정렬</title>
      <link>https://jyukki97.github.io/blog/2020-03-06-1015/</link>
      <pubDate>Fri, 06 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-03-06-1015/</guid>
      <description>https://www.acmicpc.net/problem/1015
풀이: 배열 A를 정렬한 배열을 배열 B라고 하자.
현재 위치가 i 일 때, A[i] 값이 배열 B의 어디에 위치해 있는지 찾아서 출력한다.
ex)
A
2 3 1
B
1 2 3
답:
1 2 0
수의 중복이 있을 수 있으므로 주의하자. 코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;int N, a[52], b[52], d[52], c;int main(void) {cin &amp;gt;&amp;gt; N;for (int i = 0; i &amp;lt; N; i++) {cin &amp;gt;&amp;gt; a[i];b[i] = a[i];}sort(a, a + N);for (int i = 0; i &amp;lt; N; i++) {c = lower_bound(a, a + N, b[i]) - a;while (d[c])	c++;cout &amp;lt;&amp;lt; c &amp;lt;&amp;lt; &amp;#34;&amp;#34;;d[c] = 1;}cout &amp;lt;&amp;lt; endl;}</description>
    </item>
    
    <item>
      <title>[백준]1024 수열의 합</title>
      <link>https://jyukki97.github.io/blog/2020-03-06-1024/</link>
      <pubDate>Fri, 06 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-03-06-1024/</guid>
      <description>https://www.acmicpc.net/problem/1024
풀이: 길이가 적어도 L인 수열은 다음과 같이 나타낼 수 있다.
n	n + 1	n + 2	...	n + L - 2	n + L - 1즉, 길이가 L인 수열들의 합은
L * n + Σ k (k = 1 ~ L - 1) = N
( N - Σ k (k = 1 ~ L - 1) ) % L == 0
인 L을 찾는다면, 답을 구할 수 있다.</description>
    </item>
    
    <item>
      <title>[백준]1051 숫자 정사각형</title>
      <link>https://jyukki97.github.io/blog/2020-03-06-1051/</link>
      <pubDate>Fri, 06 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-03-06-1051/</guid>
      <description>https://www.acmicpc.net/problem/1051
풀이: N, M 중 더 작은 값이 정사각형의 한 변의 길이의 최댓값이 된다.
최댓값을 1씩 줄여 가면서, 만들 수 있는 정사각형이 있는지 확인한다.
만들 수 있다면, 반복을 중지하고, 변을 제곱한 넓이를 출력한다.
코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std;int N, M, b, c = 1;int main(void) {cin &amp;gt;&amp;gt; N &amp;gt;&amp;gt; M;vector&amp;lt;string&amp;gt; a(N);for (int i = 0; i &amp;lt; N; i++)cin &amp;gt;&amp;gt; a[i];b = N &amp;gt; M ?</description>
    </item>
    
    <item>
      <title>[백준]1062 가르침</title>
      <link>https://jyukki97.github.io/blog/2020-03-06-1062/</link>
      <pubDate>Fri, 06 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-03-06-1062/</guid>
      <description>https://www.acmicpc.net/problem/1062
풀이: a ~ z 중에 K개의 글자를 배웠을 떄,
N개의 단어 중 몇개의 단어를 읽을 수 있는지 구한 후 그것들 중 최댓값을 출력한다.
a, c, i, n, t 다섯개의 글자는 무조건 들어가므로 넣고 시작하자. 코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;int N, K, b, c = 0, d, f;vector&amp;lt;string&amp;gt; a;void T(int x, int y) {if (y == K) {d = 0;for (int i = 0; i &amp;lt; N; i++) {f = 1;for (char s : a[i])	if (!</description>
    </item>
    
    <item>
      <title>[백준]1080 행렬</title>
      <link>https://jyukki97.github.io/blog/2020-03-06-1080/</link>
      <pubDate>Fri, 06 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-03-06-1080/</guid>
      <description>https://www.acmicpc.net/problem/1080
풀이: (0, 0) 부터 하나씩 비교해 나간다.
만약 A 와 B 의 숫자가 다르다면, 현재 위치부터 3 * 3 전체를 반전시킨다.
반전 시켰다면, 뒤집은 횟수를 +1 해준다.
순환이 끝난 후 행렬 A 와 B 가 다르다면 -1을 같다면 뒤집은 횟수를 출력해준다.
코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std;int N, M, c = 0, i, t, u, y;int main() {cin &amp;gt;&amp;gt; N &amp;gt;&amp;gt; M;vector&amp;lt;string&amp;gt; a(N), b(N);for (i = 0; i &amp;lt; N; i++)cin &amp;gt;&amp;gt; a[i];for (i = 0; i &amp;lt; N; i++)cin &amp;gt;&amp;gt; b[i];for (i = 0; i &amp;lt; N - 2; i++)for (t = 0; t &amp;lt; M - 2; t++)if (a[i][t] !</description>
    </item>
    
    <item>
      <title>[백준]1005 ACM Craft</title>
      <link>https://jyukki97.github.io/blog/2020-03-05-1005/</link>
      <pubDate>Thu, 05 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-03-05-1005/</guid>
      <description>https://www.acmicpc.net/problem/1005
풀이: b[i] : i 건물을 짓는데 드는 최소시간
b[i] = max(b[i 건물을 짓는데 필요한 건물들])
-&amp;gt; 바로 전 단계의 건물 중 건설시간이 오래 걸리는 것을 짓는다면, 그 시간동안 다른 건물은 다 지을 수 있기 떄문에, max값만 생각한다.
코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;int T, N, K, q, e, w, a[1002], m, n, b[1002];vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; v;int A(int x) {if (b[x] !</description>
    </item>
    
    <item>
      <title>[백준]1049 기타줄</title>
      <link>https://jyukki97.github.io/blog/2020-03-05-1049/</link>
      <pubDate>Thu, 05 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-03-05-1049/</guid>
      <description>https://www.acmicpc.net/problem/1049
풀이: 여러 브랜드 중 6줄 패키지 가격의 최솟값과 낱개 가격의 최솟값을 저장해 놓는다.
낱개 * 6 보다 패키지 가격이 더 높다면, 패키지로 살 이유가 없으므로 낱개 가격을 출력한다.
필요한 줄의 갯수가 6개 이하라면, 낱개 가격과 패키지 가격 중 낮은 가격을 출력한다.
둘 다 아니라면, (전체를 패키지로 사는 것) 과 (6개로 나눠지는 만큼 패키지로 사고 나머지는 낱개로 사는 것) 둘 중 낮은 가격을 출력한다.
코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;int N, M, q, w, a = 1001, b = 1001, dp[102] = { 0 };int main(void) {cin &amp;gt;&amp;gt; N &amp;gt;&amp;gt; M;for (int i = 0; i &amp;lt; M; i++) {cin &amp;gt;&amp;gt; q &amp;gt;&amp;gt; w;a = min(a, q);b = min(b, w);}for (int i = 1; i &amp;lt;= N; i++) {dp[i] = (((i - 1) / 6) + 1) * a;dp[i] = min(dp[i], dp[i - 1] + b);}cout &amp;lt;&amp;lt; dp[N] &amp;lt;&amp;lt; endl;}코드: 사용언어 : c++</description>
    </item>
    
    <item>
      <title>[백준]1068 트리</title>
      <link>https://jyukki97.github.io/blog/2020-03-05-1068/</link>
      <pubDate>Thu, 05 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-03-05-1068/</guid>
      <description>https://www.acmicpc.net/problem/1068
풀이: v[i] : i의 자식 노드들이 들어있다.
삭제 해야하는 노드가 w 라면,
w를 큐에 푸쉬한다.
w의 자식노드를 큐에 푸쉬한 후 w를 삭제한다.
자식노드가 없어질 때까지 반복한다.
v[ 0 ~ N - 1 ] 까지 모두 순환한다.
노드가 현제 존재하며, 자식노드가 없다면, 리프 노드이므로 +1 해준다.
코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;queue&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std;int N, a;bool b[52], c;int main(void) {cin &amp;gt;&amp;gt; N;vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; v(N);queue&amp;lt;int&amp;gt; q;for (int i = 0; i &amp;lt; N; i++) {cin &amp;gt;&amp;gt; a;if(a !</description>
    </item>
    
    <item>
      <title>[백준]1057 토너먼트</title>
      <link>https://jyukki97.github.io/blog/2020-03-04-1057/</link>
      <pubDate>Wed, 04 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-03-04-1057/</guid>
      <description>https://www.acmicpc.net/problem/1057
풀이: ​	1	2
​	1	2	3	4
1	2	3	4	5	6	7	8
현재 번호가 i 라고 할 때,
위로 갈 수록 배정받는 번호는 (i + 1) / 2 가 된다.
즉, 김지민과 임한수의 번호가 x, y 라고 할 때,
( x + 1 ) / 2 == ( y + 1 ) / 2
가 되는 순간이 둘이 대결하는 순간이다.
토너먼트가 끝날 때까지 둘이 대결하지 않는 경우는 없으므로 -1 출력은 하지않는다.</description>
    </item>
    
    <item>
      <title>[백준]1074 집합</title>
      <link>https://jyukki97.github.io/blog/2020-03-04-1074/</link>
      <pubDate>Wed, 04 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-03-04-1074/</guid>
      <description>https://www.acmicpc.net/problem/1074
풀이: 배열의 크기를 점차 줄여가면서,
위에 방문할 수 있는 배열의 크기를 계산하여, 더해가면서 구한다.
ex)
3 7 7
8 * 8 배열에서
왼쪽위, 오른쪽 위, 왼쪽 아래 4 * 4 배열은 필요없으니까 48 만큼 뺀 후,
오른쪽 아래 배열로만 4 * 4 배열로 줄여서 다시 만든다.
그렇다면, ( 7, 7 ) 은 ( 3, 3 )이 되어야 하므로 (7 % 4, 7 % 4) 가 된다.
배열의 크기가 0이 될때까지 반복한다.</description>
    </item>
    
    <item>
      <title>[백준]11723 집합</title>
      <link>https://jyukki97.github.io/blog/2020-03-04-11723/</link>
      <pubDate>Wed, 04 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-03-04-11723/</guid>
      <description>https://www.acmicpc.net/problem/11723
풀이: [C++]비트연산자 참고
add : or 연산을 통해 값을 추가한다.
remove : 값이 있는지 확인 후 있다면, xor 연산으로 삭제한다.
check : 값이 있는지 and 연산으로 확인 후 있다면 1, 없다면 0을 출력한다.
toggle : 값이 있다면 삭제하고, 없다면 추가한다.
all : 비트값을 (2^20) - 1 로 바꿔주어, 1 ~ 20 까지 채워놓는다.
empty : 비트값을 0으로 바꿔주어, 공집합으로 만들어놓는다.
시간제한이있으므로 비트마스크를 통해 연산하도록한다. cin, cout 을 사용할 경우 시간초과가 나므로 주의하자.</description>
    </item>
    
    <item>
      <title>[프로그래머스]예상 대진표</title>
      <link>https://jyukki97.github.io/blog/2020-03-04-listofmatches/</link>
      <pubDate>Wed, 04 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-03-04-listofmatches/</guid>
      <description>https://programmers.co.kr
문제: △△ 게임대회가 개최되었습니다. 이 대회는 N명이 참가하고, 토너먼트 형식으로 진행됩니다. N명의 참가자는 각각 1부터 N번을 차례대로 배정받습니다. 그리고, 1번↔2번, 3번↔4번, &amp;hellip; , N-1번↔N번의 참가자끼리 게임을 진행합니다. 각 게임에서 이긴 사람은 다음 라운드에 진출할 수 있습니다. 이때, 다음 라운드에 진출할 참가자의 번호는 다시 1번부터 N/2번을 차례대로 배정받습니다. 만약 1번↔2번 끼리 겨루는 게임에서 2번이 승리했다면 다음 라운드에서 1번을 부여받고, 3번↔4번에서 겨루는 게임에서 3번이 승리했다면 다음 라운드에서 2번을 부여받게 됩니다. 게임은 최종 한 명이 남을 때까지 진행됩니다.</description>
    </item>
    
    <item>
      <title>[백준]11404 웜홀</title>
      <link>https://jyukki97.github.io/blog/2020-03-03-11404/</link>
      <pubDate>Tue, 03 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-03-03-11404/</guid>
      <description>https://www.acmicpc.net/problem/11404
풀이: [C++]플로이드-와샬 알고리즘(Bellman-Ford Algorithm) 참고
코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;int	n, m, i, a1, a2, a3, a[102][102];int main() {cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;fill(a[0], a[0] + 10404, 987654321);for (i = 0; i &amp;lt; m; i++) {cin &amp;gt;&amp;gt; a1 &amp;gt;&amp;gt; a2 &amp;gt;&amp;gt; a3;a[a1][a2] = min(a[a1][a2], a3);}for (i = 1; i &amp;lt;= n; i++) for (int t = 1; t &amp;lt;= n; t++)for (int y = 1; y &amp;lt;= n; y++)if (t == y) a[t][y] = 0;else	a[t][y] = min(a[t][y], a[t][i] + a[i][y]);for (i = 1; i &amp;lt;= n; i++) {for (int t = 1; t &amp;lt;= n; t++)if (a[i][t] == 987654321)	cout &amp;lt;&amp;lt; &amp;#34;0 &amp;#34;;else	cout &amp;lt;&amp;lt; a[i][t] &amp;lt;&amp;lt; &amp;#34;&amp;#34;;cout &amp;lt;&amp;lt; endl;}}</description>
    </item>
    
    <item>
      <title>[백준]1865 웜홀</title>
      <link>https://jyukki97.github.io/blog/2020-03-03-1865/</link>
      <pubDate>Tue, 03 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-03-03-1865/</guid>
      <description>https://www.acmicpc.net/problem/1865
풀이: [C++]벨만-포드 알고리즘(Bellman-Ford Algorithm) 참고
벨만-포드 알고리즘으로 모든 정점을 순환 한 뒤, 음수 사이클이 있는지 판단 후 있다면, &amp;ldquo;YES&amp;rdquo; 를 없다면 &amp;ldquo;NO&amp;quot;를 출력한다. 코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std;int	T, n, m, k, i, d[502], a1, a2, a3;int main() {cin &amp;gt;&amp;gt; T;while (T--) {bool b = true;cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m &amp;gt;&amp;gt; k;vector&amp;lt;pair&amp;lt;pair&amp;lt;int, int&amp;gt;, int&amp;gt;&amp;gt; a;for (i = 0; i &amp;lt; m; i++) {cin &amp;gt;&amp;gt; a1 &amp;gt;&amp;gt; a2 &amp;gt;&amp;gt; a3;a.</description>
    </item>
    
    <item>
      <title>[백준]11657 타임머신</title>
      <link>https://jyukki97.github.io/blog/2020-03-02-11657/</link>
      <pubDate>Mon, 02 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-03-02-11657/</guid>
      <description>https://www.acmicpc.net/problem/11657
풀이: [C++]벨만-포드 알고리즘(Bellman-Ford Algorithm) 참고
코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;using namespace std;#define INF 987654321int	n, m, i, d[502], a1, a2, a3;pair&amp;lt;pair&amp;lt;int, int&amp;gt;, int&amp;gt; a[6002];int main() {cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;for (i = 0; i &amp;lt; m; i++)cin &amp;gt;&amp;gt; a[i].first.first &amp;gt;&amp;gt; a[i].first.second &amp;gt;&amp;gt; a[i].second;fill(d, d + n + 1, INF);d[1] = 0;for (i = 1; i &amp;lt;= n; i++)for (auto t : a)if (d[t.</description>
    </item>
    
    <item>
      <title>[백준]9370 미확인 도착지</title>
      <link>https://jyukki97.github.io/blog/2020-03-02-9370/</link>
      <pubDate>Mon, 02 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-03-02-9370/</guid>
      <description>https://www.acmicpc.net/problem/9370
풀이: [C++]다익스트라 알고리즘(Dijkstra Algorithm) 참고
s -&amp;gt; g -&amp;gt; h -&amp;gt; x
s -&amp;gt; h -&amp;gt; g -&amp;gt; x
두 가지 경로가 있는데, 둘 중 하나라도 최단 경로일 경우 x를 배열에 저장한다.
저장된 x를 오름차순으로 출력한다.
코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;queue&amp;gt;using namespace std;int T, n, m, t, u, v, w, i, s, g, h, v1, v2, a1, c, d[2002];bool b[2002];priority_queue&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; p;priority_queue&amp;lt;int, vector&amp;lt;int&amp;gt;, greater&amp;lt;int&amp;gt;&amp;gt; q;int main() {cin &amp;gt;&amp;gt; T;while (T--) {cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m &amp;gt;&amp;gt; t;vector&amp;lt;vector&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt;&amp;gt; a(n + 1);cin &amp;gt;&amp;gt; s &amp;gt;&amp;gt; g &amp;gt;&amp;gt; h;for (i = 0; i &amp;lt; m; i++) {cin &amp;gt;&amp;gt; u &amp;gt;&amp;gt; v &amp;gt;&amp;gt; w;a[u].</description>
    </item>
    
    <item>
      <title>[백준]1504 최단 경로</title>
      <link>https://jyukki97.github.io/blog/2020-03-01-1504/</link>
      <pubDate>Sun, 01 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-03-01-1504/</guid>
      <description>https://www.acmicpc.net/problem/1504
풀이: [C++]다익스트라 알고리즘(Dijkstra Algorithm) 참고
지나야 하는 두 개의 정점을 v1, v2 라고 할때,
1 ~ v1 ~ v2 ~ N
1 ~ v2 ~ v1 ~ N
으로 나눠서 풀어본다.
1~v1, v2 과 v1 ~ v2 과 v1, v2 ~ N 을 다익스트라 알고리즘으로 각각 구하여 더한값이
최소인 값을 구한다. 만약 경로가 없다면 -1을 출력한다.
코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;queue&amp;gt;using namespace std;int V, E, u, v, w, i, d[805], v1, v2, a1, a2;priority_queue&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; p;bool b[805];int main() {cin &amp;gt;&amp;gt; V &amp;gt;&amp;gt; E;vector&amp;lt;vector&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt;&amp;gt;a(V + 1);for (i = 0; i &amp;lt; E; i++) {cin &amp;gt;&amp;gt; u &amp;gt;&amp;gt; v &amp;gt;&amp;gt; w;a[u].</description>
    </item>
    
    <item>
      <title>[백준]1753 최단 경로</title>
      <link>https://jyukki97.github.io/blog/2020-03-01-1753/</link>
      <pubDate>Sun, 01 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-03-01-1753/</guid>
      <description>https://www.acmicpc.net/problem/1753
풀이: [C++]다익스트라 알고리즘(Dijkstra Algorithm) 참고
코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;queue&amp;gt;using namespace std;int V, E, k, u, v, w, i;vector&amp;lt;int&amp;gt; d;priority_queue&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; p;bool b[20002];int main() {cin &amp;gt;&amp;gt; V &amp;gt;&amp;gt; E &amp;gt;&amp;gt; k;vector&amp;lt;vector&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt;&amp;gt;a(V + 1);for (i = 0; i &amp;lt;= V; i++)d.push_back(987654321);for (i = 0; i &amp;lt; E; i++) {cin &amp;gt;&amp;gt; u &amp;gt;&amp;gt; v &amp;gt;&amp;gt; w;a[u].</description>
    </item>
    
    <item>
      <title>[프로그래머스]가장 먼 노드</title>
      <link>https://jyukki97.github.io/blog/2020-03-01-furthestnode/</link>
      <pubDate>Sun, 01 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-03-01-furthestnode/</guid>
      <description>https://programmers.co.kr
문제: n개의 노드가 있는 그래프가 있습니다. 각 노드는 1부터 n까지 번호가 적혀있습니다. 1번 노드에서 가장 멀리 떨어진 노드의 갯수를 구하려고 합니다. 가장 멀리 떨어진 노드란 최단경로로 이동했을 때 간선의 개수가 가장 많은 노드들을 의미합니다.
노드의 개수 n, 간선에 대한 정보가 담긴 2차원 배열 vertex가 매개변수로 주어질 때, 1번 노드로부터 가장 멀리 떨어진 노드가 몇 개인지를 return 하도록 solution 함수를 작성해주세요.
풀이: 현재 위치를 i 라고 하자.
이때까지 방문을 한적이 없고, i와의 거리가 1차이나는 노드를 배열에 저장한 후 visit을 true로 바꿔준다.</description>
    </item>
    
    <item>
      <title>[백준]1697 숨바꼭질</title>
      <link>https://jyukki97.github.io/blog/2020-02-29-1697/</link>
      <pubDate>Sat, 29 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-02-29-1697/</guid>
      <description>https://www.acmicpc.net/problem/1697
풀이: 현재 위치를 x라고 할 때, x + 1, x - 1, x * 2 위치를 BFS 를 통해 하나씩 찾아간다.
동생의 위치와 같아진다면 몇번 이동했는지 출력한다.
x + 1 은 동생의 위치보다 커질 필요가없으므로 동생의 위치보다 작을때만 이동한다. x * 2 는 동생의 위치 + 1 보다 크다면 (x - 2) * 2 를 하는 것이 이득이므로 제외한다. 현재 위치는 0보다 작아질 수 없으므로 제외한다. 이미 한번 방문한 위치는 다시 방문할 필요없으므로 제외시킨다.</description>
    </item>
    
    <item>
      <title>[백준]2206 벽 부수고 이동하기</title>
      <link>https://jyukki97.github.io/blog/2020-02-29-2206/</link>
      <pubDate>Sat, 29 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-02-29-2206/</guid>
      <description>https://www.acmicpc.net/problem/2206
풀이: [백준]2178 미로 탐색 참고
코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;queue&amp;gt;using namespace std;int n, m, k = -1, q, w, e, dps;vector&amp;lt;string&amp;gt; a;queue&amp;lt;pair&amp;lt;int, pair&amp;lt;int, int&amp;gt;&amp;gt;&amp;gt; dp;bool b[2][1002][1002];int main() {cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;a.resize(n);for (int i = 0; i &amp;lt; n; i++)cin &amp;gt;&amp;gt; a[i];dp.push({ 1, { 0,0 } });for (int i = 1; i &amp;lt; n * m + 1; i++) {dps = dp.</description>
    </item>
    
    <item>
      <title>[백준]7569 토마토</title>
      <link>https://jyukki97.github.io/blog/2020-02-29-7569/</link>
      <pubDate>Sat, 29 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-02-29-7569/</guid>
      <description>https://www.acmicpc.net/problem/7569
풀이: [백준]7576 토마토 참고
코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;queue&amp;gt;using namespace std;int n, m, h, k, q, w, e, a[102][102][102];queue&amp;lt;pair&amp;lt;int, pair&amp;lt;int, int&amp;gt;&amp;gt;&amp;gt; dp2;int main() {cin &amp;gt;&amp;gt; m &amp;gt;&amp;gt; n &amp;gt;&amp;gt; h;for (int y = 0; y &amp;lt; h; y++)for (int i = 0; i &amp;lt; n; i++)for (int t = 0; t &amp;lt; m; t++) {cin &amp;gt;&amp;gt; a[y][i][t];if (a[y][i][t] == 1)	dp2.</description>
    </item>
    
    <item>
      <title>[백준]1012 유기농 배추</title>
      <link>https://jyukki97.github.io/blog/2020-02-28-1012/</link>
      <pubDate>Fri, 28 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-02-28-1012/</guid>
      <description>https://www.acmicpc.net/problem/1012
풀이: [백준]2667 단지번호붙이기 참고
코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;string.h&amp;gt;using namespace std;int n, T, m, k, q, w, sum, a[52][52];bool b[52][52];void num(int x, int y) {b[x][y] = true;if (x + 1 &amp;lt; n &amp;amp;&amp;amp; a[x + 1][y] &amp;amp;&amp;amp; !b[x + 1][y])num(x + 1, y);if (y + 1 &amp;lt; m &amp;amp;&amp;amp; a[x][y + 1] &amp;amp;&amp;amp; !b[x][y + 1])num(x, y + 1);if (x - 1 &amp;gt;= 0 &amp;amp;&amp;amp; a[x - 1][y] &amp;amp;&amp;amp; !</description>
    </item>
    
    <item>
      <title>[백준]2178 미로 탐색</title>
      <link>https://jyukki97.github.io/blog/2020-02-28-2178/</link>
      <pubDate>Fri, 28 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-02-28-2178/</guid>
      <description>https://www.acmicpc.net/problem/2178
풀이: 이동횟수가 i 일때,
이동횟수가 i - 1 인 값들에서 왼쪽, 오른쪽, 위, 아래 중 값이 1이고, 방문한적 없는 곳을 찾아 좌표를 큐에 넣는다.
만약 현재 좌표가 도착위치라면, 이동횟수 i를 출력한다.
코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;queue&amp;gt;using namespace std;int n, m, k, q, w;vector&amp;lt;string&amp;gt; a;queue&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; dp2;bool b[102][102];int main() {cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;a.resize(n);for (int i = 0; i &amp;lt; n; i++)cin &amp;gt;&amp;gt; a[i];dp2.</description>
    </item>
    
    <item>
      <title>[백준]7576 토마토</title>
      <link>https://jyukki97.github.io/blog/2020-02-28-7576/</link>
      <pubDate>Fri, 28 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-02-28-7576/</guid>
      <description>https://www.acmicpc.net/problem/7576
풀이: [백준]2178 미로 탐색 참고
코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;queue&amp;gt;using namespace std;int n, m, k, q, w, a[1002][1002];queue&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; dp2;int main() {cin &amp;gt;&amp;gt; m &amp;gt;&amp;gt; n;for (int i = 0; i &amp;lt; n; i++)for (int t = 0; t &amp;lt; m; t++) {cin &amp;gt;&amp;gt; a[i][t];if (a[i][t] == 1)	dp2.push({ i,t });}for (int i = 0;; i++) {queue&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; dp1;while (!</description>
    </item>
    
    <item>
      <title>[백준]10942 팰린드롬?</title>
      <link>https://jyukki97.github.io/blog/2020-02-27-10942/</link>
      <pubDate>Thu, 27 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-02-27-10942/</guid>
      <description>https://www.acmicpc.net/problem/10942
풀이: DP[i][t] : i 번쨰 수 부터 t 번째 까지 수가 팰린드롬을 이룬다면 1, 아니라면 0
a[i] == a[t] 라면,
DP[i][t] = DP[i + 1][t - 1]
a[i] != a[t] 라면,
DP[i][t] = 0
테스트 케이스가 많아 시간초과가 날 수 있으므로 메모이제이션을 하자! 코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;string.h&amp;gt;using namespace std;int m, n, q, w, a[2002], dp[2002][2002];int p(int x, int y) {if (dp[x][y] !</description>
    </item>
    
    <item>
      <title>[백준]1260 DFS와 BFS</title>
      <link>https://jyukki97.github.io/blog/2020-02-27-1260/</link>
      <pubDate>Thu, 27 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-02-27-1260/</guid>
      <description>https://www.acmicpc.net/problem/1260
풀이: DFS 와 BFS를 출력한다.
코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;queue&amp;gt;#include &amp;lt;string.h&amp;gt;using namespace std;int n, m, v, q, w, a[1002][1002] = {};bool b[1002];void dfs(int x) {b[x] = true;cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &amp;#34;&amp;#34;;for (int i = 1; i &amp;lt;= n; i++)if (a[x][i] &amp;amp;&amp;amp; !b[i])	dfs(i);}int main() {cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m &amp;gt;&amp;gt; v;for (int i = 0; i &amp;lt; m; i++) {cin &amp;gt;&amp;gt; q &amp;gt;&amp;gt; w;a[q][w] = 1;a[w][q] = 1;}dfs(v);cout &amp;lt;&amp;lt; endl;memset(b, 0, n + 1);queue&amp;lt;int&amp;gt; c;c.</description>
    </item>
    
    <item>
      <title>[백준]1520 내리막 길</title>
      <link>https://jyukki97.github.io/blog/2020-02-27-1520/</link>
      <pubDate>Thu, 27 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-02-27-1520/</guid>
      <description>https://www.acmicpc.net/problem/1520
풀이: DP[i][t] : (1,1) ~ (i, t) 까지 내리막으로 갈 수 있는 경우의 수
현재 값에서 왼쪽, 오른쪽, 위, 아래 값이 각각 현재 값보다 크다면,
DP[현재] += DP[왼쪽, 오른쪽, 위, 아래] 로 구할 수 있다.
시간초과가 날 수 있으므로 메모이제이션을 하자! 코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;string.h&amp;gt;using namespace std;int m, n, a[502][502], dp[502][502];int r(int x, int y) {if (dp[x][y] != -1)	return dp[x][y];dp[x][y] = 0;if (a[x][y] &amp;lt; a[x - 1][y])dp[x][y] += r(x - 1, y);if (a[x][y] &amp;lt; a[x + 1][y])dp[x][y] += r(x + 1, y);if (a[x][y] &amp;lt; a[x][y + 1])dp[x][y] += r(x, y + 1);if (a[x][y] &amp;lt; a[x][y - 1])dp[x][y] += r(x, y - 1);return dp[x][y];}int main() {cin &amp;gt;&amp;gt; m &amp;gt;&amp;gt; n;for (int i = 1; i &amp;lt;= m; i++)for (int t = 1; t &amp;lt;= n; t++)cin &amp;gt;&amp;gt; a[i][t];memset(dp, -1, sizeof(dp));dp[1][1] = 1;cout &amp;lt;&amp;lt; r(m, n) &amp;lt;&amp;lt; endl;}</description>
    </item>
    
    <item>
      <title>[백준]2618 경찰차</title>
      <link>https://jyukki97.github.io/blog/2020-02-27-2618/</link>
      <pubDate>Thu, 27 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-02-27-2618/</guid>
      <description>https://www.acmicpc.net/problem/2618
풀이: DP[i][t] : 첫번째 경찰차가 i 번째 사건을, 두번째 경찰차가 t 번째 사건을 처리했을 때, 이동하는 거리의 합의 최소값
i 와 t 의 차이가 1 이라면,
DP[i][t] = DP[i][0 ~ t - 1] (t 번째와 0 ~ t - 1 번째 사이의 거리)까지의 최소값
1이 아니라면,
DP[i][t] = DP[i][t - 1] + (t 번째와 t - 1 번째 사이의 거리)
을 통해 최솟값을 구할 수 있다.
최솟값을 구한 후, 최솟값을 구한 경로를 역순으로 추적하여, 맡겨진 경찰차의 번호를 구한다.</description>
    </item>
    
    <item>
      <title>[백준]2667 단지번호붙이기</title>
      <link>https://jyukki97.github.io/blog/2020-02-27-2667/</link>
      <pubDate>Thu, 27 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-02-27-2667/</guid>
      <description>https://www.acmicpc.net/problem/2667
풀이: 전체를 순회한다.
만약 집이있는 곳 ( 배열에 1인 곳 ) 을 찾았다면, 연결된 모든 단지를 찾아 단지 크기를 배열에 저장한다.
순회가 끝났다면, 배열의 사이즈 (총 단지수) 를 출력한다.
그 후 단지내 집의 수를 오름차순으로 정렬하여 출력하여야하므로
배열을 정렬한 후 배열의 원소를 출력한다.
코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;string&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;int n;bool b[26][26];vector&amp;lt;string&amp;gt; a;vector&amp;lt;int&amp;gt; c;void num(int x, int y) {b[x][y] = true;c.</description>
    </item>
    
    <item>
      <title>[백준]10816 숫자 카드2</title>
      <link>https://jyukki97.github.io/blog/2020-02-26-10816/</link>
      <pubDate>Wed, 26 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-02-26-10816/</guid>
      <description>https://www.acmicpc.net/problem/10816
풀이: 배열에 숫자 카드들을 넣는다.
배열을 정렬한다.
몇 개 가지고 있는지 구해야 할 카드를 k 라고 할 때,
k가 최초로 나오는 위치 = lower_bound,
k보다 큰 값이 최초로 나오는 위치 = upper_bound
로 구할 수 있다.
즉 upper_bound - lower_bound를 실행한다면 답을 구할 수 있다.
cout과 cin 을 쓰면 시간초과가 나므로 주의하자. 코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;int n, m, k, a[500001];int main() {scanf(&amp;#34;%d&amp;#34;, &amp;amp;n);for (int i = 0; i &amp;lt; n; i++)scanf(&amp;#34;%d&amp;#34;, &amp;amp;a[i]);sort(a, a + n);scanf(&amp;#34;%d&amp;#34;, &amp;amp;m);for (int i = 0; i &amp;lt; m; i++) {scanf(&amp;#34;%d&amp;#34;, &amp;amp;k);auto l = lower_bound(a, a + n, k);auto r = upper_bound(a, a + n, k);printf(&amp;#34;%d &amp;#34;, r - l);}printf(&amp;#34;\n&amp;#34;);return 0;}</description>
    </item>
    
    <item>
      <title>[백준]11049 행렬 곱셈 순서</title>
      <link>https://jyukki97.github.io/blog/2020-02-26-11049/</link>
      <pubDate>Wed, 26 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-02-26-11049/</guid>
      <description>https://www.acmicpc.net/problem/11049
풀이: DP[i][t] : i ~ t 까지의 행렬을 곱하는데 필요한 곱셈 연산 횟수의 최솟값
dp[x][y] = min(dp[x][y], f(x, i) + f(i + 1, y) + a[x] * b[i] * b[y])
x ~ i 까지의 행렬 곱셈 + (i + 1) ~ y 까지의 행렬 곱셈 + 그 둘의 곱셈
코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;long long n, a[502], b[502], dp[502][502] = {};long long f(int x, int y) {if (x == y || dp[x][y])	return dp[x][y];dp[x][y] = f(x, x) + f(x + 1, y) + a[x] * b[x] * b[y];for (int i = x + 1; i &amp;lt; y; i++)dp[x][y] = min(dp[x][y], f(x, i) + f(i + 1, y) + a[x] * b[i] * b[y]);return dp[x][y];}int main() {cin &amp;gt;&amp;gt; n;for (int i = 1; i &amp;lt;= n; i++)cin &amp;gt;&amp;gt; a[i] &amp;gt;&amp;gt; b[i];cout &amp;lt;&amp;lt; f(1, n) &amp;lt;&amp;lt; endl;}</description>
    </item>
    
    <item>
      <title>[백준]11066 파일 합치기</title>
      <link>https://jyukki97.github.io/blog/2020-02-26-11066/</link>
      <pubDate>Wed, 26 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-02-26-11066/</guid>
      <description>https://www.acmicpc.net/problem/11066
풀이: dp[i][t] = i 장 부터 t 장까지 수록한 파일을 합쳤을 때, 필요한 최소비용
sum[i] = 1 ~ i 까지의 파일 크기의 합
dp[i][t] = min(dp[i][t], dp[i][i] ~ dp[i][t - 1] + dp[i + 1][t] ~ dp[t][t]) 로 구할 수 있다.
겹치는 숫자들이 있으므로,
dp를 구할 때 마다, dp[i][t] += sum[t] - sum[i - 1] 을 해주어야 한다.
코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;int T, n, a[502], dp[502][502] = {}, sum[502];int f(int a, int b) {if (dp[a][b] !</description>
    </item>
    
    <item>
      <title>[백준]11286 절댓값 힘</title>
      <link>https://jyukki97.github.io/blog/2020-02-26-11286/</link>
      <pubDate>Wed, 26 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-02-26-11286/</guid>
      <description>https://www.acmicpc.net/problem/11286
풀이: 0이 나온다면, 배열에 있는 값중 절댓값이 가장 작은 값을 출력한다.(절댓값이 같다면, 가장 작은 값을 출력한다.) 그 값을 배열에서 제외시킨다.
만약 배열이 비어있다면, 0을 출력한다.
0이 아닌 다른 숫자가 나온다면, 그 값을 배열에 넣는다.
cout, cin 을 사용하면, 시간초과가 나므로 주의하자. 코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;queue&amp;gt;using namespace std;int n, i, m;bool com(int a, int b) {if (abs(a) == abs(b))return a &amp;gt; b;return abs(a) &amp;gt; abs(b);}int main() {priority_queue&amp;lt;int, vector&amp;lt;int&amp;gt;, decltype(&amp;amp;com)&amp;gt; a(&amp;amp;com);scanf(&amp;#34;%d&amp;#34;, &amp;amp;n);for (i = 0; i &amp;lt; n; i++) {scanf(&amp;#34;%d&amp;#34;, &amp;amp;m);if (!</description>
    </item>
    
    <item>
      <title>[백준]1654 랜선 자르기</title>
      <link>https://jyukki97.github.io/blog/2020-02-26-1654/</link>
      <pubDate>Wed, 26 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-02-26-1654/</guid>
      <description>https://www.acmicpc.net/problem/1654
풀이: 배열을 받아온다.
배열의 들어있는 랜선의 길이 중 최댓값이
만들 수 있는 최대 길이의 랜선이므로 최댓값을 설정한다.
최솟값은 1로 설정한다.
최댓값과 최솟값의 중간값을 m이라고 하자.
모든 배열의 원소를 m으로 나눈 몫을 모두 더한다.
더한 값이 필요한 랜선의 갯수보다 작다면, m값이 너무 크다는 것이므로 최댓값을 m - 1 로 바꿔준다.
더한 값이 필요한 랜선의 갯수보다 크거나 같다면, 만들 수 있다는 것이므로 답에 저장해 놓는다.
이때, 랜선의 최대 길이를 찾아야 하므로, 랜선의 갯수와 같다고 바로 끝내지 말고 위로 가면서 최댓값을 찾아야한다.</description>
    </item>
    
    <item>
      <title>[백준]1655 가운데를 말해요</title>
      <link>https://jyukki97.github.io/blog/2020-02-26-1655/</link>
      <pubDate>Wed, 26 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-02-26-1655/</guid>
      <description>https://www.acmicpc.net/problem/1655
풀이: 하나씩 숫자를 받아온다.
첫번째 숫자를 mid 라고 할 때,
현재 숫자가 mid보다 크거나 같다면, 배열 r 에 작다면, 배열 l 에 저장한다.
mid를 배열 r 에 넣고, 배열 l 의 값 중 가장 큰 값으로 바꾼다.
만약, 배열 r과 l의 사이즈 차이가 2이상 난다면, mid값을 조정해준다.
cout, cin 을 사용하면, 시간초과가 나므로 주의하자. 코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;queue&amp;gt;using namespace std;int n, m, mid;int main() {priority_queue&amp;lt;int, vector&amp;lt;int&amp;gt;, greater&amp;lt;int&amp;gt;&amp;gt; r;priority_queue&amp;lt;int&amp;gt; l;scanf(&amp;#34;%d %d&amp;#34;, &amp;amp;n, &amp;amp;mid);printf(&amp;#34;%d\n&amp;#34;, mid);while (--n) {scanf(&amp;#34;%d&amp;#34;, &amp;amp;m);m &amp;lt; mid ?</description>
    </item>
    
    <item>
      <title>[백준]2110 공유기 설치</title>
      <link>https://jyukki97.github.io/blog/2020-02-26-2110/</link>
      <pubDate>Wed, 26 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-02-26-2110/</guid>
      <description>https://www.acmicpc.net/problem/2110
풀이: [백준]1654 랜선 자르기 참고
최대 거리를 설정하고,
그 거리를 기준으로 공유기를 설치할 수 있는지 확인하고,
이분탐색으로 최대 거리를 조절해 나간다.
코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;long long n, k, i, a[200001], sum, m, l = 1, r, c = 0, d;int main() {cin &amp;gt;&amp;gt; k &amp;gt;&amp;gt; n;for (i = 0; i &amp;lt; k; i++)cin &amp;gt;&amp;gt; a[i];sort(a, a + k);r = a[k - 1];while (l &amp;lt;= r) {sum = 1;m = (r + l) / 2;d = a[0];for (i = 1; i &amp;lt; k; i++)if (d + m &amp;lt;= a[i]) {d = a[i];sum++;}if (sum &amp;lt; n)	r = m - 1;else {c = max(c, m);l = m + 1;}}cout &amp;lt;&amp;lt; c &amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
    <item>
      <title>[백준]2805 나무 자르기</title>
      <link>https://jyukki97.github.io/blog/2020-02-26-2805/</link>
      <pubDate>Wed, 26 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-02-26-2805/</guid>
      <description>https://www.acmicpc.net/problem/2805
풀이: [백준]1654 랜선 자르기 참고
m값이 배열의 값보다 작은데 a[i] - m을 할 경우 -값이 나오므로 주의하자. 코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;long long n, k, i, a[1000001], sum, m, l = 1, r = 0, c = 0;int main() {cin &amp;gt;&amp;gt; k &amp;gt;&amp;gt; n;for (i = 0; i &amp;lt; k; i++) {cin &amp;gt;&amp;gt; a[i];r = max(r, a[i]);}while (l &amp;lt;= r) {sum = 0;m = (r + l) / 2;for (i = 0; i &amp;lt; k; i++)sum += a[i] &amp;lt; m ?</description>
    </item>
    
    <item>
      <title>[백준]k번째 수</title>
      <link>https://jyukki97.github.io/blog/2020-02-26-1300/</link>
      <pubDate>Wed, 26 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-02-26-1300/</guid>
      <description>https://www.acmicpc.net/problem/1300
풀이: [백준]1654 랜선 자르기 참고
현재 숫자의 순서가 k를 넘어간다면,
오른쪽 탐색을, 아니라면 왼쪽으로 탐색한다.
int형 사이즈를 넘어가니 long long으로 바꿔주자. 코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;long long n, k, i, sum, m, l = 1, r, c;int main() {cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; k;r = n * n;c = r;while (l &amp;lt;= r) {sum = 0;m = (r + l) / 2;for (i = 1; i &amp;lt;= n; i++)sum += min(n, m / i);if (sum &amp;lt; k)	l = m + 1;else {c = min(c, m);r = m - 1;}}cout &amp;lt;&amp;lt; c &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;}</description>
    </item>
    
    <item>
      <title>[프로그래머스]최적의 행렬 곱셈</title>
      <link>https://jyukki97.github.io/blog/2020-02-26-matrix/</link>
      <pubDate>Wed, 26 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-02-26-matrix/</guid>
      <description>https://programmers.co.kr
문제: 크기가 a by b인 행렬과 크기가 b by c 인 행렬이 있을 때, 두 행렬을 곱하기 위해서는 총 a x b x c 번 곱셈해야합니다. 예를 들어서 크기가 5 by 3인 행렬과 크기가 3 by 2인 행렬을 곱할때는 총 5 x 3 x 2 = 30번의 곱하기 연산을 해야 합니다.
행렬이 2개일 때는 연산 횟수가 일정 하지만, 행렬의 개수가 3개 이상일 때는 연산의 순서에 따라서 곱하기 연산의 횟수가 바뀔 수 있습니다.</description>
    </item>
    
    <item>
      <title>[백준]1780 종이의 개수</title>
      <link>https://jyukki97.github.io/blog/2020-02-25-1780/</link>
      <pubDate>Tue, 25 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-02-25-1780/</guid>
      <description>https://www.acmicpc.net/problem/1780
풀이: [백준]2630 색종이 만들기 참고
코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;using namespace std;int n, c[2200][2200], W = 0, B = 0, D = 0;void se(int x, int y, int a) {bool w = true, b = true, d = true;for (int i = 0; i &amp;lt; a; i++)for (int t = 0; t &amp;lt; a; t++)if (!w &amp;amp;&amp;amp; !b &amp;amp;&amp;amp; !d) break;else if (c[x + i][y + t] == -1) {w = false;b = false;}else if (c[x + i][y + t]) {w = false;d = false;}else {d = false;b = false;}W += 1 &amp;amp; w;B += 1 &amp;amp; b;D += 1 &amp;amp; d;if (!</description>
    </item>
    
    <item>
      <title>[백준]1992 쿼드트리</title>
      <link>https://jyukki97.github.io/blog/2020-02-25-1992/</link>
      <pubDate>Tue, 25 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-02-25-1992/</guid>
      <description>https://www.acmicpc.net/problem/1992
풀이: [백준]2630 색종이 만들기 참고
코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;string&amp;gt;using namespace std;int n;string s, c[65];void se(int x, int y, int a) {if (x &amp;gt;= n || y &amp;gt;= n || !a)	return;bool w = true, b = true;for (int i = 0; i &amp;lt; a; i++)for (int t = 0; t &amp;lt; a; t++)if (!w &amp;amp;&amp;amp; !b) break;else if (c[x + i][y + t] == &amp;#39;1&amp;#39;)	w = false;else b = false;if (w)	s += &amp;#39;0&amp;#39;;else if (b) s += &amp;#39;1&amp;#39;;else{s += &amp;#39;(&amp;#39;;a /= 2;se(x, y, a);se(x, y + a, a);se(x + a, y, a);se(x + a, y + a, a);s += &amp;#39;)&amp;#39;;}}int main() {cin &amp;gt;&amp;gt; n;for (int i = 0; i &amp;lt; n; i++)cin &amp;gt;&amp;gt; c[i];se(0, 0, n);cout &amp;lt;&amp;lt; s &amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
    <item>
      <title>[백준]2630 색종이 만들기</title>
      <link>https://jyukki97.github.io/blog/2020-02-25-2630/</link>
      <pubDate>Tue, 25 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-02-25-2630/</guid>
      <description>https://www.acmicpc.net/problem/2630
풀이: n을 2로 나누어 가며 1로 이루어진 곳인지 0으로 이루어진 곳인지 판단한다.
0으로 이루어져있다면 W를 +1 , 1로 이루어져있다면 B를 +1 해준다.
하얀색 색종이와 파란색 색종이의 갯수를 출력한다.
코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;using namespace std;int n, c[129][129], W = 0, B = 0;void se(int x, int y, int a) {if (x &amp;gt;= n || y &amp;gt;= n || !a)	return;bool w = true, b = true;for (int i = 0; i &amp;lt; a; i++)for (int t = 0; t &amp;lt; a; t++)if (!</description>
    </item>
    
    <item>
      <title>[백준]6549 히스토그램에서 가장 큰 직사각형</title>
      <link>https://jyukki97.github.io/blog/2020-02-25-6549/</link>
      <pubDate>Tue, 25 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-02-25-6549/</guid>
      <description>https://www.acmicpc.net/problem/6549
풀이: 값을 하나씩 받아온다.
현재 값보다 스택에 있는 값이 더 크다면,
max(현재 max값, 스택의 탑값 * (스택의 탑 바로 전 값의 위치와 현재 위치의 차이)) 을 수행하고, 현재 탑에 있는 값을 pop한다.
스택에 모든 값이 현재 있는 값보다 작거나 같다면, 스택에 현재 값을 push한다.
모든 값을 받았다면, 스택이 빌 때까지
max(현재 max값, 스택의 탑값 * (스택의 탑 바로 전 값의 위치와 전체 히스토그램의 길이의 차이))
를 수행한다.
히스토그램의 길이가 0일경우 반복을 중지한다.</description>
    </item>
    
    <item>
      <title>[백준]11054 가장 긴 바이토닉 부분 수열</title>
      <link>https://jyukki97.github.io/blog/2020-02-24-11054/</link>
      <pubDate>Mon, 24 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-02-24-11054/</guid>
      <description>https://www.acmicpc.net/problem/11054
풀이: b[i] = i 위치 왼쪽에 있는 값들 중 m[i] 보다 작은 수들의 최대 갯수
s[i] = i 위치 오른쪽에 있는 값들 중 m[i] 보다 작은 수들의 최대 갯수
가장 긴 수열의 길이 = 모든 i 에 대해 (b[i] + s[i] + 1) 의 최댓값
코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;int n, m[1001], b[1001], s[1001], ma = 0;int main() {cin &amp;gt;&amp;gt; n;for (int i = 0; i &amp;lt; n; i++)cin &amp;gt;&amp;gt; m[i];for (int i = n - 2; i &amp;gt;= 0; i--)for (int t = n - 1; t &amp;gt; i; t--)if (m[i] &amp;gt; m[t])s[i] = max(s[i], s[t] + 1);for (int i = 0; i &amp;lt; n; i++) {for (int t = 0; t &amp;lt; i; t++)if (m[i] &amp;gt; m[t])b[i] = max(b[i], b[t] + 1);ma = max(ma, b[i] + s[i] + 1);}cout &amp;lt;&amp;lt; ma &amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
    <item>
      <title>[백준]12865 평범한 배낭</title>
      <link>https://jyukki97.github.io/blog/2020-02-24-12865/</link>
      <pubDate>Mon, 24 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-02-24-12865/</guid>
      <description>https://www.acmicpc.net/problem/12865
풀이: DP[i] : i 무게일 때, 배낭에 넣을 수 있는 물건의 가치의 최댓값
DP[i + w] = max(DP[i + w], DP[i] + v)
무게가 i + w 일 때, 최댓값은 이전에 있었던 i + w 일때의 값과, i 에 있는 값에 w 무게 물건의 가치인 v를 더한 값 중 최댓값이다.
(DP를 DP[2][100001] 처럼 두개로 나누어 놓은 이유는 물건의 갯수가 1개씩이기 때문에 물건 중복을 피하기위해 나누어놓았다.)
ex) 무게가 4이고, 가치가 5일때, DP[4] = 5 가 되지만, DP[8] = DP[4] + 5 가 되어 10이 되는 불상사가 일어날 수 있기 때문에, 두개로 나누어 놓앗다.</description>
    </item>
    
    <item>
      <title>[백준]14888 연산자 끼워넣기</title>
      <link>https://jyukki97.github.io/blog/2020-02-24-14888/</link>
      <pubDate>Mon, 24 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-02-24-14888/</guid>
      <description>https://www.acmicpc.net/problem/14888
풀이: 각 숫자를 순서대로 배열에 넣어놓는다.
+, -, *, / 를 갯수만큼 각 숫자사이의 끼워넣어 식을 만든다.
만들 식의 값들을 배열에 저장해놓는다.
배열에 들어있는 수 중 최댓값, 최솟값을 출력한다.
코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;int n, num[101], op[4];vector&amp;lt;int&amp;gt; sumn;void o(int a, int b) {if (a == n - 1) {sumn.push_back(b);return;}if (op[0] &amp;gt; 0) {op[0]--;o(a + 1, b + num[a + 1]);op[0]++;}if (op[1] &amp;gt; 0) {op[1]--;o(a + 1, b - num[a + 1]);op[1]++;}if (op[2] &amp;gt; 0) {op[2]--;o(a + 1, b * num[a + 1]);op[2]++;}if (op[3] &amp;gt; 0) {op[3]--;o(a + 1, b / num[a + 1]);op[3]++;}}int main() {cin &amp;gt;&amp;gt; n;for (int i = 0; i &amp;lt; n; i++)cin &amp;gt;&amp;gt; num[i];cin &amp;gt;&amp;gt; op[0] &amp;gt;&amp;gt; op[1] &amp;gt;&amp;gt; op[2] &amp;gt;&amp;gt; op[3];o(0, num[0]);sort(sumn.</description>
    </item>
    
    <item>
      <title>[백준]14889 스타트와 링크</title>
      <link>https://jyukki97.github.io/blog/2020-02-24-14889/</link>
      <pubDate>Mon, 24 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-02-24-14889/</guid>
      <description>https://www.acmicpc.net/problem/14889
풀이: n / 2 명의 스타트 팀과 n / 2 팀의 링크팀을 만든다.
스타트팀만 만든다면, 자동적으로 남는 사람들은 링크팀이된다.
구하는 팀에 1은 무조건 들어가도록한다. (1을 포함한 팀을 전부 구한다면, 1을 포함하지 않는 팀은 상대팀에 모두 있기 때문에)
스타트팀의 모든 Sij 값의 합과 링크팀의 모든 Sij 값의 합의 차이를 구한다.
구한 차이들 중 가장 작은 값을 출력한다.
코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;int n, m[21][21], mn = 100000, start, link;bool s[21];void st(int a, int b) {if (a == n / 2) {start = 0;link = 0;for (int i = 0; i &amp;lt; n; i++)if (s[i]) {for (int t = i + 1; t &amp;lt; n; t++)if (s[t])start += m[i][t] + m[t][i];}elsefor (int t = i + 1; t &amp;lt; n; t++)if (!</description>
    </item>
    
    <item>
      <title>[백준]1541 잃어버린 괄호</title>
      <link>https://jyukki97.github.io/blog/2020-02-24-1541/</link>
      <pubDate>Mon, 24 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-02-24-1541/</guid>
      <description>https://www.acmicpc.net/problem/1541
풀이: 문자열을 하나씩 확인한다.
+ 라면, 괄호를 치지않는다.
- 라면, 괄호를 친다.
즉, -가 나오면 시작괄호를 치고, 다음 -가 나오면, 끝나는 괄호가 된다.
ex) 45 + 55 - 65 + 45 - 67 + 67
= 45 + 55 - (65 + 45) - (67 + 67)
코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;string&amp;gt;using namespace std;int main() {string s;vector&amp;lt;int&amp;gt; a;int n = 0;cin &amp;gt;&amp;gt; s;a.</description>
    </item>
    
    <item>
      <title>[백준]1676 팩도리얼 0의 개수</title>
      <link>https://jyukki97.github.io/blog/2020-02-24-1676/</link>
      <pubDate>Mon, 24 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-02-24-1676/</guid>
      <description>https://www.acmicpc.net/problem/1676
풀이: 뒤에서 0이 나오려면 팩토리얼을 곱할때, 5 가 곱해져야한다.
즉, 5의 배수가 지나간다면, 팩토리얼의 갯수가 1씩 늘어날 것이다.
팩토리얼을 만드는 동안 5가 몇번 곱해지는지 계산한다면, 0의 갯수를 구할 수 있다.
(이 문제는 N의 제한이 500 까지이기 때문에, 팩토리얼을 전체 계산해서 구하기는 힘들다.)
코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;using namespace std;int main() {int n, m = 0;cin &amp;gt;&amp;gt; n;while (n) {n /= 5;m += n;}cout &amp;lt;&amp;lt; m &amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
    <item>
      <title>[백준]1931 회의실배정</title>
      <link>https://jyukki97.github.io/blog/2020-02-24-1931/</link>
      <pubDate>Mon, 24 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-02-24-1931/</guid>
      <description>https://www.acmicpc.net/problem/1931
풀이: 회의 정보를 배열에 저장한다.
저장된 배열을 끝나는 시간을 기준으로 정렬한다. (끝나는 시간이 같다면, 시작하는 시간을 기준으로 정렬)
배열을 처음부터 순회해간다.
저장된 끝값보다 현재 시작시간이 더 크다면, 끝값을 현재 끝나는 시간으로 바꾸고 사용할 수 있는 회의 수를 +1 해준다.
코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;int n, ma = 0, e = -1;int main() {cin &amp;gt;&amp;gt; n;vector&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; v(n);for (int i = 0; i &amp;lt; n; i++)cin &amp;gt;&amp;gt; v[i].</description>
    </item>
    
    <item>
      <title>[백준]2565 전깃줄</title>
      <link>https://jyukki97.github.io/blog/2020-02-24-2565/</link>
      <pubDate>Mon, 24 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-02-24-2565/</guid>
      <description>https://www.acmicpc.net/problem/2565
풀이: c[i] = i 위치 이전 값 중 겹치는 것이 없는 갯수의 최대
연결된 전깃줄 A와 전깃줄 B 를 배열에 저장한다.
저장된 배열을 전깃줄 A를 기준으로 정렬한다.
첫번째 원소부터, 이전 원소 중 전깃줄 B가 더 작은 값 중 c[i] 의 최댓값 + 1을 저장한다.
max값에 c[i]의 최댓값 + 1 중 최댓값을 저장한다.
n - max값을 출력한다.
코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;int n, a, b, c[101], ma = 0;vector&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; v;int main() {cin &amp;gt;&amp;gt; n;for (int i = 0; i &amp;lt; n; i++) {cin &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b;v.</description>
    </item>
    
    <item>
      <title>[백준]5430 AC</title>
      <link>https://jyukki97.github.io/blog/2020-02-24-5430/</link>
      <pubDate>Mon, 24 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-02-24-5430/</guid>
      <description>https://www.acmicpc.net/problem/5430
풀이: 배열안에 들어있는 원소를
R이 나오면 뒤집고,
D가 나오면 맨 앞 숫자를 버린다.
만약 D가 나왔는데, 배열이 비어있다면, error 를 출력한다.
시간초과에 주의하자 : cout &amp;raquo; printf, cin &amp;raquo; scanf
특히 strlen을 주의하자 시간을 많이잡아먹는다.
코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;string.h&amp;gt;#include &amp;lt;queue&amp;gt;using namespace std;int main() {int T, n, m;cin &amp;gt;&amp;gt; T;while (T--) {deque&amp;lt;int&amp;gt; a;char p[100001], s[300001], *tok;bool b = true, l = true;scanf(&amp;#34;%s %d %s&amp;#34;, &amp;amp;p, &amp;amp;n, &amp;amp;s);if (n) {tok = strtok(s, &amp;#34;[,]&amp;#34;);do {a.</description>
    </item>
    
    <item>
      <title>[백준]9375 패션왕 신해빈</title>
      <link>https://jyukki97.github.io/blog/2020-02-24-9375/</link>
      <pubDate>Mon, 24 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-02-24-9375/</guid>
      <description>https://www.acmicpc.net/problem/9375
풀이: 프로그래머스]위장 을 참고
코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;string&amp;gt;#include &amp;lt;map&amp;gt;using namespace std;int main() {int n, m, ma;cin &amp;gt;&amp;gt; n;while (n--) {ma = 1;cin &amp;gt;&amp;gt; m;string s;map&amp;lt;string, int&amp;gt; a;for (int i = 0; i &amp;lt; m; i++) {cin &amp;gt;&amp;gt; s &amp;gt;&amp;gt; s;a[s]++;}for (auto i = a.begin(); i != a.end(); i++)ma *= i-&amp;gt;second + 1;cout &amp;lt;&amp;lt; ma - 1 &amp;lt;&amp;lt; endl;}return 0;}</description>
    </item>
    
    <item>
      <title>[백준]9663 N-Queen</title>
      <link>https://jyukki97.github.io/blog/2020-02-23-9663/</link>
      <pubDate>Sun, 23 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-02-23-9663/</guid>
      <description>https://www.acmicpc.net/problem/9663
풀이: https://jyukki97.github.io/blog/2020-02-23-nqueen/ 을 참고
코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;using namespace std;bool visit[16][16];int n, sum = 0;bool po(int a, int b) {for (int i = 1; i &amp;lt;= a || i &amp;lt;= b; i++) {if ((a - i &amp;gt;= 0 &amp;amp;&amp;amp; b - i &amp;gt;= 0 &amp;amp;&amp;amp; visit[a - i][b - i]) ||(a - i &amp;gt;= 0 &amp;amp;&amp;amp; b + i &amp;lt; n &amp;amp;&amp;amp; visit[a - i][b + i]) ||(a - i &amp;gt;= 0 &amp;amp;&amp;amp; visit[a - i][b]))	return false;}return true;}void nq(int a) {for (int i = 0; i &amp;lt; n; i++) {if (po(a, i)) {if (a == n - 1)	sum++;else {visit[a][i] = true;nq(a + 1);visit[a][i] = false;}}}}int main() {cin &amp;gt;&amp;gt; n;nq(0);cout &amp;lt;&amp;lt; sum &amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
    <item>
      <title>[프로그래머스]N-Queen</title>
      <link>https://jyukki97.github.io/blog/2020-02-23-nqueen/</link>
      <pubDate>Sun, 23 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-02-23-nqueen/</guid>
      <description>https://programmers.co.kr
문제: 가로, 세로 길이가 n인 정사각형으로된 체스판이 있습니다. 체스판 위의 n개의 퀸이 서로를 공격할 수 없도록 배치하고 싶습니다.
예를 들어서 n이 4인경우 다음과 같이 퀸을 배치하면 n개의 퀸은 서로를 한번에 공격 할 수 없습니다.
체스판의 가로 세로의 세로의 길이 n이 매개변수로 주어질 때, n개의 퀸이 조건에 만족 하도록 배치할 수 있는 방법의 수를 return하는 solution함수를 완성해주세요.
풀이: 첫번째 줄부터 n번째 줄까지 퀸을 하나 씩 놓을 수 있다.
i번째 줄에 0 ~ n까지 퀸을 놓는다고 할 때,</description>
    </item>
    
    <item>
      <title>[백준]1181 단어 정렬</title>
      <link>https://jyukki97.github.io/blog/2020-02-22-1181/</link>
      <pubDate>Sat, 22 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-02-22-1181/</guid>
      <description>https://www.acmicpc.net/problem/1181
풀이: 배열에 들어있는 string을 길이 순서로 정렬 후
길이가 같다면, 사전순으로 정렬한다.
이 때, 중복된 문자가 있다면, 제거한다.
코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;set&amp;gt;#include &amp;lt;string&amp;gt;using namespace std;bool com(string a, string b) {if (a.size() == b.size())return a &amp;lt; b;return a.size() &amp;lt; b.size();}int main() { int n;cin &amp;gt;&amp;gt; n;string s;set&amp;lt;string, decltype(&amp;amp;com)&amp;gt; a(&amp;amp;com);for (int i = 0; i &amp;lt; n; i++) {cin &amp;gt;&amp;gt; s;a.</description>
    </item>
    
    <item>
      <title>[백준]1018 체스판 다시 칠하기</title>
      <link>https://jyukki97.github.io/blog/2020-02-21-1018/</link>
      <pubDate>Fri, 21 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-02-21-1018/</guid>
      <description>https://www.acmicpc.net/problem/1018
풀이: (0, 0) ~ (8, 8) &amp;hellip;.. (n - 8, m - 8) ~ (n, m) 까지의 모든 8 X 8 체스판을 서치한다.
체스판이 WBWBWB&amp;hellip; 순서로 되어있는지 확인 후 안되어 있는 칸이 몇 칸인지 찾는다.
찾아낸 수를 C라고 할 때, 64 - C와 C 중 더 작은 값을 저장한다.
저장된 값들 중 가장 작은 값을 출력한다.
코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;string&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;int main() { int n, m, c, ma = 64;cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;vector&amp;lt;string&amp;gt; a(n);for (int i = 0; i &amp;lt; n; i++)cin &amp;gt;&amp;gt; a[i];for (int i = 0; i &amp;lt; n - 7; i++) {for (int t = 0; t &amp;lt; m - 7; t++) {c = 0;for (int y = 0; y &amp;lt; 8; y++)for (int u = 0; u &amp;lt; 8; u++) {bool b = (y % 2) ^ (u % 2) ^ (a[i + y][t + u] == &amp;#39;B&amp;#39; ?</description>
    </item>
    
    <item>
      <title>[백준]2231 분해합</title>
      <link>https://jyukki97.github.io/blog/2020-02-20-2231/</link>
      <pubDate>Thu, 20 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-02-20-2231/</guid>
      <description>https://www.acmicpc.net/problem/2231
풀이: n - (n의 자릿수 * 9) ~ n 까지의 수 중 n의 생성자를 찾아 출력한다.
없다면 0을 출력
n의 자릿수 * 9를 뺀 수부터 시작하는 이유는 생성자가 n + (n의 각 자릿수의 합) 이므로
각 자릿수의 최댓값인 9를 자릿수 만큼 곱한 후 n에서 빼준 값이 생성자의 최소 조건이 된다.
코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;string&amp;gt;using namespace std;int c(int a) {int n = a;while (a) {n += a % 10;a /= 10;}return n;}int main() { string m;bool b = true;cin &amp;gt;&amp;gt; m;int n = stoi(m), a = n - 9 * m.</description>
    </item>
    
    <item>
      <title>[백준]2798 블랙잭</title>
      <link>https://jyukki97.github.io/blog/2020-02-19-2798/</link>
      <pubDate>Wed, 19 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-02-19-2798/</guid>
      <description>https://www.acmicpc.net/problem/2798
풀이: 3장을 뽑을 수 있는 모든 경우의 수를 확인하여 3장의 합이 M값을 넘지않는 최댓값을 출력한다.
코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;int main() { int n, m, ma = 0;cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;vector&amp;lt;int&amp;gt; a(n, 0);for (int i = 0; i &amp;lt; n; i++)cin &amp;gt;&amp;gt; a[i];for (int i = 0; i &amp;lt; n - 2; i++)for (int t = i + 1; t &amp;lt; n - 1; t++)for (int y = t + 1; y &amp;lt; n; y++)if (a[i] + a[t] + a[y] &amp;lt;= m)ma = max(ma, a[i] + a[t] + a[y]);cout &amp;lt;&amp;lt; ma &amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
    <item>
      <title>[백준]11729 하노이 탑 이동 순서</title>
      <link>https://jyukki97.github.io/blog/2020-02-18-11729/</link>
      <pubDate>Tue, 18 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-02-18-11729/</guid>
      <description>https://www.acmicpc.net/problem/11729
풀이: https://jyukki97.github.io/blog/2020-02-18-towerofhanoi/ 를 참고
코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;using namespace std;void h(int n, int a, int b, int c) {if (!n) return;else {h(n - 1, a, c, b);printf(&amp;#34;%d %d\n&amp;#34;, a, b);h(n - 1, c, b, a);}}int main() { int n, a = 1;cin &amp;gt;&amp;gt; n;for (int i = 0; i &amp;lt; n; i++)a *= 2;cout &amp;lt;&amp;lt; a - 1 &amp;lt;&amp;lt; endl;h(n, 1, 3, 2);return 0;}</description>
    </item>
    
    <item>
      <title>[프로그래머스]하노이의 탑</title>
      <link>https://jyukki97.github.io/blog/2020-02-18-towerofhanoi/</link>
      <pubDate>Tue, 18 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-02-18-towerofhanoi/</guid>
      <description>https://programmers.co.kr
문제: 하노이 탑(Tower of Hanoi)은 퍼즐의 일종입니다. 세 개의 기둥과 이 기동에 꽂을 수 있는 크기가 다양한 원판들이 있고, 퍼즐을 시작하기 전에는 한 기둥에 원판들이 작은 것이 위에 있도록 순서대로 쌓여 있습니다. 게임의 목적은 다음 두 가지 조건을 만족시키면서, 한 기둥에 꽂힌 원판들을 그 순서 그대로 다른 기둥으로 옮겨서 다시 쌓는 것입니다.
 한 번에 하나의 원판만 옮길 수 있습니다. 큰 원판이 작은 원판 위에 있어서는 안됩니다.  하노이 탑의 세 개의 기둥을 왼쪽 부터 1번, 2번, 3번이라고 하겠습니다.</description>
    </item>
    
    <item>
      <title>[프로그래머스]단어 변환</title>
      <link>https://jyukki97.github.io/blog/2020-02-17-wordtranslation/</link>
      <pubDate>Mon, 17 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-02-17-wordtranslation/</guid>
      <description>https://programmers.co.kr
문제: 두 개의 단어 begin, target과 단어의 집합 words가 있습니다. 아래와 같은 규칙을 이용하여 begin에서 target으로 변환하는 가장 짧은 변환 과정을 찾으려고 합니다.
1. 한 번에 한 개의 알파벳만 바꿀 수 있습니다.2. words에 있는 단어로만 변환할 수 있습니다.예를 들어 begin이 hit, target가 cog, words가 [hot,dot,dog,lot,log,cog]라면 hit -&amp;gt; hot -&amp;gt; dot -&amp;gt; dog -&amp;gt; cog와 같이 4단계를 거쳐 변환할 수 있습니다.
두 개의 단어 begin, target과 단어의 집합 words가 매개변수로 주어질 때, 최소 몇 단계의 과정을 거쳐 begin을 target으로 변환할 수 있는지 return 하도록 solution 함수를 작성해주세요.</description>
    </item>
    
    <item>
      <title>[프로그래머스]입국심사</title>
      <link>https://jyukki97.github.io/blog/2020-02-16-immigration/</link>
      <pubDate>Sun, 16 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-02-16-immigration/</guid>
      <description>https://programmers.co.kr
문제: n명이 입국심사를 위해 줄을 서서 기다리고 있습니다. 각 입국심사대에 있는 심사관마다 심사하는데 걸리는 시간은 다릅니다.
처음에 모든 심사대는 비어있습니다. 한 심사대에서는 동시에 한 명만 심사를 할 수 있습니다. 가장 앞에 서 있는 사람은 비어 있는 심사대로 가서 심사를 받을 수 있습니다. 하지만 더 빨리 끝나는 심사대가 있으면 기다렸다가 그곳으로 가서 심사를 받을 수도 있습니다.
모든 사람이 심사를 받는데 걸리는 시간을 최소로 하고 싶습니다.
입국심사를 기다리는 사람 수 n, 각 심사관이 한 명을 심사하는데 걸리는 시간이 담긴 배열 times가 매개변수로 주어질 때, 모든 사람이 심사를 받는데 걸리는 시간의 최솟값을 return 하도록 solution 함수를 작성해주세요.</description>
    </item>
    
    <item>
      <title>[프로그래머스]조이스틱</title>
      <link>https://jyukki97.github.io/blog/2020-02-15-joystick/</link>
      <pubDate>Sat, 15 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-02-15-joystick/</guid>
      <description>https://programmers.co.kr
문제: 조이스틱으로 알파벳 이름을 완성하세요. 맨 처음엔 A로만 이루어져 있습니다. ex) 완성해야 하는 이름이 세 글자면 AAA, 네 글자면 AAAA
조이스틱을 각 방향으로 움직이면 아래와 같습니다.
▲ - 다음 알파벳▼ - 이전 알파벳 (A에서 아래쪽으로 이동하면 Z로)◀ - 커서를 왼쪽으로 이동 (첫 번째 위치에서 왼쪽으로 이동하면 마지막 문자에 커서)▶ - 커서를 오른쪽으로 이동예를 들어 아래의 방법으로 JAZ를 만들 수 있습니다.
- 첫 번째 위치에서 조이스틱을 위로 9번 조작하여 J를 완성합니다.</description>
    </item>
    
    <item>
      <title>[프로그래머스]구명보트</title>
      <link>https://jyukki97.github.io/blog/2020-02-14-lifeboat/</link>
      <pubDate>Fri, 14 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-02-14-lifeboat/</guid>
      <description>https://programmers.co.kr
문제: 무인도에 갇힌 사람들을 구명보트를 이용하여 구출하려고 합니다. 구명보트는 작아서 한 번에 최대 2명씩 밖에 탈 수 없고, 무게 제한도 있습니다.
예를 들어, 사람들의 몸무게가 [70kg, 50kg, 80kg, 50kg]이고 구명보트의 무게 제한이 100kg이라면 2번째 사람과 4번째 사람은 같이 탈 수 있지만 1번째 사람과 3번째 사람의 무게의 합은 150kg이므로 구명보트의 무게 제한을 초과하여 같이 탈 수 없습니다.
구명보트를 최대한 적게 사용하여 모든 사람을 구출하려고 합니다.
사람들의 몸무게를 담은 배열 people과 구명보트의 무게 제한 limit가 매개변수로 주어질 때, 모든 사람을 구출하기 위해 필요한 구명보트 개수의 최솟값을 return 하도록 solution 함수를 작성해주세요.</description>
    </item>
    
    <item>
      <title>[프로그래머스]압축</title>
      <link>https://jyukki97.github.io/blog/2020-02-13-compression/</link>
      <pubDate>Thu, 13 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-02-13-compression/</guid>
      <description>https://programmers.co.kr
문제: 신입사원 어피치는 카카오톡으로 전송되는 메시지를 압축하여 전송 효율을 높이는 업무를 맡게 되었다. 메시지를 압축하더라도 전달되는 정보가 바뀌어서는 안 되므로, 압축 전의 정보를 완벽하게 복원 가능한 무손실 압축 알고리즘을 구현하기로 했다.
어피치는 여러 압축 알고리즘 중에서 성능이 좋고 구현이 간단한 LZW(Lempel–Ziv–Welch) 압축을 구현하기로 했다. LZW 압축은 1983년 발표된 알고리즘으로, 이미지 파일 포맷인 GIF 등 다양한 응용에서 사용되었다.
LZW 압축은 다음 과정을 거친다.
 길이가 1인 모든 단어를 포함하도록 사전을 초기화한다.</description>
    </item>
    
    <item>
      <title>[프로그래머스]캐시</title>
      <link>https://jyukki97.github.io/blog/2020-02-12-cache/</link>
      <pubDate>Wed, 12 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-02-12-cache/</guid>
      <description>https://programmers.co.kr
문제: 지도개발팀에서 근무하는 제이지는 지도에서 도시 이름을 검색하면 해당 도시와 관련된 맛집 게시물들을 데이터베이스에서 읽어 보여주는 서비스를 개발하고 있다. 이 프로그램의 테스팅 업무를 담당하고 있는 어피치는 서비스를 오픈하기 전 각 로직에 대한 성능 측정을 수행하였는데, 제이지가 작성한 부분 중 데이터베이스에서 게시물을 가져오는 부분의 실행시간이 너무 오래 걸린다는 것을 알게 되었다. 어피치는 제이지에게 해당 로직을 개선하라고 닦달하기 시작하였고, 제이지는 DB 캐시를 적용하여 성능 개선을 시도하고 있지만 캐시 크기를 얼마로 해야 효율적인지 몰라 난감한 상황이다.</description>
    </item>
    
    <item>
      <title>[프로그래머스]다트 게임</title>
      <link>https://jyukki97.github.io/blog/2020-02-11-dartgame/</link>
      <pubDate>Tue, 11 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-02-11-dartgame/</guid>
      <description>https://programmers.co.kr
문제: 카카오톡 게임별의 하반기 신규 서비스로 다트 게임을 출시하기로 했다. 다트 게임은 다트판에 다트를 세 차례 던져 그 점수의 합계로 실력을 겨루는 게임으로, 모두가 간단히 즐길 수 있다. 갓 입사한 무지는 코딩 실력을 인정받아 게임의 핵심 부분인 점수 계산 로직을 맡게 되었다. 다트 게임의 점수 계산 로직은 아래와 같다.
 다트 게임은 총 3번의 기회로 구성된다. 각 기회마다 얻을 수 있는 점수는 0점에서 10점까지이다. 점수와 함께 Single(S), Double(D), Triple(T) 영역이 존재하고 각 영역 당첨 시 점수에서 1제곱, 2제곱, 3제곱 (점수1 , 점수2 , 점수3 )으로 계산된다.</description>
    </item>
    
    <item>
      <title>[프로그래머스]문자열 내 마음대로 정렬하기</title>
      <link>https://jyukki97.github.io/blog/2020-02-10-stringsort/</link>
      <pubDate>Mon, 10 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-02-10-stringsort/</guid>
      <description>https://programmers.co.kr
문제: 문자열로 구성된 리스트 strings와, 정수 n이 주어졌을 때, 각 문자열의 인덱스 n번째 글자를 기준으로 오름차순 정렬하려 합니다. 예를 들어 strings가 [sun, bed, car]이고 n이 1이면 각 단어의 인덱스 1의 문자 u, e, a로 strings를 정렬합니다.
풀이: n번째 글자를 기준으로 오름차순 정렬을 한다.
코드: 사용언어 : c++
#include &amp;lt;string&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;vector&amp;lt;string&amp;gt; solution(vector&amp;lt;string&amp;gt; strings, int n) {vector&amp;lt;string&amp;gt; answer;for (int i = 0; i &amp;lt; strings.</description>
    </item>
    
    <item>
      <title>[프로그래머스]올바른 괄호의 갯수</title>
      <link>https://jyukki97.github.io/blog/2020-02-09-correctbrackets/</link>
      <pubDate>Sun, 09 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-02-09-correctbrackets/</guid>
      <description>https://programmers.co.kr
문제: 올바른 괄호란 (())나 ()와 같이 올바르게 모두 닫힌 괄호를 의미합니다. )(나 ())() 와 같은 괄호는 올바르지 않은 괄호가 됩니다. 괄호 쌍의 개수 n이 주어질 때, n개의 괄호 쌍으로 만들 수 있는 모든 가능한 괄호 문자열의 갯수를 반환하는 함수 solution을 완성해 주세요.
풀이: 괄호를 () 라고 했을 때, 이것을 ( 따로 ) 따로 생각해서 순열을 구한다고 해보자.
이 때, 나열 할 수 있는 경우의 수는 (2*n)! 이 된다.
그러나 ( 의 갯수와 ) 의 갯수가 각각 n개씩 중복되므로 (n!</description>
    </item>
    
    <item>
      <title>[프로그래머스]숫자 블록</title>
      <link>https://jyukki97.github.io/blog/2020-02-08-numblock/</link>
      <pubDate>Sat, 08 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-02-08-numblock/</guid>
      <description>https://programmers.co.kr
문제: 그렙시에는 0으로 된 도로에 숫자 블록을 설치하기로 하였습니다. 숫자 블록의 규칙은 다음과 같습니다.
블록의 번호가 n 일 때, 가장 처음 블록은 n * 2번째 위치에 설치합니다. 그다음은 n * 3, 그다음은 n * 4, &amp;hellip;로 진행합니다.만약 기존에 블록이 깔려있는 자리라면 그 블록을빼고 새로운 블록으로 집어넣습니다.
예를 들어 1번 블록은 2,3,4,5, &amp;hellip; 인 위치에 우선 설치합니다. 그다음 2번 블록은 4,6,8,10, &amp;hellip; 인 위치에 설치하고, 3번 블록은 6,9,12&amp;hellip; 인 위치에 설치합니다.</description>
    </item>
    
    <item>
      <title>[프로그래머스]카드 게임</title>
      <link>https://jyukki97.github.io/blog/2020-02-07-cardgame/</link>
      <pubDate>Fri, 07 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-02-07-cardgame/</guid>
      <description>https://programmers.co.kr
문제: 카드게임이 있다. 게임에 사용하는 각 카드에는 양의 정수 하나가 적혀있고 같은 숫자가 적힌 카드는 여러 장 있을 수 있다. 게임방법은 우선 짝수개의 카드를 무작위로 섞은 뒤 같은 개수의 두 더미로 나누어 하나는 왼쪽에 다른 하나는 오른쪽에 둔다.
각 더미의 제일 위에 있는 카드끼리 서로 비교하며 게임을 한다. 게임 규칙은 다음과 같다. 지금부터 왼쪽 더미의 제일 위 카드를 왼쪽 카드로, 오른쪽 더미의 제일 위 카드를 오른쪽 카드로 부르겠다.
1. 언제든지 왼쪽 카드만 통에 버릴 수도 있고 왼쪽 카드와 오른쪽 카드를 둘 다 통에 버릴 수도 있다.</description>
    </item>
    
    <item>
      <title>[프로그래머스]3 X n 타일링</title>
      <link>https://jyukki97.github.io/blog/2020-02-06-3xn/</link>
      <pubDate>Thu, 06 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-02-06-3xn/</guid>
      <description>https://programmers.co.kr
문제: 가로 길이가 2이고 세로의 길이가 1인 직사각형 모양의 타일이 있습니다. 이 직사각형 타일을 이용하여 세로의 길이가 3이고 가로의 길이가 n인 바닥을 가득 채우려고 합니다. 타일을 채울 때는 다음과 같이 2가지 방법이 있습니다
 타일을 가로로 배치 하는 경우 타일을 세로로 배치 하는 경우  예를들어서 n이 8인 직사각형은 다음과 같이 채울 수 있습니다.
직사각형의 가로의 길이 n이 매개변수로 주어질 때, 이 직사각형을 채우는 방법의 수를 return 하는 solution 함수를 완성해주세요.</description>
    </item>
    
    <item>
      <title>[프로그래머스]야근 지수</title>
      <link>https://jyukki97.github.io/blog/2020-02-05-overtimeindex/</link>
      <pubDate>Wed, 05 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-02-05-overtimeindex/</guid>
      <description>https://programmers.co.kr
문제: 회사원 Demi는 가끔은 야근을 하는데요, 야근을 하면 야근 피로도가 쌓입니다. 야근 피로도는 야근을 시작한 시점에서 남은 일의 작업량을 제곱하여 더한 값입니다. Demi는 N시간 동안 야근 피로도를 최소화하도록 일할 겁니다.Demi가 1시간 동안 작업량 1만큼을 처리할 수 있다고 할 때, 퇴근까지 남은 N 시간과 각 일에 대한 작업량 works에 대해 야근 피로도를 최소화한 값을 리턴하는 함수 solution을 완성해주세요.
풀이: 작업량 works에 들어있는 값 중 최댓값에서 1을 빼는 작업을 퇴근 까지 남은 시간인 N시간 만큼 반복한다.</description>
    </item>
    
    <item>
      <title>[프로그래머스]멀리 뛰기</title>
      <link>https://jyukki97.github.io/blog/2020-02-04-longjump/</link>
      <pubDate>Tue, 04 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-02-04-longjump/</guid>
      <description>https://programmers.co.kr
문제: 효진이는 멀리 뛰기를 연습하고 있습니다. 효진이는 한번에 1칸, 또는 2칸을 뛸 수 있습니다. 칸이 총 4개 있을 때, 효진이는 (1칸, 1칸, 1칸, 1칸) (1칸, 2칸, 1칸) (1칸, 1칸, 2칸) (2칸, 1칸, 1칸) (2칸, 2칸) 의 5가지 방법으로 맨 끝 칸에 도달할 수 있습니다. 멀리뛰기에 사용될 칸의 수 n이 주어질 때, 효진이가 끝에 도달하는 방법이 몇 가지인지 알아내, 여기에 1234567를 나눈 나머지를 리턴하는 함수, solution을 완성하세요. 예를 들어 4가 입력된다면, 5를 return하면 됩니다.</description>
    </item>
    
    <item>
      <title>[프로그래머스]다음 큰 숫자</title>
      <link>https://jyukki97.github.io/blog/2020-02-03-nextbignum/</link>
      <pubDate>Mon, 03 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-02-03-nextbignum/</guid>
      <description>https://programmers.co.kr
문제: 자연수 n이 주어졌을 때, n의 다음 큰 숫자는 다음과 같이 정의 합니다.
 조건 1. n의 다음 큰 숫자는 n보다 큰 자연수 입니다. 조건 2. n의 다음 큰 숫자와 n은 2진수로 변환했을 때 1의 갯수가 같습니다. 조건 3. n의 다음 큰 숫자는 조건 1, 2를 만족하는 수 중 가장 작은 수 입니다.  예를 들어서 78(1001110)의 다음 큰 숫자는 83(1010011)입니다.
자연수 n이 매개변수로 주어질 때, n의 다음 큰 숫자를 return 하는 solution 함수를 완성해주세요.</description>
    </item>
    
    <item>
      <title>[프로그래머스]줄 서는 방법</title>
      <link>https://jyukki97.github.io/blog/2020-02-02-howtolineup/</link>
      <pubDate>Sun, 02 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-02-02-howtolineup/</guid>
      <description>https://programmers.co.kr
문제: n명의 사람이 일렬로 줄을 서고 있습니다. n명의 사람들에게는 각각 1번부터 n번까지 번호가 매겨져 있습니다. n명이 사람을 줄을 서는 방법은 여러가지 방법이 있습니다. 예를 들어서 3명의 사람이 있다면 다음과 같이 6개의 방법이 있습니다.
 [1, 2, 3] [1, 3, 2] [2, 1, 3] [2, 3, 1] [3, 1, 2] [3, 2, 1]  사람의 수 n과, 자연수 k가 주어질 때, 사람을 나열 하는 방법을 사전 순으로 나열 했을 때, k번째 방법을 return하는 solution 함수를 완성해주세요.</description>
    </item>
    
    <item>
      <title>[프로그래머스]가장 큰 수</title>
      <link>https://jyukki97.github.io/blog/2020-02-01-biggestnum/</link>
      <pubDate>Sat, 01 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-02-01-biggestnum/</guid>
      <description>https://programmers.co.kr
문제: 0 또는 양의 정수가 주어졌을 때, 정수를 이어 붙여 만들 수 있는 가장 큰 수를 알아내 주세요.
예를 들어, 주어진 정수가 [6, 10, 2]라면 [6102, 6210, 1062, 1026, 2610, 2106]를 만들 수 있고, 이중 가장 큰 수는 6210입니다.
0 또는 양의 정수가 담긴 배열 numbers가 매개변수로 주어질 때, 순서를 재배치하여 만들 수 있는 가장 큰 수를 문자열로 바꾸어 return 하도록 solution 함수를 작성해주세요.
풀이: int 배열을 string으로 바꿔서 정렬한다.</description>
    </item>
    
    <item>
      <title>[프로그래머스]소수 찾기</title>
      <link>https://jyukki97.github.io/blog/2020-01-31-findprimnum/</link>
      <pubDate>Fri, 31 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-01-31-findprimnum/</guid>
      <description>https://programmers.co.kr
문제: 한자리 숫자가 적힌 종이 조각이 흩어져있습니다. 흩어진 종이 조각을 붙여 소수를 몇 개 만들 수 있는지 알아내려 합니다.
각 종이 조각에 적힌 숫자가 적힌 문자열 numbers가 주어졌을 때, 종이 조각으로 만들 수 있는 소수가 몇 개인지 return 하도록 solution 함수를 완성해주세요.
풀이: 문자열 numbers로 만들 수 있는 모든 순열을 set에 넣는다. (중복된 숫자를 거르기 위함)
set에 들어있는 수들을 모두 순회하여 소수라면 answer값을 +1 해준다.
(맨 처음에 sort를 하지않을 경우 실패가 뜨는데 왜 그런지는 잘 모르겠다.</description>
    </item>
    
    <item>
      <title>[프로그래머스]오픈 채팅방</title>
      <link>https://jyukki97.github.io/blog/2020-01-30-openchating/</link>
      <pubDate>Thu, 30 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-01-30-openchating/</guid>
      <description>https://programmers.co.kr
문제: 카카오톡 오픈채팅방에서는 친구가 아닌 사람들과 대화를 할 수 있는데, 본래 닉네임이 아닌 가상의 닉네임을 사용하여 채팅방에 들어갈 수 있다.
신입사원인 김크루는 카카오톡 오픈 채팅방을 개설한 사람을 위해, 다양한 사람들이 들어오고, 나가는 것을 지켜볼 수 있는 관리자창을 만들기로 했다. 채팅방에 누군가 들어오면 다음 메시지가 출력된다.
[닉네임]님이 들어왔습니다.
채팅방에서 누군가 나가면 다음 메시지가 출력된다.
[닉네임]님이 나갔습니다.
채팅방에서 닉네임을 변경하는 방법은 다음과 같이 두 가지이다.
 채팅방을 나간 후, 새로운 닉네임으로 다시 들어간다.</description>
    </item>
    
    <item>
      <title>[프로그래머스]소수 만들기</title>
      <link>https://jyukki97.github.io/blog/2020-01-29-makeprimenum/</link>
      <pubDate>Wed, 29 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-01-29-makeprimenum/</guid>
      <description>https://programmers.co.kr
문제: 주어진 숫자 중 3개의 수를 더했을 때 소수가 되는 경우의 개수를 구하려고 합니다. 숫자들이 들어있는 배열 nums가 매개변수로 주어질 때, nums에 있는 숫자들 중 서로 다른 3개를 골라 더했을 때 소수가 되는 경우의 개수를 return 하도록 solution 함수를 완성해주세요.
풀이: 3개의 숫자를 더한 값이 소수인지 아닌지 판별 후 소수라면 answer을 +1 해준다.
코드: 사용언어 : c++
#include &amp;lt;vector&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;math.h&amp;gt;using namespace std;int solution(vector&amp;lt;int&amp;gt; nums) {int answer = 0;for(int i = 0;i &amp;lt; nums.</description>
    </item>
    
    <item>
      <title>[프로그래머스]행렬의 곱셈</title>
      <link>https://jyukki97.github.io/blog/2020-01-28-matrixmultiplication/</link>
      <pubDate>Tue, 28 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-01-28-matrixmultiplication/</guid>
      <description>https://programmers.co.kr
문제: 2차원 행렬 arr1과 arr2를 입력받아, arr1에 arr2를 곱한 결과를 반환하는 함수, solution을 완성해주세요.
풀이: arr1의 가로행과 arr2의 세로열의 값들을 각각 곱한것을 더한 값을 a에 저장한다.
저장된 배열 a를 answer에 푸쉬 한다.
코드: 사용언어 : c++
#include &amp;lt;string&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std;vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; solution(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; arr1, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; arr2) {vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; answer;for (int i = 0; i &amp;lt; arr1.size(); i++){vector&amp;lt;int&amp;gt;a;for (int t = 0; t &amp;lt; arr2[0].</description>
    </item>
    
    <item>
      <title>[프로그래머스]라면공장</title>
      <link>https://jyukki97.github.io/blog/2020-01-27-ramenfactory/</link>
      <pubDate>Mon, 27 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-01-27-ramenfactory/</guid>
      <description>https://programmers.co.kr
문제: 라면 공장에서는 하루에 밀가루를 1톤씩 사용합니다. 원래 밀가루를 공급받던 공장의 고장으로 앞으로 k일 이후에야 밀가루를 공급받을 수 있기 때문에 해외 공장에서 밀가루를 수입해야 합니다.
해외 공장에서는 향후 밀가루를 공급할 수 있는 날짜와 수량을 알려주었고, 라면 공장에서는 운송비를 줄이기 위해 최소한의 횟수로 밀가루를 공급받고 싶습니다.
현재 공장에 남아있는 밀가루 수량 stock, 밀가루 공급 일정(dates)과 해당 시점에 공급 가능한 밀가루 수량(supplies), 원래 공장으로부터 공급받을 수 있는 시점 k가 주어질 때, 밀가루가 떨어지지 않고 공장을 운영하기 위해서 최소한 몇 번 해외 공장으로부터 밀가루를 공급받아야 하는지를 return 하도록 solution 함수를 완성하세요.</description>
    </item>
    
    <item>
      <title>[프로그래머스]제일 작은 수 제거하기</title>
      <link>https://jyukki97.github.io/blog/2020-01-26-removeminnum/</link>
      <pubDate>Sun, 26 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-01-26-removeminnum/</guid>
      <description>https://programmers.co.kr
문제: 정수를 저장한 배열, arr 에서 가장 작은 수를 제거한 배열을 리턴하는 함수, solution을 완성해주세요. 단, 리턴하려는 배열이 빈 배열인 경우엔 배열에 -1을 채워 리턴하세요. 예를들어 arr이 [4,3,2,1]인 경우는 [4,3,2]를 리턴 하고, [10]면 [-1]을 리턴 합니다.
풀이: arr에서 제일 작은 수를 찾아 삭제한다.
만약 arr이 비었다면 -1을 넣는다.
코드: 사용언어 : c++
#include &amp;lt;string&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std;vector&amp;lt;int&amp;gt; solution(vector&amp;lt;int&amp;gt; arr) {int min = arr[0], c = 0;for(int i = 1; i &amp;lt; arr.</description>
    </item>
    
    <item>
      <title>[프로그래머스]직사각형 별찍기</title>
      <link>https://jyukki97.github.io/blog/2020-01-25-ractanglestar/</link>
      <pubDate>Sat, 25 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-01-25-ractanglestar/</guid>
      <description>https://programmers.co.kr
문제: 이 문제에는 표준 입력으로 두 개의 정수 n과 m이 주어집니다. 별(*) 문자를 이용해 가로의 길이가 n, 세로의 길이가 m인 직사각형 형태를 출력해보세요.
풀이: n번 별을 찍는다. 개행한다.
그것을 m번 반복한다.
코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;using namespace std;int main(void) {int a, b;cin &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b;for (int i = 0; i &amp;lt; b; i++){for (int t = 0; t &amp;lt; a; t++){cout &amp;lt;&amp;lt; &amp;#39;*&amp;#39;;} cout &amp;lt;&amp;lt; endl;}return 0;}</description>
    </item>
    
    <item>
      <title>[프로그래머스]정수 내림차순으로 배치하기</title>
      <link>https://jyukki97.github.io/blog/2020-01-24-integersort/</link>
      <pubDate>Fri, 24 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-01-24-integersort/</guid>
      <description>https://programmers.co.kr
문제: 함수 solution은 정수 n을 매개변수로 입력받습니다. n의 각 자릿수를 큰것부터 작은 순으로 정렬한 새로운 정수를 리턴해주세요. 예를들어 n이 118372면 873211을 리턴하면 됩니다.
풀이: 정수 n을 string 에 담는다.
담아진 string 을 내림차순으로 정렬한다.
string을 long long 값으로 변환후 리턴한다.
코드: 사용언어 : c++
#include &amp;lt;string&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;long long solution(long long n) {string a = to_string(n);sort(a.begin(), a.end(), greater&amp;lt;char&amp;gt;());return stoull(a);}</description>
    </item>
    
    <item>
      <title>[프로그래머스]H-index</title>
      <link>https://jyukki97.github.io/blog/2020-01-23-h-index/</link>
      <pubDate>Thu, 23 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-01-23-h-index/</guid>
      <description>https://programmers.co.kr
문제: H-Index는 과학자의 생산성과 영향력을 나타내는 지표입니다. 어느 과학자의 H-Index를 나타내는 값인 h를 구하려고 합니다. 위키백과1에 따르면, H-Index는 다음과 같이 구합니다.
어떤 과학자가 발표한 논문 n편 중, h번 이상 인용된 논문이 h편 이상이고 나머지 논문이 h번 이하 인용되었다면 h가 이 과학자의 H-Index입니다.
어떤 과학자가 발표한 논문의 인용 횟수를 담은 배열 citations가 매개변수로 주어질 때, 이 과학자의 H-Index를 return 하도록 solution 함수를 작성해주세요.
풀이: 논문 n편을 정렬한다.
1번째 논문이 1보다 크다면 H-index는 1이 된다.</description>
    </item>
    
    <item>
      <title>[프로그래머스]행렬의 덧셈</title>
      <link>https://jyukki97.github.io/blog/2020-01-22-matrixsum/</link>
      <pubDate>Wed, 22 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-01-22-matrixsum/</guid>
      <description>https://programmers.co.kr
문제: 행렬의 덧셈은 행과 열의 크기가 같은 두 행렬의 같은 행, 같은 열의 값을 서로 더한 결과가 됩니다. 2개의 행렬 arr1과 arr2를 입력받아, 행렬 덧셈의 결과를 반환하는 함수, solution을 완성해주세요.
풀이: 각 행렬의 같은 행 같은 열을 더한 행렬을 출력한다.
코드: 사용언어 : c++
#include &amp;lt;string&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std;vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; solution(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; arr1, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; arr2) {for (int i = 0; i &amp;lt; arr1.size(); i++)for(int t = 0; t &amp;lt; arr1[i].</description>
    </item>
    
    <item>
      <title>[프로그래머스]폰켓몬</title>
      <link>https://jyukki97.github.io/blog/2020-01-21-phoneketmon/</link>
      <pubDate>Tue, 21 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-01-21-phoneketmon/</guid>
      <description>https://programmers.co.kr
문제: 당신은 폰켓몬을 잡기 위한 오랜 여행 끝에, 홍 박사님의 연구실에 도착했습니다. 홍 박사님은 당신에게 자신의 연구실에 있는 총 N 마리의 폰켓몬 중에서 N/2마리를 가져가도 좋다고 했습니다. 홍 박사님 연구실의 폰켓몬은 종류에 따라 번호를 붙여 구분합니다. 따라서 같은 종류의 폰켓몬은 같은 번호를 가지고 있습니다. 예를 들어 연구실에 총 4마리의 폰켓몬이 있고, 각 폰켓몬의 종류 번호가 [3번, 1번, 2번, 3번]이라면 이는 3번 폰켓몬 두 마리, 1번 폰켓몬 한 마리, 2번 폰켓몬 한 마리가 있음을 나타냅니다.</description>
    </item>
    
    <item>
      <title>[프로그래머스]점프와 순간 이동</title>
      <link>https://jyukki97.github.io/blog/2020-01-20-jumpandteleport/</link>
      <pubDate>Mon, 20 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-01-20-jumpandteleport/</guid>
      <description>https://programmers.co.kr
문제: OO 연구소는 한 번에 K 칸을 앞으로 점프하거나, (현재까지 온 거리) x 2 에 해당하는 위치로 순간이동을 할 수 있는 특수한 기능을 가진 아이언 슈트를 개발하여 판매하고 있습니다. 이 아이언 슈트는 건전지로 작동되는데, 순간이동을 하면 건전지 사용량이 줄지 않지만, 앞으로 K 칸을 점프하면 K 만큼의 건전지 사용량이 듭니다. 그러므로 아이언 슈트를 착용하고 이동할 때는 순간 이동을 하는 것이 더 효율적입니다. 아이언 슈트 구매자는 아이언 슈트를 착용하고 거리가 N 만큼 떨어져 있는 장소로 가려고 합니다.</description>
    </item>
    
    <item>
      <title>[프로그래머스]더 맵게</title>
      <link>https://jyukki97.github.io/blog/2020-01-19-morespicy/</link>
      <pubDate>Sun, 19 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-01-19-morespicy/</guid>
      <description>https://programmers.co.kr
문제: 매운 것을 좋아하는 Leo는 모든 음식의 스코빌 지수를 K 이상으로 만들고 싶습니다. 모든 음식의 스코빌 지수를 K 이상으로 만들기 위해 Leo는 스코빌 지수가 가장 낮은 두 개의 음식을 아래와 같이 특별한 방법으로 섞어 새로운 음식을 만듭니다.
섞은 음식의 스코빌 지수 = 가장 맵지 않은 음식의 스코빌 지수 + (두 번째로 맵지 않은 음식의 스코빌 지수 * 2)Leo는 모든 음식의 스코빌 지수가 K 이상이 될 때까지 반복하여 섞습니다. Leo가 가진 음식의 스코빌 지수를 담은 배열 scoville과 원하는 스코빌 지수 K가 주어질 때, 모든 음식의 스코빌 지수를 K 이상으로 만들기 위해 섞어야 하는 최소 횟수를 return 하도록 solution 함수를 작성해주세요.</description>
    </item>
    
    <item>
      <title>[프로그래머스]124 나라의 숫자</title>
      <link>https://jyukki97.github.io/blog/2020-01-18-numbersof124countries/</link>
      <pubDate>Sat, 18 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-01-18-numbersof124countries/</guid>
      <description>https://programmers.co.kr
문제: 124 나라가 있습니다. 124 나라에서는 10진법이 아닌 다음과 같은 자신들만의 규칙으로 수를 표현합니다.
 124 나라에는 자연수만 존재합니다. 124 나라에는 모든 수를 표현할 때 1, 2, 4만 사용합니다.  예를 들어서 124 나라에서 사용하는 숫자는 다음과 같이 변환됩니다.
   10진법 124 나라 10진법 124 나라     1 1 6 14   2 2 7 21   3 4 8 22   4 11 9 24   5 12 10 41    자연수 n이 매개변수로 주어질 때, n을 124 나라에서 사용하는 숫자로 바꾼 값을 return 하도록 solution 함수를 완성해 주세요.</description>
    </item>
    
    <item>
      <title>[프로그래머스]쇠막대기</title>
      <link>https://jyukki97.github.io/blog/2020-01-17-ironbar/</link>
      <pubDate>Fri, 17 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-01-17-ironbar/</guid>
      <description>https://programmers.co.kr
문제: 여러 개의 쇠막대기를 레이저로 절단하려고 합니다. 효율적인 작업을 위해서 쇠막대기를 아래에서 위로 겹쳐 놓고, 레이저를 위에서 수직으로 발사하여 쇠막대기들을 자릅니다. 쇠막대기와 레이저의 배치는 다음 조건을 만족합니다.
- 쇠막대기는 자신보다 긴 쇠막대기 위에만 놓일 수 있습니다.- 쇠막대기를 다른 쇠막대기 위에 놓는 경우 완전히 포함되도록 놓되, 끝점은 겹치지 않도록 놓습니다.- 각 쇠막대기를 자르는 레이저는 적어도 하나 존재합니다.- 레이저는 어떤 쇠막대기의 양 끝점과도 겹치지 않습니다.아래 그림은 위 조건을 만족하는 예를 보여줍니다.</description>
    </item>
    
    <item>
      <title>[프로그래머스]탑</title>
      <link>https://jyukki97.github.io/blog/2020-01-16-tower/</link>
      <pubDate>Thu, 16 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-01-16-tower/</guid>
      <description>https://programmers.co.kr
문제: 수평 직선에 탑 N대를 세웠습니다. 모든 탑의 꼭대기에는 신호를 송/수신하는 장치를 설치했습니다. 발사한 신호는 신호를 보낸 탑보다 높은 탑에서만 수신합니다. 또한, 한 번 수신된 신호는 다른 탑으로 송신되지 않습니다.
예를 들어 높이가 6, 9, 5, 7, 4인 다섯 탑이 왼쪽으로 동시에 레이저 신호를 발사합니다. 그러면, 탑은 다음과 같이 신호를 주고받습니다. 높이가 4인 다섯 번째 탑에서 발사한 신호는 높이가 7인 네 번째 탑이 수신하고, 높이가 7인 네 번째 탑의 신호는 높이가 9인 두 번째 탑이, 높이가 5인 세 번째 탑의 신호도 높이가 9인 두 번째 탑이 수신합니다.</description>
    </item>
    
    <item>
      <title>[프로그래머스]저울</title>
      <link>https://jyukki97.github.io/blog/2020-01-15-scale/</link>
      <pubDate>Wed, 15 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-01-15-scale/</guid>
      <description>https://programmers.co.kr
문제: 하나의 양팔 저울을 이용하여 물건의 무게를 측정하려고 합니다. 이 저울의 양팔의 끝에는 물건이나 추를 올려놓는 접시가 달려 있고, 양팔의 길이는 같습니다. 또한, 저울의 한쪽에는 저울추들만 놓을 수 있고, 다른 쪽에는 무게를 측정하려는 물건만 올려놓을 수 있습니다.
저울추가 담긴 배열 weight가 매개변수로 주어질 때, 이 추들로 측정할 수 없는 양의 정수 무게 중 최솟값을 return 하도록 solution 함수를 작성해주세요.
예를 들어, 무게가 각각 [3, 1, 6, 2, 7, 30, 1]인 7개의 저울추를 주어졌을 때, 이 추들로 측정할 수 없는 양의 정수 무게 중 최솟값은 21입니다.</description>
    </item>
    
    <item>
      <title>[프로그래머스]문자열 내림차순으로 배치하기</title>
      <link>https://jyukki97.github.io/blog/2020-01-14-stringdescendingsort/</link>
      <pubDate>Tue, 14 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-01-14-stringdescendingsort/</guid>
      <description>https://programmers.co.kr
문제: 문자열 s에 나타나는 문자를 큰것부터 작은 순으로 정렬해 새로운 문자열을 리턴하는 함수, solution을 완성해주세요. s는 영문 대소문자로만 구성되어 있으며, 대문자는 소문자보다 작은 것으로 간주합니다.
풀이: 주어진 문자열을 내림차순으로 정렬한다.
코드: 사용언어 : c++
#include &amp;lt;string&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;string solution(string s) {sort(s.begin(), s.end(), greater&amp;lt;char&amp;gt;());return s;}</description>
    </item>
    
    <item>
      <title>[프로그래머스]모의고사</title>
      <link>https://jyukki97.github.io/blog/2020-01-13-mocktest/</link>
      <pubDate>Mon, 13 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-01-13-mocktest/</guid>
      <description>https://programmers.co.kr
문제: 수포자는 수학을 포기한 사람의 준말입니다. 수포자 삼인방은 모의고사에 수학 문제를 전부 찍으려 합니다. 수포자는 1번 문제부터 마지막 문제까지 다음과 같이 찍습니다.
1번 수포자가 찍는 방식: 1, 2, 3, 4, 5, 1, 2, 3, 4, 5, &amp;hellip; 2번 수포자가 찍는 방식: 2, 1, 2, 3, 2, 4, 2, 5, 2, 1, 2, 3, 2, 4, 2, 5, &amp;hellip; 3번 수포자가 찍는 방식: 3, 3, 1, 1, 2, 2, 4, 4, 5, 5, 3, 3, 1, 1, 2, 2, 4, 4, 5, 5, &amp;hellip;</description>
    </item>
    
    <item>
      <title>[프로그래머스]정수 삼각형</title>
      <link>https://jyukki97.github.io/blog/2020-01-12-inttriangle/</link>
      <pubDate>Sun, 12 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-01-12-inttriangle/</guid>
      <description>https://programmers.co.kr
문제: 위와 같은 삼각형의 꼭대기에서 바닥까지 이어지는 경로 중, 거쳐간 숫자의 합이 가장 큰 경우를 찾아보려고 합니다. 아래 칸으로 이동할 때는 대각선 방향으로 한 칸 오른쪽 또는 왼쪽으로만 이동 가능합니다. 예를 들어 3에서는 그 아래칸의 8 또는 1로만 이동이 가능합니다.
삼각형의 정보가 담긴 배열 triangle이 매개변수로 주어질 때, 거쳐간 숫자의 최댓값을 return 하도록 solution 함수를 완성하세요.
풀이: DP[i][t] : i 줄 t 위치에서의 최댓값
DP[i][t] = max(DP[i - 1][t - 1], DP[i - 1][t])</description>
    </item>
    
    <item>
      <title>[프로그래머스]타일 장식물</title>
      <link>https://jyukki97.github.io/blog/2020-01-11-tiledecoration/</link>
      <pubDate>Sat, 11 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-01-11-tiledecoration/</guid>
      <description>https://programmers.co.kr
문제: 대구 달성공원에 놀러 온 지수는 최근에 새로 만든 타일 장식물을 보게 되었다. 타일 장식물은 정사각형 타일을 붙여 만든 형태였는데, 한 변이 1인 정사각형 타일부터 시작하여 마치 앵무조개의 나선 모양처럼 점점 큰 타일을 붙인 형태였다. 타일 장식물의 일부를 그리면 다음과 같다.
그림에서 타일에 적힌 수는 각 타일의 한 변의 길이를 나타낸다. 타일 장식물을 구성하는 정사각형 타일 한 변의 길이를 안쪽 타일부터 시작하여 차례로 적으면 다음과 같다. [1, 1, 2, 3, 5, 8, .</description>
    </item>
    
    <item>
      <title>[프로그래머스]거스름돈</title>
      <link>https://jyukki97.github.io/blog/2020-01-10-change/</link>
      <pubDate>Fri, 10 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-01-10-change/</guid>
      <description>https://programmers.co.kr
문제: Finn은 편의점에서 야간 아르바이트를 하고 있습니다. 야간에 손님이 너무 없어 심심한 Finn은 손님들께 거스름돈을 n 원을 줄 때 방법의 경우의 수를 구하기로 하였습니다.
예를 들어서 손님께 5원을 거슬러 줘야 하고 1원, 2원, 5원이 있다면 다음과 같이 4가지 방법으로 5원을 거슬러 줄 수 있습니다.
 1원을 5개 사용해서 거슬러 준다. 1원을 3개 사용하고, 2원을 1개 사용해서 거슬러 준다. 1원을 1개 사용하고, 2원을 2개 사용해서 거슬러 준다. 5원을 1개 사용해서 거슬러 준다.</description>
    </item>
    
    <item>
      <title>[프로그래머스]기지국 설치</title>
      <link>https://jyukki97.github.io/blog/2020-01-09-setupstations/</link>
      <pubDate>Thu, 09 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-01-09-setupstations/</guid>
      <description>https://programmers.co.kr
문제: N개의 아파트가 일렬로 쭉 늘어서 있습니다. 이 중에서 일부 아파트 옥상에는 4g 기지국이 설치되어 있습니다. 기술이 발전해 5g 수요가 높아져 4g 기지국을 5g 기지국으로 바꾸려 합니다. 그런데 5g 기지국은 4g 기지국보다 전달 범위가 좁아, 4g 기지국을 5g 기지국으로 바꾸면 어떤 아파트에는 전파가 도달하지 않습니다.
예를 들어 11개의 아파트가 쭉 늘어서 있고, [4, 11] 번째 아파트 옥상에는 4g 기지국이 설치되어 있습니다. 만약 이 4g 기지국이 전파 도달 거리가 1인 5g 기지국으로 바뀔 경우 모든 아파트에 전파를 전달할 수 없습니다.</description>
    </item>
    
    <item>
      <title>[프로그래머스]최고의 집합</title>
      <link>https://jyukki97.github.io/blog/2020-01-08-bestset/</link>
      <pubDate>Wed, 08 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-01-08-bestset/</guid>
      <description>https://programmers.co.kr
문제: 자연수 n 개로 이루어진 중복 집합(multi set, 편의상 이후에는 집합으로 통칭) 중에 다음 두 조건을 만족하는 집합을 최고의 집합이라고 합니다.
 각 원소의 합이 S가 되는 수의 집합 위 조건을 만족하면서 각 원소의 곱 이 최대가 되는 집합  예를 들어서 자연수 2개로 이루어진 집합 중 합이 9가 되는 집합은 다음과 같이 4개가 있습니다. { 1, 8 }, { 2, 7 }, { 3, 6 }, { 4, 5 } 그중 각 원소의 곱이 최대인 { 4, 5 }가 최고의 집합입니다.</description>
    </item>
    
    <item>
      <title>[프로그래머스]숫자 게임</title>
      <link>https://jyukki97.github.io/blog/2020-01-07-numgame/</link>
      <pubDate>Tue, 07 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-01-07-numgame/</guid>
      <description>https://programmers.co.kr
문제: xx 회사의 2xN명의 사원들은 N명씩 두 팀으로 나눠 숫자 게임을 하려고 합니다. 두 개의 팀을 각각 A팀과 B팀이라고 하겠습니다. 숫자 게임의 규칙은 다음과 같습니다.
 먼저 모든 사원이 무작위로 자연수를 하나씩 부여받습니다. 각 사원은 딱 한 번씩 경기를 합니다. 각 경기당 A팀에서 한 사원이, B팀에서 한 사원이 나와 서로의 수를 공개합니다. 그때 숫자가 큰 쪽이 승리하게 되고, 승리한 사원이 속한 팀은 승점을 1점 얻게 됩니다. 만약 숫자가 같다면 누구도 승점을 얻지 않습니다.</description>
    </item>
    
    <item>
      <title>[프로그래머스]가장 긴 팰린드롬</title>
      <link>https://jyukki97.github.io/blog/2020-01-06-longestpalindrome/</link>
      <pubDate>Mon, 06 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-01-06-longestpalindrome/</guid>
      <description>https://programmers.co.kr
문제: 앞뒤를 뒤집어도 똑같은 문자열을 팰린드롬(palindrome)이라고 합니다. 문자열 s가 주어질 때, s의 부분문자열(Substring)중 가장 긴 팰린드롬의 길이를 return 하는 solution 함수를 완성해 주세요.
예를들면, 문자열 s가 abcdcba이면 7을 return하고 abacde이면 3을 return합니다.
풀이: Manacher&#39;s algorithm 을 이용한다.
코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;string&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;int p[5002];int solution(string s){string a = &amp;#34;#&amp;#34;;for (char i : s) {a += i;a += &amp;#34;#&amp;#34;;}int m = 0, ed = 0, answer = 0;for (int i = 1; i &amp;lt; a.</description>
    </item>
    
    <item>
      <title>[프로그래머스]등굣길</title>
      <link>https://jyukki97.github.io/blog/2020-01-05-waytoschool/</link>
      <pubDate>Sun, 05 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-01-05-waytoschool/</guid>
      <description>https://programmers.co.kr
문제: 계속되는 폭우로 일부 지역이 물에 잠겼습니다. 물에 잠기지 않은 지역을 통해 학교를 가려고 합니다. 집에서 학교까지 가는 길은 m x n 크기의 격자모양으로 나타낼 수 있습니다.
아래 그림은 m = 4, n = 3 인 경우입니다.
가장 왼쪽 위, 즉 집이 있는 곳의 좌표는 (1, 1)로 나타내고 가장 오른쪽 아래, 즉 학교가 있는 곳의 좌표는 (m, n)으로 나타냅니다.
격자의 크기 m, n과 물이 잠긴 지역의 좌표를 담은 2차원 배열 puddles이 매개변수로 주어집니다.</description>
    </item>
    
    <item>
      <title>[프로그래머스]이중우선순위큐</title>
      <link>https://jyukki97.github.io/blog/2020-01-04-priorityqueue/</link>
      <pubDate>Sat, 04 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-01-04-priorityqueue/</guid>
      <description>https://programmers.co.kr
문제: 이중 우선순위 큐는 다음 연산을 할 수 있는 자료구조를 말합니다.
   명령어 수신 탑(높이)     I 숫자 큐에 주어진 숫자를 삽입합니다.   D 1 큐에서 최댓값을 삭제합니다.   D -1 큐에서 최솟값을 삭제합니다.    이중 우선순위 큐가 할 연산 operations가 매개변수로 주어질 때, 모든 연산을 처리한 후 큐가 비어있으면 [0,0] 비어있지 않으면 [최댓값, 최솟값]을 return 하도록 solution 함수를 구현해주세요.</description>
    </item>
    
    <item>
      <title>[프로그래머스]2 X n 타일링</title>
      <link>https://jyukki97.github.io/blog/2020-01-03-2xntiling/</link>
      <pubDate>Fri, 03 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-01-03-2xntiling/</guid>
      <description>https://programmers.co.kr
문제: 가로 길이가 2이고 세로의 길이가 1인 직사각형모양의 타일이 있습니다. 이 직사각형 타일을 이용하여 세로의 길이가 2이고 가로의 길이가 n인 바닥을 가득 채우려고 합니다. 타일을 채울 때는 다음과 같이 2가지 방법이 있습니다.
 타일을 가로로 배치 하는 경우 타일을 세로로 배치 하는 경우  예를들어서 n이 7인 직사각형은 다음과 같이 채울 수 있습니다.
직사각형의 가로의 길이 n이 매개변수로 주어질 때, 이 직사각형을 채우는 방법의 수를 return 하는 solution 함수를 완성해주세요.</description>
    </item>
    
    <item>
      <title>[프로그래머스]x만큼 간격이 있는 n개의 숫자</title>
      <link>https://jyukki97.github.io/blog/2020-01-03-xgapnnum/</link>
      <pubDate>Fri, 03 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-01-03-xgapnnum/</guid>
      <description>https://programmers.co.kr
문제: 함수 solution은 정수 x와 자연수 n을 입력 받아, x부터 시작해 x씩 증가하는 숫자를 n개 지니는 리스트를 리턴해야 합니다. 다음 제한 조건을 보고, 조건을 만족하는 함수, solution을 완성해주세요.
풀이: x * 1, x *2&amp;hellip;., x * n 을 리턴한다.
코드: 사용언어 : c++
#include &amp;lt;string&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std;vector&amp;lt;long long&amp;gt; solution(int x, int n) {vector&amp;lt;long long&amp;gt; answer;for (int i = 1;i &amp;lt;= n;i++)answer.push_back(x * i);return answer;}</description>
    </item>
    
    <item>
      <title>[프로그래머스]네트워크</title>
      <link>https://jyukki97.github.io/blog/2020-01-03-network/</link>
      <pubDate>Fri, 03 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-01-03-network/</guid>
      <description>https://programmers.co.kr
문제: 네트워크란 컴퓨터 상호 간에 정보를 교환할 수 있도록 연결된 형태를 의미합니다. 예를 들어, 컴퓨터 A와 컴퓨터 B가 직접적으로 연결되어있고, 컴퓨터 B와 컴퓨터 C가 직접적으로 연결되어 있을 때 컴퓨터 A와 컴퓨터 C도 간접적으로 연결되어 정보를 교환할 수 있습니다. 따라서 컴퓨터 A, B, C는 모두 같은 네트워크 상에 있다고 할 수 있습니다.
컴퓨터의 개수 n, 연결에 대한 정보가 담긴 2차원 배열 computers가 매개변수로 주어질 때, 네트워크의 개수를 return 하도록 solution 함수를 작성하시오.</description>
    </item>
    
    <item>
      <title>[프로그래머스]비밀지도</title>
      <link>https://jyukki97.github.io/blog/2020-01-03-secretmap/</link>
      <pubDate>Fri, 03 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-01-03-secretmap/</guid>
      <description>https://programmers.co.kr
문제: 비밀지도 네오는 평소 프로도가 비상금을 숨겨놓는 장소를 알려줄 비밀지도를 손에 넣었다. 그런데 이 비밀지도는 숫자로 암호화되어 있어 위치를 확인하기 위해서는 암호를 해독해야 한다. 다행히 지도 암호를 해독할 방법을 적어놓은 메모도 함께 발견했다.
 지도는 한 변의 길이가 n인 정사각형 배열 형태로, 각 칸은 공백(&amp;rdquo; ) 또는벽(#&amp;quot;) 두 종류로 이루어져 있다. 전체 지도는 두 장의 지도를 겹쳐서 얻을 수 있다. 각각 지도 1과 지도 2라고 하자. 지도 1 또는 지도 2 중 어느 하나라도 벽인 부분은 전체 지도에서도 벽이다.</description>
    </item>
    
    <item>
      <title>[프로그래머스]실패율</title>
      <link>https://jyukki97.github.io/blog/2020-01-03-failurelate/</link>
      <pubDate>Fri, 03 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-01-03-failurelate/</guid>
      <description>https://programmers.co.kr
문제: 실패율 슈퍼 게임 개발자 오렐리는 큰 고민에 빠졌다. 그녀가 만든 프랜즈 오천성이 대성공을 거뒀지만, 요즘 신규 사용자의 수가 급감한 것이다. 원인은 신규 사용자와 기존 사용자 사이에 스테이지 차이가 너무 큰 것이 문제였다.
이 문제를 어떻게 할까 고민 한 그녀는 동적으로 게임 시간을 늘려서 난이도를 조절하기로 했다. 역시 슈퍼 개발자라 대부분의 로직은 쉽게 구현했지만, 실패율을 구하는 부분에서 위기에 빠지고 말았다. 오렐리를 위해 실패율을 구하는 코드를 완성하라.
 실패율은 다음과 같이 정의한다.</description>
    </item>
    
    <item>
      <title>[프로그래머스]예산</title>
      <link>https://jyukki97.github.io/blog/2020-01-03-budget/</link>
      <pubDate>Fri, 03 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-01-03-budget/</guid>
      <description>https://programmers.co.kr
문제: S사에서는 각 부서에 필요한 물품을 지원해 주기 위해 부서별로 물품을 구매하는데 필요한 금액을 조사했습니다. 그러나, 전체 예산이 정해져 있기 때문에 모든 부서의 물품을 구매해 줄 수는 없습니다. 그래서 최대한 많은 부서의 물품을 구매해 줄 수 있도록 하려고 합니다.
물품을 구매해 줄 때는 각 부서가 신청한 금액만큼을 모두 지원해 줘야 합니다. 예를 들어 1,000원을 신청한 부서에는 정확히 1,000원을 지원해야 하며, 1,000원보다 적은 금액을 지원해 줄 수는 없습니다.
부서별로 신청한 금액이 들어있는 배열 d와 예산 budget이 매개변수로 주어질 때, 최대 몇 개의 부서에 물품을 지원할 수 있는지 return 하도록 solution 함수를 완성해주세요.</description>
    </item>
    
    <item>
      <title>[프로그래머스]예산</title>
      <link>https://jyukki97.github.io/blog/2020-01-03-budget_level3/</link>
      <pubDate>Fri, 03 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-01-03-budget_level3/</guid>
      <description>https://programmers.co.kr
문제: 국가의 역할 중 하나는 여러 지방의 예산요청을 심사하여 국가의 예산을 분배하는 것입니다. 국가예산의 총액은 미리 정해져 있어서 모든 예산요청을 배정해 주기는 어려울 수도 있습니다. 그래서 정해진 총액 이하에서 가능한 한 최대의 총 예산을 다음과 같은 방법으로 배정합니다.
1. 모든 요청이 배정될 수 있는 경우에는 요청한 금액을 그대로 배정합니다.2. 모든 요청이 배정될 수 없는 경우에는 특정한 정수 상한액을 계산하여 그 이상인 예산요청에는 모두 상한액을 배정합니다. 상한액 이하의 예산요청에 대해서는 요청한 금액을 그대로 배정합니다.</description>
    </item>
    
    <item>
      <title>[프로그래머스]종이접기</title>
      <link>https://jyukki97.github.io/blog/2020-01-03-origami/</link>
      <pubDate>Fri, 03 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-01-03-origami/</guid>
      <description>https://programmers.co.kr
문제: 직사각형 종이를 n번 접으려고 합니다. 이때, 항상 오른쪽 절반을 왼쪽으로 접어 나갑니다. 다음은 n = 2인 경우의 예시입니다.
먼저 오른쪽 절반을 왼쪽으로 접습니다.
다시 오른쪽 절반을 왼쪽으로 접습니다.
종이를 모두 접은 후에는 종이를 전부 펼칩니다. 종이를 펼칠 때는 종이를 접은 방법의 역순으로 펼쳐서 처음 놓여있던 때와 같은 상태가 되도록 합니다. 위와 같이 두 번 접은 후 종이를 펼치면 아래 그림과 같이 종이에 접은 흔적이 생기게 됩니다.
위 그림에서 ∨ 모양이 생긴 부분은 점선(0)으로, ∧ 모양이 생긴 부분은 실선(1)으로 표시했습니다.</description>
    </item>
    
    <item>
      <title>[프로그래머스]JadenCase 문자열 만들기</title>
      <link>https://jyukki97.github.io/blog/2020-01-02-jadencasestring/</link>
      <pubDate>Thu, 02 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-01-02-jadencasestring/</guid>
      <description>https://programmers.co.kr
문제: JadenCase란 모든 단어의 첫 문자가 대문자이고, 그 외의 알파벳은 소문자인 문자열입니다. 문자열 s가 주어졌을 때, s를 JadenCase로 바꾼 문자열을 리턴하는 함수, solution을 완성해주세요.
풀이: [C++]대소문자, 숫자 구분함수  참고
모든 단어의 첫 문자가 대문자가 아니라면 대문자로 바꾼다.
첫 문자가 아니라면 소문자로 바꾼다.
코드: 사용언어 : c++
#include &amp;lt;string&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std;string solution(string s) {int c = 0;for (int i = 0;i &amp;lt; s.</description>
    </item>
    
    <item>
      <title>[프로그래머스]뉴스 클러스터링</title>
      <link>https://jyukki97.github.io/blog/2020-01-02-newsclustering/</link>
      <pubDate>Thu, 02 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-01-02-newsclustering/</guid>
      <description>https://programmers.co.kr
문제: 뉴스 클러스터링 여러 언론사에서 쏟아지는 뉴스, 특히 속보성 뉴스를 보면 비슷비슷한 제목의 기사가 많아 정작 필요한 기사를 찾기가 어렵다. Daum 뉴스의 개발 업무를 맡게 된 신입사원 튜브는 사용자들이 편리하게 다양한 뉴스를 찾아볼 수 있도록 문제점을 개선하는 업무를 맡게 되었다.
개발의 방향을 잡기 위해 튜브는 우선 최근 화제가 되고 있는 카카오 신입 개발자 공채 관련 기사를 검색해보았다.
 카카오 첫 공채..&amp;lsquo;블라인드&amp;rsquo; 방식 채용 카카오, 합병 후 첫 공채.. 블라인드 전형으로 개발자 채용 카카오, 블라인드 전형으로 신입 개발자 공채 카카오 공채, 신입 개발자 코딩 능력만 본다 카카오, 신입 공채.</description>
    </item>
    
    <item>
      <title>[프로그래머스]영어 끝말잇기</title>
      <link>https://jyukki97.github.io/blog/2020-01-02-engwordchain/</link>
      <pubDate>Thu, 02 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-01-02-engwordchain/</guid>
      <description>https://programmers.co.kr
문제: 1부터 n까지 번호가 붙어있는 n명의 사람이 영어 끝말잇기를 하고 있습니다. 영어 끝말잇기는 다음과 같은 규칙으로 진행됩니다.
 1번부터 번호 순서대로 한 사람씩 차례대로 단어를 말합니다. 마지막 사람이 단어를 말한 다음에는 다시 1번부터 시작합니다. 앞사람이 말한 단어의 마지막 문자로 시작하는 단어를 말해야 합니다. 이전에 등장했던 단어는 사용할 수 없습니다. 한 글자인 단어는 인정되지 않습니다.  다음은 3명이 끝말잇기를 하는 상황을 나타냅니다.
tank → kick → know → wheel → land → dream → mother → robot → tank</description>
    </item>
    
    <item>
      <title>[프로그래머스]정수 제곱근 판별</title>
      <link>https://jyukki97.github.io/blog/2020-01-02-distinguishsqrt/</link>
      <pubDate>Thu, 02 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-01-02-distinguishsqrt/</guid>
      <description>https://programmers.co.kr
문제: 임의의 양의 정수 n에 대해, n이 어떤 양의 정수 x의 제곱인지 아닌지 판단하려 합니다. n이 양의 정수 x의 제곱이라면 x+1의 제곱을 리턴하고, n이 양의 정수 x의 제곱이 아니라면 -1을 리턴하는 함수를 완성하세요.
풀이: 정수 n의 제곱근의 소수점을 버린 수를 a라 할때,
a * a 이 n 과 다르다면 n은 제곱근이 아니므로 -1 을 리턴, 같다면 (a + 1) * (a + 1) 을 리턴해준다.
코드: 사용언어 : c++</description>
    </item>
    
    <item>
      <title>[프로그래머스]짝수와 홀수</title>
      <link>https://jyukki97.github.io/blog/2020-01-02-oddandeven/</link>
      <pubDate>Thu, 02 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-01-02-oddandeven/</guid>
      <description>https://programmers.co.kr
문제: 정수 num이 짝수일 경우 Even을 반환하고 홀수인 경우 Odd를 반환하는 함수, solution을 완성해주세요.
풀이: 정수 num이 짝수면 &amp;ldquo;Even&amp;rdquo; 을 홀수라면 &amp;ldquo;Odd&amp;rdquo; 를 반환한다.
코드: 사용언어 : c++
#include &amp;lt;string&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std;string solution(int num) {return num % 2 ? &amp;#34;Odd&amp;#34; : &amp;#34;Even&amp;#34;;}</description>
    </item>
    
    <item>
      <title>[프로그래머스]콜라츠 추측</title>
      <link>https://jyukki97.github.io/blog/2020-01-02-collatzconjecture/</link>
      <pubDate>Thu, 02 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-01-02-collatzconjecture/</guid>
      <description>https://programmers.co.kr
문제: 1937년 Collatz란 사람에 의해 제기된 이 추측은, 주어진 수가 1이 될때까지 다음 작업을 반복하면, 모든 수를 1로 만들 수 있다는 추측입니다. 작업은 다음과 같습니다.
1-1. 입력된 수가 짝수라면 2로 나눕니다. 1-2. 입력된 수가 홀수라면 3을 곱하고 1을 더합니다.2. 결과로 나온 수에 같은 작업을 1이 될 때까지 반복합니다.예를 들어, 입력된 수가 6이라면 6→3→10→5→16→8→4→2→1 이 되어 총 8번 만에 1이 됩니다. 위 작업을 몇 번이나 반복해야하는지 반환하는 함수, solution을 완성해 주세요.</description>
    </item>
    
    <item>
      <title>[프로그래머스]평균 구하기</title>
      <link>https://jyukki97.github.io/blog/2020-01-02-average/</link>
      <pubDate>Thu, 02 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-01-02-average/</guid>
      <description>https://programmers.co.kr
문제: 정수를 담고 있는 배열 arr의 평균값을 return하는 함수, solution을 완성해보세요.
풀이: 배열 arr의 평균값을 리턴한다.
코드: 사용언어 : c++
#include &amp;lt;string&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std;double solution(vector&amp;lt;int&amp;gt; arr) {double answer = 0;for(int i : arr)answer += i;return answer / arr.size();}</description>
    </item>
    
    <item>
      <title>[프로그래머스]프렌즈4블록</title>
      <link>https://jyukki97.github.io/blog/2020-01-02-friends4block/</link>
      <pubDate>Thu, 02 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-01-02-friends4block/</guid>
      <description>https://programmers.co.kr
문제: 프렌즈4블록 블라인드 공채를 통과한 신입 사원 라이언은 신규 게임 개발 업무를 맡게 되었다. 이번에 출시할 게임 제목은 프렌즈4블록. 같은 모양의 카카오프렌즈 블록이 2×2 형태로 4개가 붙어있을 경우 사라지면서 점수를 얻는 게임이다.
만약 판이 위와 같이 주어질 경우, 라이언이 2×2로 배치된 7개 블록과 콘이 2×2로 배치된 4개 블록이 지워진다. 같은 블록은 여러 2×2에 포함될 수 있으며, 지워지는 조건에 만족하는 2×2 모양이 여러 개 있다면 한꺼번에 지워진다.
블록이 지워진 후에 위에 있는 블록이 아래로 떨어져 빈 공간을 채우게 된다.</description>
    </item>
    
    <item>
      <title>[프로그래머스]하샤드 수</title>
      <link>https://jyukki97.github.io/blog/2020-01-02-harshadnum/</link>
      <pubDate>Thu, 02 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-01-02-harshadnum/</guid>
      <description>https://programmers.co.kr
문제: 양의 정수 x가 하샤드 수이려면 x의 자릿수의 합으로 x가 나누어져야 합니다. 예를 들어 18의 자릿수 합은 1+8=9이고, 18은 9로 나누어 떨어지므로 18은 하샤드 수입니다. 자연수 x를 입력받아 x가 하샤드 수인지 아닌지 검사하는 함수, solution을 완성해주세요.
풀이: 정수 x의 각 자릿수의 합을 구한다.
정수 x를 구한 값으로 나누어 나머지가 0이라면 true를 0이 아니라면 false를 출력한다.
코드: 사용언어 : c++
#include &amp;lt;string&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std;bool solution(int x) {int c = 0;string a = to_string(x);for(char i : a)c += i - &amp;#39;0&amp;#39;;return !</description>
    </item>
    
    <item>
      <title>[프로그래머스]핸드폰 번호 가리기</title>
      <link>https://jyukki97.github.io/blog/2020-01-02-maskingphonenum/</link>
      <pubDate>Thu, 02 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-01-02-maskingphonenum/</guid>
      <description>https://programmers.co.kr
문제: 프로그래머스 모바일은 개인정보 보호를 위해 고지서를 보낼 때 고객들의 전화번호의 일부를 가립니다. 전화번호가 문자열 phone_number로 주어졌을 때, 전화번호의 뒷 4자리를 제외한 나머지 숫자를 전부 *으로 가린 문자열을 리턴하는 함수, solution을 완성해주세요.
풀이: 문자열 phone_number 의 뒤에 4자리를 제외한 나머지 숫자를 전부 &amp;lsquo;*&amp;rsquo; 로 바꾼 후 리턴한다.
코드: 사용언어 : c++
#include &amp;lt;string&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std;string solution(string phone_number) {for (int i = 0;i &amp;lt; phone_number.</description>
    </item>
    
    <item>
      <title>[프로그래머스]땅따먹기</title>
      <link>https://jyukki97.github.io/blog/2020-01-01-ttangttameokgi/</link>
      <pubDate>Wed, 01 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-01-01-ttangttameokgi/</guid>
      <description>https://programmers.co.kr
문제: 땅따먹기 게임을 하려고 합니다. 땅따먹기 게임의 땅(land)은 총 N행 4열로 이루어져 있고, 모든 칸에는 점수가 쓰여 있습니다. 1행부터 땅을 밟으며 한 행씩 내려올 때, 각 행의 4칸 중 한 칸만 밟으면서 내려와야 합니다. 단, 땅따먹기 게임에는 한 행씩 내려올 때, 같은 열을 연속해서 밟을 수 없는 특수 규칙이 있습니다.
예를 들면,
| 1 | 2 | 3 | 5 |
| 5 | 6 | 7 | 8 |</description>
    </item>
    
    <item>
      <title>[프로그래머스]숫자의 표현</title>
      <link>https://jyukki97.github.io/blog/2020-01-01-numexpression/</link>
      <pubDate>Wed, 01 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-01-01-numexpression/</guid>
      <description>https://programmers.co.kr
문제: Finn은 요즘 수학공부에 빠져 있습니다. 수학 공부를 하던 Finn은 자연수 n을 연속한 자연수들로 표현 하는 방법이 여러개라는 사실을 알게 되었습니다. 예를들어 15는 다음과 같이 4가지로 표현 할 수 있습니다.
 1 + 2 + 3 + 4 + 5 = 15 4 + 5 + 6 = 15 7 + 8 = 15 15 = 15  자연수 n이 매개변수로 주어질 때, 연속된 자연수들로 n을 표현하는 방법의 수를 return하는 solution를 완성해주세요.</description>
    </item>
    
    <item>
      <title>[프로그래머스]짝지어 제거하기</title>
      <link>https://jyukki97.github.io/blog/2020-01-01-removemating/</link>
      <pubDate>Wed, 01 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-01-01-removemating/</guid>
      <description>https://programmers.co.kr
문제: 짝지어 제거하기는, 알파벳 소문자로 이루어진 문자열을 가지고 시작합니다. 먼저 문자열에서 같은 알파벳이 2개 붙어 있는 짝을 찾습니다. 그다음, 그 둘을 제거한 뒤, 앞뒤로 문자열을 이어 붙입니다. 이 과정을 반복해서 문자열을 모두 제거한다면 짝지어 제거하기가 종료됩니다. 문자열 S가 주어졌을 때, 짝지어 제거하기를 성공적으로 수행할 수 있는지 반환하는 함수를 완성해 주세요. 성공적으로 수행할 수 있으면 1을, 아닐 경우 0을 리턴해주면 됩니다.
예를 들어, 문자열 S = baabaa 라면
b aa baa → bb aa → aa →</description>
    </item>
    
    <item>
      <title>[프로그래머스]N개의 최소공배수</title>
      <link>https://jyukki97.github.io/blog/2019-12-31-nlcm/</link>
      <pubDate>Tue, 31 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-12-31-nlcm/</guid>
      <description>https://programmers.co.kr
문제: 두 수의 최소공배수(Least Common Multiple)란 입력된 두 수의 배수 중 공통이 되는 가장 작은 숫자를 의미합니다. 예를 들어 2와 7의 최소공배수는 14가 됩니다. 정의를 확장해서, n개의 수의 최소공배수는 n 개의 수들의 배수 중 공통이 되는 가장 작은 숫자가 됩니다. n개의 숫자를 담은 배열 arr이 입력되었을 때 이 수들의 최소공배수를 반환하는 함수, solution을 완성해 주세요.
풀이: 최소공배수를 answer이라 할때,
answer과 arr를 차례대로 최소공배수를 구해 anwer에 값에 넣는다.
코드: 사용언어 : c++</description>
    </item>
    
    <item>
      <title>[프로그래머스]최대공약수와 최소공배수</title>
      <link>https://jyukki97.github.io/blog/2019-12-31-gcdandlcm/</link>
      <pubDate>Tue, 31 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-12-31-gcdandlcm/</guid>
      <description>https://programmers.co.kr
문제: 두 수를 입력받아 두 수의 최대공약수와 최소공배수를 반환하는 함수, solution을 완성해 보세요. 배열의 맨 앞에 최대공약수, 그다음 최소공배수를 넣어 반환하면 됩니다. 예를 들어 두 수 3, 12의 최대공약수는 3, 최소공배수는 12이므로 solution(3, 12)는 [3, 12]를 반환해야 합니다.
풀이: 최대공약수를 구한다.
최소공배수는 두 수에 곱에서 최대공약수를 나눈 값이 된다.
코드: 사용언어 : c++
#include &amp;lt;string&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std;vector&amp;lt;int&amp;gt; solution(int n, int m) {vector&amp;lt;int&amp;gt; answer;int a = n &amp;gt; m ?</description>
    </item>
    
    <item>
      <title>[프로그래머스]최댓값과 최솟값</title>
      <link>https://jyukki97.github.io/blog/2019-12-31-maximumandminimum/</link>
      <pubDate>Tue, 31 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-12-31-maximumandminimum/</guid>
      <description>https://programmers.co.kr
문제: 문자열 s에는 공백으로 구분된 숫자들이 저장되어 있습니다. str에 나타나는 숫자 중 최소값과 최대값을 찾아 이를 (최소값) (최대값)형태의 문자열을 반환하는 함수, solution을 완성하세요. 예를들어 s가 1 2 3 4라면 1 4를 리턴하고, -1 -2 -3 -4라면 -4 -1을 리턴하면 됩니다.
풀이: 공백 문자로 구분된 문자열을 배열안에 구분해서 넣는다.
나눠진 배열을 int 형으로 정렬한다. (string 형으로 정렬할 경우 사전순으로 정렬되기 때문에 안된다.)
배열에 맨 처음값과 마지막값을 리턴해준다.
코드: 사용언어 : c++</description>
    </item>
    
    <item>
      <title>[프로그래머스]최솟값 만들기</title>
      <link>https://jyukki97.github.io/blog/2019-12-31-makeminimum/</link>
      <pubDate>Tue, 31 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-12-31-makeminimum/</guid>
      <description>https://programmers.co.kr
문제: 길이가 같은 배열 A, B 두개가 있습니다. 각 배열은 자연수로 이루어져 있습니다. 배열 A, B에서 각각 한 개의 숫자를 뽑아 두 수를 곱합니다. 이러한 과정을 배열의 길이만큼 반복하며, 두 수를 곱한 값을 누적하여 더합니다. 이때 최종적으로 누적된 값이 최소가 되도록 만드는 것이 목표입니다. (단, 각 배열에서 k번째 숫자를 뽑았다면 다음에 k번째 숫자는 다시 뽑을 수 없습니다.)
예를 들어 A = [1, 4, 2] , B = [5, 4, 4] 라면</description>
    </item>
    
    <item>
      <title>[프로그래머스]피보나치 수</title>
      <link>https://jyukki97.github.io/blog/2019-12-31-fibonaccinum/</link>
      <pubDate>Tue, 31 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-12-31-fibonaccinum/</guid>
      <description>https://programmers.co.kr
문제: 피보나치 수는 F(0) = 0, F(1) = 1일 때, 1 이상의 n에 대하여 F(n) = F(n-1) + F(n-2) 가 적용되는 수 입니다.
예를들어
 F(2) = F(0) + F(1) = 0 + 1 = 1 F(3) = F(1) + F(2) = 1 + 1 = 2 F(4) = F(2) + F(3) = 1 + 2 = 3 F(5) = F(3) + F(4) = 2 + 3 = 5  와 같이 이어집니다.</description>
    </item>
    
    <item>
      <title>[프로그래머스]가장 큰 정사각형 찾기</title>
      <link>https://jyukki97.github.io/blog/2019-12-30-findbigestractangle/</link>
      <pubDate>Mon, 30 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-12-30-findbigestractangle/</guid>
      <description>https://programmers.co.kr
문제: 1와 0로 채워진 표(board)가 있습니다. 표 1칸은 1 x 1 의 정사각형으로 이루어져 있습니다. 표에서 1로 이루어진 가장 큰 정사각형을 찾아 넓이를 return 하는 solution 함수를 완성해 주세요. (단, 정사각형이란 축에 평행한 정사각형을 말합니다.)
예를 들어
   1 2 3 4     0 1 1 1   1 1 1 1   1 1 1 1   0 0 1 0    가 있다면 가장 큰 정사각형은</description>
    </item>
    
    <item>
      <title>[프로그래머스]올바른 괄호</title>
      <link>https://jyukki97.github.io/blog/2019-12-30-correctpare/</link>
      <pubDate>Mon, 30 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-12-30-correctpare/</guid>
      <description>https://programmers.co.kr
문제: 괄호가 바르게 짝지어졌다는 것은 &amp;lsquo;(&amp;rsquo; 문자로 열렸으면 반드시 짝지어서 &amp;lsquo;)&amp;rsquo; 문자로 닫혀야 한다는 뜻입니다. 예를 들어
 ()() 또는 (())() 는 올바른 괄호입니다. )()( 또는 (()( 는 올바르지 않은 괄호입니다.  &amp;lsquo;(&amp;rsquo; 또는 &amp;lsquo;)&amp;rsquo; 로만 이루어진 문자열 s가 주어졌을 때, 문자열 s가 올바른 괄호이면 true를 return 하고, 올바르지 않은 괄호이면 false를 return 하는 solution 함수를 완성해 주세요.
풀이: 스택이 비었거나 &amp;lsquo;(&amp;rsquo; 가 나온다면 스택에 push()
둘 다 아니면서 스택에 맨 위값이 &amp;lsquo;(&amp;rsquo; 라면 pop()</description>
    </item>
    
    <item>
      <title>[프로그래머스]카펫</title>
      <link>https://jyukki97.github.io/blog/2019-12-30-carpet/</link>
      <pubDate>Mon, 30 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-12-30-carpet/</guid>
      <description>https://programmers.co.kr
문제: Leo는 카펫을 사러 갔다가 아래 그림과 같이 중앙에는 빨간색으로 칠해져 있고 모서리는 갈색으로 칠해져 있는 격자 모양 카펫을 봤습니다.
Leo는 집으로 돌아와서 아까 본 카펫의 빨간색과 갈색으로 색칠된 격자의 개수는 기억했지만, 전체 카펫의 크기는 기억하지 못했습니다.
Leo가 본 카펫에서 갈색 격자의 수 brown, 빨간색 격자의 수 red가 매개변수로 주어질 때 카펫의 가로, 세로 크기를 순서대로 배열에 담아 return 하도록 solution 함수를 작성해주세요.
풀이: 완전탐색 brown + red 인 사각형을 만족하는 모든 가로 * 세로 중에서 red를 만족하는 가로, 세로값을 찾는다.</description>
    </item>
    
    <item>
      <title>[프로그래머스]타겟 넘버</title>
      <link>https://jyukki97.github.io/blog/2019-12-30-targetnum/</link>
      <pubDate>Mon, 30 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-12-30-targetnum/</guid>
      <description>https://programmers.co.kr
문제: n개의 음이 아닌 정수가 있습니다. 이 수를 적절히 더하거나 빼서 타겟 넘버를 만들려고 합니다. 예를 들어 [1, 1, 1, 1, 1]로 숫자 3을 만들려면 다음 다섯 방법을 쓸 수 있습니다.
-1+1+1+1+1 = 3+1-1+1+1+1 = 3+1+1-1+1+1 = 3+1+1+1-1+1 = 3+1+1+1+1-1 = 3사용할 수 있는 숫자가 담긴 배열 numbers, 타겟 넘버 target이 매개변수로 주어질 때 숫자를 적절히 더하고 빼서 타겟 넘버를 만드는 방법의 수를 return 하도록 solution 함수를 작성해주세요.</description>
    </item>
    
    <item>
      <title>[프로그래머스]숫자 야구</title>
      <link>https://jyukki97.github.io/blog/2019-12-29-numbaseball/</link>
      <pubDate>Sun, 29 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-12-29-numbaseball/</guid>
      <description>https://programmers.co.kr
문제: 숫자 야구 게임이란 2명이 서로가 생각한 숫자를 맞추는 게임입니다. 게임해보기
각자 서로 다른 1~9까지 3자리 임의의 숫자를 정한 뒤 서로에게 3자리의 숫자를 불러서 결과를 확인합니다. 그리고 그 결과를 토대로 상대가 정한 숫자를 예상한 뒤 맞힙니다.
* 숫자는 맞지만, 위치가 틀렸을 때는 볼* 숫자와 위치가 모두 맞을 때는 스트라이크* 숫자와 위치가 모두 틀렸을 때는 아웃예를 들어, 아래의 경우가 있으면
A : 123B : 1스트라이크 1볼.A : 356B : 1스트라이크 0볼.</description>
    </item>
    
    <item>
      <title>[프로그래머스]위장</title>
      <link>https://jyukki97.github.io/blog/2019-12-29-camouflage/</link>
      <pubDate>Sun, 29 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-12-29-camouflage/</guid>
      <description>https://programmers.co.kr
문제: 스파이들은 매일 다른 옷을 조합하여 입어 자신을 위장합니다.
예를 들어 스파이가 가진 옷이 아래와 같고 오늘 스파이가 동그란 안경, 긴 코트, 파란색 티셔츠를 입었다면 다음날은 청바지를 추가로 입거나 동그란 안경 대신 검정 선글라스를 착용하거나 해야 합니다.
   종류 이름     얼굴 동그란 안경, 검정 선글라스   상의 파란색 티셔츠   하의 청바지   겉옷 긴 코트    스파이가 가진 의상들이 담긴 2차원 배열 clothes가 주어질 때 서로 다른 옷의 조합의 수를 return 하도록 solution 함수를 작성해주세요.</description>
    </item>
    
    <item>
      <title>[프로그래머스]전화번호 목록</title>
      <link>https://jyukki97.github.io/blog/2019-12-28-phonebooklist/</link>
      <pubDate>Sat, 28 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-12-28-phonebooklist/</guid>
      <description>https://programmers.co.kr
문제: 전화번호부에 적힌 전화번호 중, 한 번호가 다른 번호의 접두어인 경우가 있는지 확인하려 합니다. 전화번호가 다음과 같을 경우, 구조대 전화번호는 영석이의 전화번호의 접두사입니다.
 구조대 : 119 박준영 : 97 674 223 지영석 : 11 9552 4421  전화번호부에 적힌 전화번호를 담은 배열 phone_book 이 solution 함수의 매개변수로 주어질 때, 어떤 번호가 다른 번호의 접두어인 경우가 있으면 false를 그렇지 않으면 true를 return 하도록 solution 함수를 작성해주세요.
풀이: phone_book 에 있는 전화번호들을 사전순으로 정렬해 놓는다.</description>
    </item>
    
    <item>
      <title>[프로그래머스]큰 수 만들기</title>
      <link>https://jyukki97.github.io/blog/2019-12-28-makebignum/</link>
      <pubDate>Sat, 28 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-12-28-makebignum/</guid>
      <description>https://programmers.co.kr
문제: 어떤 숫자에서 k개의 수를 제거했을 때 얻을 수 있는 가장 큰 숫자를 구하려 합니다.
예를 들어, 숫자 1924에서 수 두 개를 제거하면 [19, 12, 14, 92, 94, 24] 를 만들 수 있습니다. 이 중 가장 큰 숫자는 94 입니다.
문자열 형식으로 숫자 number와 제거할 수의 개수 k가 solution 함수의 매개변수로 주어집니다. number에서 k 개의 수를 제거했을 때 만들 수 있는 수 중 가장 큰 숫자를 문자열 형태로 return 하도록 solution 함수를 완성하세요.</description>
    </item>
    
    <item>
      <title>[프로그래머스]멀쩡한 사각형</title>
      <link>https://jyukki97.github.io/blog/2019-12-27-intactractangle/</link>
      <pubDate>Fri, 27 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-12-27-intactractangle/</guid>
      <description>https://programmers.co.kr
문제: 가로 길이가 Wcm, 세로 길이가 Hcm인 직사각형 종이가 있습니다. 종이에는 가로, 세로 방향과 평행하게 격자 형태로 선이 그어져 있으며, 모든 격자칸은 1cm x 1cm 크기입니다. 이 종이를 격자 선을 따라 1cm × 1cm의 정사각형으로 잘라 사용할 예정이었는데, 누군가가 이 종이를 대각선 꼭지점 2개를 잇는 방향으로 잘라 놓았습니다. 그러므로 현재 직사각형 종이는 크기가 같은 직각삼각형 2개로 나누어진 상태입니다. 새로운 종이를 구할 수 없는 상태이기 때문에, 이 종이에서 원래 종이의 가로, 세로 방향과 평행하게 1cm × 1cm로 잘라 사용할 수 있는 만큼만 사용하기로 하였습니다.</description>
    </item>
    
    <item>
      <title>[프로그래머스]주식가격</title>
      <link>https://jyukki97.github.io/blog/2019-12-27-stockprice/</link>
      <pubDate>Fri, 27 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-12-27-stockprice/</guid>
      <description>https://programmers.co.kr
문제: 초 단위로 기록된 주식가격이 담긴 배열 prices가 매개변수로 주어질 때, 가격이 떨어지지 않은 기간은 몇 초인지를 return 하도록 solution 함수를 완성하세요.
풀이: 초 단위로 시간을 흘러가게 한 후 주식가격이 떨어지면 그 시간을 기록하여 answer에 저장한다.
코드: 사용언어 : c++
#include &amp;lt;string&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std;vector&amp;lt;int&amp;gt; solution(vector&amp;lt;int&amp;gt; prices) {vector&amp;lt;int&amp;gt; answer;for (int i = 0;i &amp;lt; prices.size();i++) {answer.push_back(0);for (int t = i + 1;t &amp;lt; prices.</description>
    </item>
    
    <item>
      <title>[프로그래머스]프린터</title>
      <link>https://jyukki97.github.io/blog/2019-12-27-printer/</link>
      <pubDate>Fri, 27 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-12-27-printer/</guid>
      <description>https://programmers.co.kr
문제: 일반적인 프린터는 인쇄 요청이 들어온 순서대로 인쇄합니다. 그렇기 때문에 중요한 문서가 나중에 인쇄될 수 있습니다. 이런 문제를 보완하기 위해 중요도가 높은 문서를 먼저 인쇄하는 프린터를 개발했습니다. 이 새롭게 개발한 프린터는 아래와 같은 방식으로 인쇄 작업을 수행합니다.
1. 인쇄 대기목록의 가장 앞에 있는 문서(J)를 대기목록에서 꺼냅니다.2. 나머지 인쇄 대기목록에서 J보다 중요도가 높은 문서가 한 개라도 존재하면 J를 대기목록의 가장 마지막에 넣습니다.3. 그렇지 않으면 J를 인쇄합니다.예를 들어, 4개의 문서(A, B, C, D)가 순서대로 인쇄 대기목록에 있고 중요도가 2 1 3 2 라면 C D A B 순으로 인쇄하게 됩니다.</description>
    </item>
    
    <item>
      <title>[프로그래머스]기능개발</title>
      <link>https://jyukki97.github.io/blog/2019-12-26-fdevelopment/</link>
      <pubDate>Thu, 26 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-12-26-fdevelopment/</guid>
      <description>https://programmers.co.kr
문제: 프로그래머스 팀에서는 기능 개선 작업을 수행 중입니다. 각 기능은 진도가 100%일 때 서비스에 반영할 수 있습니다.
또, 각 기능의 개발속도는 모두 다르기 때문에 뒤에 있는 기능이 앞에 있는 기능보다 먼저 개발될 수 있고, 이때 뒤에 있는 기능은 앞에 있는 기능이 배포될 때 함께 배포됩니다.
먼저 배포되어야 하는 순서대로 작업의 진도가 적힌 정수 배열 progresses와 각 작업의 개발 속도가 적힌 정수 배열 speeds가 주어질 때 각 배포마다 몇 개의 기능이 배포되는지를 return 하도록 solution 함수를 완성하세요.</description>
    </item>
    
    <item>
      <title>[프로그래머스]다리를 지나는 트럭</title>
      <link>https://jyukki97.github.io/blog/2019-12-26-bridgetruck/</link>
      <pubDate>Thu, 26 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-12-26-bridgetruck/</guid>
      <description>https://programmers.co.kr
문제: 트럭 여러 대가 강을 가로지르는 일 차선 다리를 정해진 순으로 건너려 합니다. 모든 트럭이 다리를 건너려면 최소 몇 초가 걸리는지 알아내야 합니다. 트럭은 1초에 1만큼 움직이며, 다리 길이는 bridge_length이고 다리는 무게 weight까지 견딥니다. ※ 트럭이 다리에 완전히 오르지 않은 경우, 이 트럭의 무게는 고려하지 않습니다.
예를 들어, 길이가 2이고 10kg 무게를 견디는 다리가 있습니다. 무게가 [7, 4, 5, 6]kg인 트럭이 순서대로 최단 시간 안에 다리를 건너려면 다음과 같이 건너야 합니다.</description>
    </item>
    
    <item>
      <title>[프로그래머스]스킬트리</title>
      <link>https://jyukki97.github.io/blog/2019-12-26-skilltree/</link>
      <pubDate>Thu, 26 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-12-26-skilltree/</guid>
      <description>https://programmers.co.kr
문제: 선행 스킬이란 어떤 스킬을 배우기 전에 먼저 배워야 하는 스킬을 뜻합니다.
예를 들어 선행 스킬 순서가 스파크 → 라이트닝 볼트 → 썬더일때, 썬더를 배우려면 먼저 라이트닝 볼트를 배워야 하고, 라이트닝 볼트를 배우려면 먼저 스파크를 배워야 합니다.
위 순서에 없는 다른 스킬(힐링 등)은 순서에 상관없이 배울 수 있습니다. 따라서 스파크 → 힐링 → 라이트닝 볼트 → 썬더와 같은 스킬트리는 가능하지만, 썬더 → 스파크나 라이트닝 볼트 → 스파크 → 힐링 → 썬더와 같은 스킬트리는 불가능합니다.</description>
    </item>
    
    <item>
      <title>[프로그래머스]자연수 뒤집어 배열로 만들기</title>
      <link>https://jyukki97.github.io/blog/2019-12-25-turnnnum/</link>
      <pubDate>Wed, 25 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-12-25-turnnnum/</guid>
      <description>https://programmers.co.kr
풀이:  자연수 n을 뒤집어 각 자리 숫자를 원소로 가지는 배열을 리턴한다.  코드: 사용언어 : c++
#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;stdbool.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt;int* solution(long long n) {// 리턴할 값은 메모리를 동적 할당해주세요. int* answer = (int*)malloc(sizeof(int)*12 + 1);int c = 0;while (n) {answer[c] = n % 10;n /= 10;c++;}return answer;}</description>
    </item>
    
    <item>
      <title>[프로그래머스]자릿수 더하기</title>
      <link>https://jyukki97.github.io/blog/2019-12-24-sumpnum/</link>
      <pubDate>Tue, 24 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-12-24-sumpnum/</guid>
      <description>https://programmers.co.kr
풀이:  자연수 n의 각 자릿수의 합을 구해서 리턴한다.  코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;using namespace std;int solution(int n){int answer = 0;while (n != 0) {answer += n % 10;n /= 10;}return answer;}</description>
    </item>
    
    <item>
      <title>[프로그래머스]이상한 문자 만들기</title>
      <link>https://jyukki97.github.io/blog/2019-12-23-strangestring/</link>
      <pubDate>Mon, 23 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-12-23-strangestring/</guid>
      <description>https://programmers.co.kr
문제: 문자열 s는 한 개 이상의 단어로 구성되어 있습니다. 각 단어는 하나 이상의 공백문자로 구분되어 있습니다. 각 단어의 짝수번째 알파벳은 대문자로, 홀수번째 알파벳은 소문자로 바꾼 문자열을 리턴하는 함수, solution을 완성하세요.
풀이:  문자열 전체의 짝/홀수 인덱스가 아니라 각 단어 기준이므로 주의한다. 공백문자가 하나가 아닐 수도 있으므로 주의한다. 공백문자를 기준으로 단어를 나누므로, 공백문자가 나왔을 경우 카운트를 초기화하는 식으로 문자열을 나눈다.  코드: 사용언어 : c++
#include &amp;lt;string&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std;string solution(string s) {int c = 0;for (int i = 0;i &amp;lt; s.</description>
    </item>
    
    <item>
      <title>[프로그래머스]두 정수 사이의 합</title>
      <link>https://jyukki97.github.io/blog/2019-12-22-sumnums/</link>
      <pubDate>Sun, 22 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-12-22-sumnums/</guid>
      <description>https://programmers.co.kr
풀이:  두 수 a, b 사이에 속한 모든 정수의 합을 리턴한다. a와 b는 -10,000,000 이상 10,000,000 이하인 정수 이므로 주의한다. a와 b의 대소관계가 정해져 있지 않으므로 절댓값을 이용한다.  코드: 사용언어 : c++
#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;stdbool.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt;long long solution(int a, int b) {long long answer = ((long)a + (long)b) * (abs((long)b - (long)a) + 1) / 2;return answer;}</description>
    </item>
    
    <item>
      <title>[프로그래머스]약수의 합</title>
      <link>https://jyukki97.github.io/blog/2019-12-22-sumdivisor/</link>
      <pubDate>Sun, 22 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-12-22-sumdivisor/</guid>
      <description>https://programmers.co.kr
풀이:  정수 n의 모든 약수의 합을 리턴한다.  코드: 사용언어 : c++
#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;stdbool.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt;int solution(int n) {int answer = 0;for (int i = 1;i &amp;lt;= n;i++)if (n % i == 0)answer += i;return answer;}</description>
    </item>
    
    <item>
      <title>[프로그래머스]가운데 글자 가져오기</title>
      <link>https://jyukki97.github.io/blog/2019-12-21-middlenum/</link>
      <pubDate>Sat, 21 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-12-21-middlenum/</guid>
      <description>https://programmers.co.kr
풀이:  문자열 s의 가운데 글자를 리턴한다. 만약 문자열 s의 길이가 짝수라면 가운데 두 글자를 반환한다  코드: 사용언어 : c++
#include &amp;lt;string&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std;string solution(string s) {string answer;if (s.length() % 2 == 0) {answer = s[s.length() / 2 - 1];answer += s[s.length() / 2];}else {answer = s[s.length() / 2];}return answer;}</description>
    </item>
    
    <item>
      <title>[프로그래머스]시저 암호</title>
      <link>https://jyukki97.github.io/blog/2019-12-21-caesarcipher/</link>
      <pubDate>Sat, 21 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-12-21-caesarcipher/</guid>
      <description>https://programmers.co.kr
풀이:  문자열 s를 n만큼 밀어서 나온 다른 알파벳의 결과값을 리턴한다. 중간에 공백문자가 있을 수 있으니 주의한다. &amp;lsquo;z&#39;를 밀 경우 &amp;lsquo;A&#39;가 아니라 &amp;lsquo;a&#39;가 나와야 하므로 주의한다.  코드: 사용언어 : c++
#include &amp;lt;string&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std;string solution(string s, int n) {for (int i = 0;i &amp;lt; s.size();i++) {if (isalpha(s[i])) {if (s[i] + n &amp;gt; &amp;#39;z&amp;#39;) {s[i] = 96 + (s[i] + n) % &amp;#39;z&amp;#39;;}else if (s[i] &amp;lt;= &amp;#39;Z&amp;#39; &amp;amp;&amp;amp; s[i] + n &amp;gt; &amp;#39;Z&amp;#39;) {s[i] = 64 + (s[i] + n) % &amp;#39;Z&amp;#39;;}elses[i] += n;}}return s;}</description>
    </item>
    
    <item>
      <title>[프로그래머스]나누어 떨어지는 숫자 배열</title>
      <link>https://jyukki97.github.io/blog/2019-12-20-dividednum/</link>
      <pubDate>Fri, 20 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-12-20-dividednum/</guid>
      <description>https://programmers.co.kr
풀이:  arr의 각 원소 중 divisor로 나누어 떨어지는 값을 오름차순으로 정렬한 배열을 리턴한다. 만약 배열의 원소가 없다면 -1을 리턴한다.  코드: 사용언어 : c++
#include &amp;lt;string&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;vector&amp;lt;int&amp;gt; solution(vector&amp;lt;int&amp;gt; arr, int divisor) {vector&amp;lt;int&amp;gt; answer;for (int i : arr) {if (i % divisor == 0)answer.push_back(i);}sort(answer.begin(), answer.end());if(answer.size()==0)answer.push_back(-1);return answer;}</description>
    </item>
    
    <item>
      <title>[프로그래머스]문자열을 정수로 바꾸기</title>
      <link>https://jyukki97.github.io/blog/2019-12-20-stoi/</link>
      <pubDate>Fri, 20 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-12-20-stoi/</guid>
      <description>https://programmers.co.kr
풀이:  문자열 s를 숫자로 변환한 결과를 리턴한다.  코드: 사용언어 : c++
#include &amp;lt;string&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std;int solution(string s) {int answer = stoi(s);return answer;}</description>
    </item>
    
    <item>
      <title>[프로그래머스]같은 숫자는 싫어</title>
      <link>https://jyukki97.github.io/blog/2019-12-19-samesum/</link>
      <pubDate>Thu, 19 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-12-19-samesum/</guid>
      <description>https://programmers.co.kr
풀이:  배열 arr에서 연속적인 숫자는 하나를 제외하고 모두 삭제한 배열을 리턴한다.  코드: 사용언어 : c++
#include &amp;lt;vector&amp;gt;#include &amp;lt;iostream&amp;gt;using namespace std;vector&amp;lt;int&amp;gt; solution(vector&amp;lt;int&amp;gt; arr) {vector&amp;lt;int&amp;gt; answer;for (int i : arr) {if (answer.size() &amp;gt; 0) {if (answer.back() != i) {answer.push_back(i);}}else {answer.push_back(i);}}return answer;}</description>
    </item>
    
    <item>
      <title>[프로그래머스]소수 찾기</title>
      <link>https://jyukki97.github.io/blog/2019-12-19-findpnum/</link>
      <pubDate>Thu, 19 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-12-19-findpnum/</guid>
      <description>https://programmers.co.kr
풀이:  2이상 n이하의 수들 중 소수의 갯수를 구하여 출력한다.  코드: 사용언어 : c++
#include &amp;lt;string&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;math.h&amp;gt;using namespace std;int solution(int n) {vector&amp;lt;int&amp;gt; q = { 2 };for (int i = 3;i &amp;lt;= n;i++) {bool w = true;for (int t : q) {if (t &amp;gt; sqrt(i)) {break;}if (i % t == 0) {w = false;break;}}if (w == true) {q.</description>
    </item>
    
    <item>
      <title>[프로그래머스]수박수박수박수박수박수?</title>
      <link>https://jyukki97.github.io/blog/2019-12-19-subaksubak/</link>
      <pubDate>Thu, 19 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-12-19-subaksubak/</guid>
      <description>https://programmers.co.kr
풀이:  &amp;ldquo;수박수박수&amp;hellip;&amp;rdquo; 의 패턴을 유지하는 n만큼의 길이의 문자열을 리턴한다.  코드: 사용언어 : c++
#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;stdbool.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt;#include &amp;lt;string.h&amp;gt;char* solution(int n) {bool c = true;char a[] = &amp;#34;수&amp;#34;;char b[] = &amp;#34;박&amp;#34;;char* answer = (char*)malloc(sizeof(char)*3*n + 1);for (int i = 0;i &amp;lt; 3*n;i+=3) {if (c) {strcpy(answer + i, a);c = false;}else {strcpy(answer + i, b);c = true;}}return answer;}</description>
    </item>
    
    <item>
      <title>[프로그래머스]서울에서 김서방 찾기</title>
      <link>https://jyukki97.github.io/blog/2019-12-18-findkim/</link>
      <pubDate>Wed, 18 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-12-18-findkim/</guid>
      <description>https://programmers.co.kr
풀이:  string 배열 seoul의 원소 중 &amp;ldquo;Kim&amp;quot;의 위치를 찾아 반환한다.  코드: 사용언어 : c++
#include &amp;lt;string&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std;string solution(vector&amp;lt;string&amp;gt; seoul) {for (int i = 0;i &amp;lt; seoul.size();i++)if (seoul[i] == &amp;#34;Kim&amp;#34;)return &amp;#34;김서방은 &amp;#34; + to_string(i) + &amp;#34;에 있다&amp;#34;;}</description>
    </item>
    
    <item>
      <title>[프로그래머스]문자열 다루기 기본</title>
      <link>https://jyukki97.github.io/blog/2019-12-17-stringbase/</link>
      <pubDate>Tue, 17 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-12-17-stringbase/</guid>
      <description>https://programmers.co.kr
풀이:  문자열 s의 길이가 4 또는 6 이고, 숫자로만 구성되어있는지 확인 후 아니라면 false를 리턴  코드: 사용언어 : c++
#include &amp;lt;string&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std;bool solution(string s) {bool answer = true;if (s.length() != 4 &amp;amp;&amp;amp; s.length() != 6) {answer = false;}else {for (int i = 0;i &amp;lt; s.length();i++) {if (s[i] &amp;gt; &amp;#39;9&amp;#39;) {answer = false;break;}}}return answer;}</description>
    </item>
    
    <item>
      <title>[프로그래머스]문자열 내 p와 y의 개수</title>
      <link>https://jyukki97.github.io/blog/2019-12-16-py/</link>
      <pubDate>Mon, 16 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-12-16-py/</guid>
      <description>https://programmers.co.kr
풀이:  문자열 s의 모든 원소를 보고 p,P 이면 p의 갯수를 올리고, y,Y이면 y의 갯수를 올린다. p의 갯수와 y의 갯수가 같다면 true 다르다면 false 를 리턴한다.  코드: 사용언어 : c++
#include &amp;lt;string&amp;gt;#include &amp;lt;iostream&amp;gt;using namespace std;bool solution(string s){bool answer = true;int p = 0;int y = 0;for (int i = 0;i &amp;lt; s.length();i++) {if (s[i] == &amp;#39;p&amp;#39; || s[i] == &amp;#39;P&amp;#39;) {p++;}if (s[i] == &amp;#39;y&amp;#39; || s[i] == &amp;#39;Y&amp;#39;) {y++;}}if (p !</description>
    </item>
    
    <item>
      <title>[프로그래머스]체육복</title>
      <link>https://jyukki97.github.io/blog/2019-12-15-gymclothes/</link>
      <pubDate>Sun, 15 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-12-15-gymclothes/</guid>
      <description>https://programmers.co.kr
풀이:   학생 전체 중 체육복을 잃어버린 학생과 체육복을 추가로 가져온 학생을 정리한다.(체육복을 추가로 가져온 학생들 중 체육복을 잃어버린 학생이 있을 수 있기 때문에)
  체육복이 없는 학생 중 양 옆에 여벌의 체육복을 가져온 학생이 있는경우 빌려입는다.
  전체 학생 중 체육복이 1개 이상 있는 학생들의 수를 리턴한다.
  주의 사항:   체육복을 추가로 가져온 학생들 중 체육복을 잃어버린 학생이 있을 수 있다.
  체육복을 추가로 가져오지 않았을 경우, 옆 사람에게 체육복을 추가로 얻어도 다른 사람에게 양도할 수 없다.</description>
    </item>
    
    <item>
      <title>[프로그래머스]k번째 수</title>
      <link>https://jyukki97.github.io/blog/2019-12-14-knum/</link>
      <pubDate>Sat, 14 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-12-14-knum/</guid>
      <description>https://programmers.co.kr
풀이:  array 배열의 commands[0]번째부터 commands[1]번째 까지 자른 후 정렬한다. 자른 배열의 commands[2] 번째 숫자를 출력한다. commands 배열의 길이만큼 반복한다.  코드: 사용언어 : c++
#include &amp;lt;string&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;vector&amp;lt;int&amp;gt; solution(vector&amp;lt;int&amp;gt; array, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; commands) {vector&amp;lt;int&amp;gt; answer;for(int i=0;i&amp;lt;commands.size();i++){vector&amp;lt;int&amp;gt; a = array;sort(a.begin()+commands[i][0]-1,a.begin()+commands[i][1]);answer.push_back(a[commands[i][0] + commands[i][2] - 2]); }return answer;}</description>
    </item>
    
    <item>
      <title>[프로그래머스]2016년</title>
      <link>https://jyukki97.github.io/blog/2019-12-13-2016%EB%85%84/</link>
      <pubDate>Fri, 13 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-12-13-2016%EB%85%84/</guid>
      <description>https://programmers.co.kr
풀이:  매 달 날짜를 계산하여 원하는 날짜의 요일을 구한다,  주의사항:  2016년은 윤년이다. 1월 1일은 금요일이다.  코드: 사용언어 : c++
#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;stdbool.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt;char* solution(int a, int b) {// 리턴할 값은 메모리를 동적 할당해주세요. int m[13] = { 0,31,29,31,30,31,30,31,31,30,31,30,31 };const char *d[8]= { &amp;#34;THU&amp;#34;,&amp;#34;FRI&amp;#34;,&amp;#34;SAT&amp;#34;,&amp;#34;SUN&amp;#34;,&amp;#34;MON&amp;#34;,&amp;#34;TUE&amp;#34;,&amp;#34;WED&amp;#34; };for(int i = 1;i &amp;lt; a;i++) {b += m[i];}b %= 7;return d[b];}</description>
    </item>
    
    <item>
      <title>[백준]11399 ATM</title>
      <link>https://jyukki97.github.io/blog/2019-06-20-11399/</link>
      <pubDate>Thu, 20 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-06-20-11399/</guid>
      <description>https://www.acmicpc.net/problem/11399
풀이:  돈을 인출하는데 필요한 시간을 입력받는다. 입력받은 시간을 정렬한다. 정렬한 값을 n-i를 곱해서 더해준다.  코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;int main() {int n,r=0,a[1001];cin &amp;gt;&amp;gt; n;for (int i = 0; i &amp;lt; n; i++)cin &amp;gt;&amp;gt; a[i];sort(&amp;amp;a[0], &amp;amp;a[n]);for (int i = 0; i &amp;lt; n; i++)r += a[i] * (n - i);cout &amp;lt;&amp;lt; r &amp;lt;&amp;lt; endl;}</description>
    </item>
    
    <item>
      <title>[백준]2609 최대공약수와 최소공배수</title>
      <link>https://jyukki97.github.io/blog/2019-06-19-2609/</link>
      <pubDate>Wed, 19 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-06-19-2609/</guid>
      <description>https://www.acmicpc.net/problem/2609
풀이:  두 수를 입력받는다. 두 수의 최대공약수와 최소공배수를 출력한다.  코드: 사용언어 : Python 3
import matha,b=map(int,input().split())c=math.gcd(a,b)print(c,a//c*b)</description>
    </item>
    
    <item>
      <title>[백준]14490 백대열</title>
      <link>https://jyukki97.github.io/blog/2019-06-18-14490/</link>
      <pubDate>Tue, 18 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-06-18-14490/</guid>
      <description>https://www.acmicpc.net/problem/14490
풀이:  두 수를 입력받는다(:을 사이에 두고 주어지므로 주의) 두 수의 최대공약수를 구한다. 두 수를 최대공약수로 나눠서 출력한다(최대한으로 약분은 최대공약수로 나누어주면 가능하다)(이때 :을 사이에 두고 출력한다.)  코드: 사용언어 : Python 3
import matha,b=map(int,input().split(&amp;#39;:&amp;#39;))c=math.gcd(a,b)print(a//c,b//c,sep=&amp;#39;:&amp;#39;)</description>
    </item>
    
    <item>
      <title>[백준]1850 최대공약수</title>
      <link>https://jyukki97.github.io/blog/2019-06-17-1850/</link>
      <pubDate>Mon, 17 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-06-17-1850/</guid>
      <description>https://www.acmicpc.net/problem/1850
풀이:  두 수를 입력받는다 두 수의 최대공약수를 구한다. 최대공약수만큼 1을 반복해서 출력한다.  코드: 사용언어 : Python 3
a,b=map(int,input().split())while b: a,b=b,a%bprint(&amp;#39;1&amp;#39;*a)</description>
    </item>
    
    <item>
      <title>[백준]10757 큰 수 A&#43;B</title>
      <link>https://jyukki97.github.io/blog/2019-06-16-10757/</link>
      <pubDate>Sun, 16 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-06-16-10757/</guid>
      <description>https://www.acmicpc.net/problem/10757
풀이:  두 수를 입력받은 후 더해서 출력한다.  코드: 사용언어 : Python 3
print(sum(map(int,input().split())))</description>
    </item>
    
    <item>
      <title>[백준]10826 피보나치 수 4</title>
      <link>https://jyukki97.github.io/blog/2019-06-15-10826/</link>
      <pubDate>Sat, 15 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-06-15-10826/</guid>
      <description>https://www.acmicpc.net/problem/10826
풀이:  n을 입력받는다 n번째 피보나치 수를 출력한다  코드: 사용언어 : Python 3
s,t=0,1for i in range(int(input())):t,s=s,s+tprint(s)</description>
    </item>
    
    <item>
      <title>[백준]11050 이항 계수 1</title>
      <link>https://jyukki97.github.io/blog/2019-06-14-11050/</link>
      <pubDate>Fri, 14 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-06-14-11050/</guid>
      <description>https://www.acmicpc.net/problem/11050
풀이:  n, k 를 입력받고, nCk를 출력한다  코드: 사용언어 : Python 3
n,k=map(int,input().split())r=1for i in range(k): r*=(n-i)/(i+1)print((int)(r))</description>
    </item>
    
    <item>
      <title>[백준]11365 !밀비 급일</title>
      <link>https://jyukki97.github.io/blog/2019-06-13-11365/</link>
      <pubDate>Thu, 13 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-06-13-11365/</guid>
      <description>https://www.acmicpc.net/problem/11365
풀이:  문자열을 입력받고, 그 문자열을 뒤집어서 출력한다. 문자열이 END라면 반복을 중지한다.  코드: 사용언어 : Python 3
while 1:a=input()if a==&amp;#39;END&amp;#39;:breakprint(a[::-1])</description>
    </item>
    
    <item>
      <title>[백준]10952 A&#43;B - 5</title>
      <link>https://jyukki97.github.io/blog/2019-06-12-10952/</link>
      <pubDate>Wed, 12 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-06-12-10952/</guid>
      <description>https://www.acmicpc.net/problem/10952
풀이:  반복 횟수를 무한히 한 후 입력받은 두 수의 합을 출력 입력받은 두 수가 0 0 이라면 반복문을 빠져나간다.  코드: 사용언어 : Python 3
while 1:a,b=map(int,input().split())if a==0:breakprint(a+b)</description>
    </item>
    
    <item>
      <title>[백준]15552 빠른 A&#43;B</title>
      <link>https://jyukki97.github.io/blog/2019-06-11-15552/</link>
      <pubDate>Tue, 11 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-06-11-15552/</guid>
      <description>https://www.acmicpc.net/problem/15552
풀이:  반복 횟수를 입력받은 후 입력받은 두 수의 합을 출력 간단한 문제이지만 매우 많은 테스트케이스의 수가 있으므로 input() 대신 sys.stdin().readline()을 사용한다.  코드: 사용언어 : Python 3
import sysfor i in range(int(input())):print(sum(map(int,sys.stdin.readline().split())))</description>
    </item>
    
    <item>
      <title>[백준]10950 A&#43;B - 3</title>
      <link>https://jyukki97.github.io/blog/2019-06-10-10950/</link>
      <pubDate>Mon, 10 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-06-10-10950/</guid>
      <description>https://www.acmicpc.net/problem/10950
풀이:  반복 횟수를 입력받은 후 입력받은 두 수의 합을 출력  코드: 사용언어 : Python 3
for i in range(int(input())):print(sum(map(int,input().split())))</description>
    </item>
    
    <item>
      <title>[백준]10971 외판원 순회 2</title>
      <link>https://jyukki97.github.io/blog/2019-06-09-10971/</link>
      <pubDate>Sun, 09 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-06-09-10971/</guid>
      <description>https://www.acmicpc.net/problem/10971
풀이:  [백준]2098 외판원순회 와 같으므로 참고  코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;int w[17][17],d[17][100000], n;int T(int a, int b) {if ((1 &amp;lt;&amp;lt; n) - 1 == b &amp;amp;&amp;amp; w[a][0] != 0)return w[a][0];int &amp;amp;r = d[a][b];if (r &amp;gt; 0)return r;r = 100000000;for (int i = 0; i &amp;lt; n; i++)if (w[a][i] != 0 &amp;amp;&amp;amp; (b &amp;amp; (1 &amp;lt;&amp;lt; i)) == 0)r = min(r, w[a][i] + T(i, b | (1 &amp;lt;&amp;lt; i)));return r;}int main(void) {cin &amp;gt;&amp;gt; n;for (int i = 0; i &amp;lt; n; i++)for (int t = 0; t &amp;lt; n; t++)cin &amp;gt;&amp;gt; w[i][t];cout &amp;lt;&amp;lt; T(0, 1) &amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
    <item>
      <title>[백준]11047 동전 0</title>
      <link>https://jyukki97.github.io/blog/2019-06-08-11047/</link>
      <pubDate>Sat, 08 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-06-08-11047/</guid>
      <description>https://www.acmicpc.net/problem/11047
풀이:  동전에 가격이 높은 것 부터 내가 필요한 가격에서 빼준다. 빼준 횟수만큼 카운트를 높여준다. 카운트를 출력한다. ( i ≥ 2인 경우에 Ai는 Ai-1의 배수) 조건으로 인해 그냥 높은 것 부터 빼줘도 문제가 생기지않는다.  코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;using namespace std;int main() {int n, k, s[12], c = 0;cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; k;while (n--)cin &amp;gt;&amp;gt; s[n];while (k) {c += k / s[++n]; k %= s[n];}cout &amp;lt;&amp;lt; c &amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
    <item>
      <title>[백준]2164 카드2</title>
      <link>https://jyukki97.github.io/blog/2019-06-07-2164/</link>
      <pubDate>Fri, 07 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-06-07-2164/</guid>
      <description>https://www.acmicpc.net/problem/2164
풀이:  카드의 갯수가 2 ^ i 개일 경우 남게 되는 카드의 번호는 2 ^ i 이다. 카드의 갯수가 (2 ^ i) + n 개 일 경우 남게 되는 카드의 번호는 2 * n 이다.  코드: 사용언어 : Python 3
n,s=int(input()),1while s&amp;lt;n:s*=2print(s if s==n else 2*n-s)</description>
    </item>
    
    <item>
      <title>[백준]12015 가장 긴 증가하는 부분 수열 2</title>
      <link>https://jyukki97.github.io/blog/2019-06-06-12015/</link>
      <pubDate>Thu, 06 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-06-06-12015/</guid>
      <description>https://www.acmicpc.net/problem/12015
풀이:  https://jyukki97.github.io/2352/ 와 같은 문제이므로 참고  코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std;vector&amp;lt;int&amp;gt;d;int main(void) {int n, s, l;cin &amp;gt;&amp;gt; n;while (n--) {cin &amp;gt;&amp;gt; s;l = lower_bound(d.begin(), d.end(), s) - d.begin();if (l == d.size())d.push_back(s);elsed[l] = s;}cout &amp;lt;&amp;lt; d.size() &amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
    <item>
      <title>[백준]1365 꼬인 전깃줄</title>
      <link>https://jyukki97.github.io/blog/2019-06-05-1365/</link>
      <pubDate>Wed, 05 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-06-05-1365/</guid>
      <description>https://www.acmicpc.net/problem/1365
풀이:  https://jyukki97.github.io/2352/ 와 같은 문제이므로 참고  코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std;vector&amp;lt;int&amp;gt;d;int main(void) {int n, s, l;cin &amp;gt;&amp;gt; n;for (int i = 0; i &amp;lt; n; i++) {cin &amp;gt;&amp;gt; s;l = lower_bound(d.begin(), d.end(), s) - d.begin();if (l == d.size())d.push_back(s);elsed[l] = s;}cout &amp;lt;&amp;lt; n - d.size() &amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
    <item>
      <title>[백준]2352 반도체 설계</title>
      <link>https://jyukki97.github.io/blog/2019-06-04-2352/</link>
      <pubDate>Tue, 04 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-06-04-2352/</guid>
      <description>https://www.acmicpc.net/problem/2352
풀이:  맨 처음 값부터 하나 하나 입력받는다. 입력받은 값이 벡터 안에 있는 값들 보다 크다면 벡터에 맨 뒤에 넣는다. 벡터의 처음부터 검색했을 때, 입력받은 값보다 큰 값이 있다면, 그 값과 교체한다. 벡터의 원소 갯수를 출력한다. 일반적으로 for문을 두개 쓴 O(n^2)의 코드는 시간초과가 나므로 주의하자  코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std;vector&amp;lt;int&amp;gt;d;int main(void) {int n, s, l;cin &amp;gt;&amp;gt; n;while(n--) {cin &amp;gt;&amp;gt; s;l = lower_bound(d.</description>
    </item>
    
    <item>
      <title>[백준]1495 기타리스트</title>
      <link>https://jyukki97.github.io/blog/2019-06-02-1495/</link>
      <pubDate>Sun, 02 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-06-02-1495/</guid>
      <description>https://www.acmicpc.net/problem/1495
풀이:  dp[a][b]를 a 번째 곡을 연주 할 때, b 볼륨으로 연주 할 수 있는가? 라고 하자. dp[0][S]는 0 번째 곡을 연주 할 때, S 볼륨으로 연주할 수 있으므로(시작지점) 1을 할당한다. 0번째 곡을 연주할 때, S볼륨으로 연주가 가능하다면, 1번째 곡을 연주할 때, S+s[1] or S-s[1] 볼륨도 연주 가능하다(0&amp;lt;=볼륨&amp;lt;=m 일때) 즉, dp[i][t + s[i]] = dp[i - 1][t] or dp[i][t - s[i]] = dp[i - 1][t] 마지막에 dp[N]값을 모두 순환하며, 가장 높은 값을 출력하고, 가능한 볼륨이 없다면 -1을 출력한다.</description>
    </item>
    
    <item>
      <title>[백준]4781 사탕 가게</title>
      <link>https://jyukki97.github.io/blog/2019-05-30-4781/</link>
      <pubDate>Thu, 30 May 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-05-30-4781/</guid>
      <description>https://www.acmicpc.net/problem/4781
풀이:  dp[a]를 a원으로 구매할 수 있는 가장 높은 칼로리라고 한다. 사탕의 칼로리를 s, 가격을 d라고 했을 때, 현제 a원으로 구매할 수 있는 가장 높은 칼로리와 a-d원 으로 구매할 수 있는 가장높을칼로리 + s 를 비교하여 높은 값으로 교체한다. 즉, dp[t] = max(dp[t], dp[t - d] + s) 를 반복하여 do[m]값을 구한다.  코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;double M1, d1;int N, M, s, d, dp[10002];int main(void) {while (1) {memset(dp, 0, sizeof(dp));cin &amp;gt;&amp;gt; N &amp;gt;&amp;gt; M1;if (N == 0)break;M = M1 * 100;for (int i = 0; i &amp;lt; N; i++) {cin &amp;gt;&amp;gt; s &amp;gt;&amp;gt; d1;d = d1 * 100;for (int t = d; t &amp;lt;= M; t++) dp[t] = max(dp[t], dp[t - d] + s);}cout &amp;lt;&amp;lt; dp[M] &amp;lt;&amp;lt; endl;}return 0;}</description>
    </item>
    
    <item>
      <title>[백준]2662 기업 투자</title>
      <link>https://jyukki97.github.io/blog/2019-05-29-2662/</link>
      <pubDate>Wed, 29 May 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-05-29-2662/</guid>
      <description>https://www.acmicpc.net/problem/2662
풀이:  dp[a][b]를 남은 금액이 a원 일 때, b번째 기업에 투자해서 얻을 수 있는 최대 이익이라고 하자. 첫번째 기업에 0원을 투자하는 것 부터 M번째 기업에 N원을 투자하는 것 까지 반복하여 최대 이익금을 구한다. 최대 이익금일 때 각 기업에 얼마를 투자했는지 구한 후 출력한다. 시간초과가 나기 쉬우므로 메모이제이션을 한다.  코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;cstring&amp;gt;using namespace std;int N, M, s[302][22], dp[302][22], x[302][22];int q(int a, int c) {if (c &amp;gt; M)return 0;int &amp;amp;m = dp[a][c];if (m !</description>
    </item>
    
    <item>
      <title>[백준]1937 욕심쟁이 판다</title>
      <link>https://jyukki97.github.io/blog/2019-05-28-1937/</link>
      <pubDate>Tue, 28 May 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-05-28-1937/</guid>
      <description>https://www.acmicpc.net/problem/1937
풀이:  k[a][b]를 (a , b)지점에서 시작한 판다가 살아남은 최대 일수라고 한다. (a, b) 주변 십자가 방향 지점( (1,0), (-1, 0), (0, 1), (0, -1)) 에서 대나무의 양이 (a, b) 보다 낮다면 그 지점에 최대 일수에서 +1 한 값이 k[a][b] 값이 된다. 높은 값에서 낮은값으로 찾아가면서 최대 일수를 구한다. 시간초과가 날 수 있으므로 메모이제이션을 통해 시행횟수를 제한해준다.  코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;int n, s[510][510], k[510][510];int dx[] = { 1,0,0,-1 };int dy[] = { 0,1,-1,0 };int panda(int a, int b){for (int y = 0; y &amp;lt; 4; y++)if (a + dy[y] &amp;gt;= 0 &amp;amp;&amp;amp; a + dy[y] &amp;lt; n &amp;amp;&amp;amp; b + dx[y] &amp;gt;= 0 &amp;amp;&amp;amp; b + dx[y] &amp;lt; n)if (s[a][b] &amp;lt; s[a + dy[y]][b + dx[y]]) {if(k[a + dy[y]][b + dx[y]] == 1)k[a][b] = max(k[a][b], panda(a + dy[y], b + dx[y]) + 1);elsek[a][b] = max(k[a][b], k[a + dy[y]][b + dx[y]] + 1);}return k[a][b];}int main(void) {cin &amp;gt;&amp;gt; n;int m = 1;fill(&amp;amp;k[0][0], &amp;amp;k[n][n], 1);for (int i = 0; i &amp;lt; n; i++)for (int t = 0; t &amp;lt; n; t++)cin &amp;gt;&amp;gt; s[i][t];for (int i = 0; i &amp;lt; n; i++)for (int t = 0; t &amp;lt; n; t++)m = max(m, panda(i, t));cout &amp;lt;&amp;lt; m &amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
    <item>
      <title>[백준]5069 미로에 갇힌 상근</title>
      <link>https://jyukki97.github.io/blog/2019-05-27-5069/</link>
      <pubDate>Mon, 27 May 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-05-27-5069/</guid>
      <description>https://www.acmicpc.net/problem/5069
풀이:  s[n][t][y]를 n번 이동해서 (t, y)인 방으로 다시 돌아오는 경우의 수라고 한다. 처음 상근이가 있는 방을 (10, 10)이라고 한다(n의 최대 수가 14 이므로 10칸을 넘어가지 않기 때문에) s[n][10][10] 은 n번 이동해서 상근이가 있는 방으로 돌아와야하므로 상근이의 근처에 있는 모든 n-1번 이동하여 돌아오는 경우의 수들의 합과 같다. 즉 s[n][10][10] = s[n-1][10][11] + s[n-1][10][9] + s[n-1][11][11] + s[n-1][11][10] + s[n-1][9][9] + s[n-1][9][10]  코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;using namespace std;int s[15][21][21];int dy[] = { 0,0,1,1,-1,-1 };int dx[] = { 1,-1,1,0,-1,0 };int main(void) {int T, a;cin &amp;gt;&amp;gt; T;s[0][10][10] = 1;for (int i = 1; i &amp;lt; 15; i++)for (int t = 1; t &amp;lt; 21; t++)for (int y = 1; y &amp;lt; 21; y++)for (int u = 0; u &amp;lt; 6; u++)if (t + dx[u] &amp;gt; 0 &amp;amp;&amp;amp; t + dx[u] &amp;lt; 21 &amp;amp;&amp;amp; y + dy[u] &amp;gt; 0 &amp;amp;&amp;amp; y + dy[u] &amp;lt; 21)s[i][t][y] += s[i - 1][t + dx[u]][y + dy[u]];while (T--) {cin &amp;gt;&amp;gt; a;cout &amp;lt;&amp;lt; s[a][10][10] &amp;lt;&amp;lt; endl;}return 0;}</description>
    </item>
    
    <item>
      <title>[백준]1351 무한 수열</title>
      <link>https://jyukki97.github.io/blog/2019-03-29-1351/</link>
      <pubDate>Fri, 29 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-03-29-1351/</guid>
      <description>https://www.acmicpc.net/problem/1351
풀이:  N번째 수열부터 차례대로 찾아나간다. N번째 수열이 map 에 존재한다면 그대로 리턴, 없다면 N = a/b + a/c 로 돌아가서 찾기 N이 0이라면 1을 리턴 각각의 값이 매우 크므로 long long 사용 실패 코드 예시처럼 map을 쓰지않고 리턴을 할 경우 같은 수열이 여러번 중복되어 계산되기 때문에 시간초과가 날 수 있다.  코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;map&amp;gt;using namespace std;long long a, b, c;map&amp;lt;long long, long long&amp;gt; n;long long infi(long long q) {if (q == 0)return 1;if (n.</description>
    </item>
    
    <item>
      <title>[백준]1712 손익분기점</title>
      <link>https://jyukki97.github.io/blog/2018-03-16-1712/</link>
      <pubDate>Fri, 16 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2018-03-16-1712/</guid>
      <description>https://www.acmicpc.net/problem/1712
풀이:  고정비용을 노트북 가격에서 생산비인 가변 비용을 뺀 값으로 나눈 몫을 출력한다. 만약 가변비용이 노트북의 가격보다 높다면 -1을 출력한다.  코드: 사용언어 : Python 3
a,b,c=map(int,input().split())if b&amp;gt;=c:print(&amp;#34;-1&amp;#34;)else:print(a//(c-b)+1)</description>
    </item>
    
    <item>
      <title>[백준]1919 애너그램 만들기</title>
      <link>https://jyukki97.github.io/blog/2018-02-05-1919/</link>
      <pubDate>Mon, 05 Feb 2018 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2018-02-05-1919/</guid>
      <description>https://www.acmicpc.net/problem/1919
풀이:  a~z까지의 알파벳 중 문자열에 나온 개수를 확인 후 그 차이를 출력한다.  코드: 사용언어 : Python 3
a,b=input(),input()print(sum(abs(b.count(chr(i))-a.count(chr(i)))for i in range(97,123)))</description>
    </item>
    
    <item>
      <title>[백준]2338 긴자리 계산</title>
      <link>https://jyukki97.github.io/blog/2018-02-04-2338/</link>
      <pubDate>Sun, 04 Feb 2018 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2018-02-04-2338/</guid>
      <description>https://www.acmicpc.net/problem/2338
풀이:  두 수를 입력받는다. 두 수를 더한값, 뺀값, 곱한값을 각각 출력한다.  코드: 사용언어 : Python 3
a,b=int(input()),int(input())print(a+b,a-b,a*b,sep=&amp;#39;\n&amp;#39;)</description>
    </item>
    
    <item>
      <title>[백준]2154 수 이어 쓰기 3</title>
      <link>https://jyukki97.github.io/blog/2018-02-03-2154/</link>
      <pubDate>Sat, 03 Feb 2018 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2018-02-03-2154/</guid>
      <description>https://www.acmicpc.net/problem/2154
풀이:  전체 수를 string타입으로 나열한다. 그 숫자 중 제시된 숫자 n이 맨 처음으로 나오는 인덱스를 출력한다.  코드: 사용언어 : Python 3
n,s=int(input()),&amp;#34;&amp;#34;for i in range(1,n+1):s+=str(i)print(s.find(str(n))+1)</description>
    </item>
    
    <item>
      <title>[백준]2624 동전 바꿔주기</title>
      <link>https://jyukki97.github.io/blog/2018-01-11-2624/</link>
      <pubDate>Thu, 11 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2018-01-11-2624/</guid>
      <description>https://www.acmicpc.net/problem/2624
풀이:   coin[i] : i원의 지폐를 동전으로 교환할 수 있는 경우의 수
  지폐의 가격 + 동전의 가격 * 동전의 개수를 계속 쌓아간다.
  코드: #include &amp;lt;iostream&amp;gt;using namespace std;pair&amp;lt;int, int&amp;gt; a[101];int coin[10001] = { 0 };int main(void) {int T, k, n, m;cin &amp;gt;&amp;gt; T &amp;gt;&amp;gt; k;for (int i = 0; i &amp;lt; k; i++) {cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;a[i] = make_pair(n, m);}coin[0] = 1;for (int i = 0; i &amp;lt; k; i++)for (int t = T; t &amp;gt; 0 ; t--)for (int y = 1; y &amp;lt;= a[i].</description>
    </item>
    
    <item>
      <title>[백준]3908 서로 다른 소수의 합</title>
      <link>https://jyukki97.github.io/blog/2018-01-10-3908/</link>
      <pubDate>Wed, 10 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2018-01-10-3908/</guid>
      <description>https://www.acmicpc.net/problem/3908
풀이:  소수를 찾는다. 소수를 하나씩 추가해가면서 a[n][k]를 찾는다. a[n][k] : 양의 정수 n을 서로 다른 k개의 소수의 합으로 나타낼 수 있는 최대의 경우의 수  코드: #include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;math.h&amp;gt;#include &amp;lt;string.h&amp;gt;using namespace std;int	T, n, k, a[1122][16] = { 0 };bool isprime[1122];vector&amp;lt;int&amp;gt; b;int prime() {memset(isprime, 1, sizeof(isprime));isprime[0] = isprime[1] = false;for (int i = 2; i &amp;lt; sqrt(1122); i++)if(isprime[i])for (int t = i * i; t &amp;lt; 1122; t += i)isprime[t] = false;for (int i = 2; i &amp;lt; 1122; i++) if (isprime[i]) b.</description>
    </item>
    
    <item>
      <title>[백준]2748 피보나치 수 2</title>
      <link>https://jyukki97.github.io/blog/2018-01-05-2748/</link>
      <pubDate>Fri, 05 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2018-01-05-2748/</guid>
      <description>https://www.acmicpc.net/problem/2748
풀이:  a[i % 3] : n번째 피보나치 수 a[i % 3] = a[(i - 1) % 3] + a[(i - 2) % 3];  코드: #include &amp;lt;iostream&amp;gt;using namespace std;long long a[3] = { 0,1 }, n;int main() {cin &amp;gt;&amp;gt; n;for (int i = 2; i &amp;lt;= n; i++)a[i % 3] = a[(i - 1) % 3] + a[(i - 2) % 3];cout &amp;lt;&amp;lt; a[n % 3] &amp;lt;&amp;lt; endl;}</description>
    </item>
    
    <item>
      <title>[백준]11568 민균이의 계략</title>
      <link>https://jyukki97.github.io/blog/2018-01-02-11568/</link>
      <pubDate>Tue, 02 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2018-01-02-11568/</guid>
      <description>https://www.acmicpc.net/problem/11568
풀이:  11053 가장 긴 증가하는 부분 수열 의 문제와 같으므로 링크를 참고  코드: #include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;long long a[1001] = { 0 }, b[1001];int main(void) {long long n, temp;cin &amp;gt;&amp;gt; n;for (int i = 0; i &amp;lt; n; i++) {cin &amp;gt;&amp;gt; a[i];b[i] = 1;}for (int i = 0; i &amp;lt; n; i++) {temp = 0;for (int t = 0; t &amp;lt;= i; t++) {if (a[i] &amp;gt; a[i - t])temp = max(b[i - t], temp);}b[i] += temp;}for (int i = 0; i &amp;lt; n; i++) {temp = max(b[i], temp);}cout &amp;lt;&amp;lt; temp &amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
    <item>
      <title>[백준]2228 구간 나누기</title>
      <link>https://jyukki97.github.io/blog/2017-12-26-2228/</link>
      <pubDate>Tue, 26 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-12-26-2228/</guid>
      <description>https://www.acmicpc.net/problem/2228
풀이:   dp[n][m] : n개의 숫자를 m개의 구간으로 나눈 최대 합
  dp[i][t] = dp[i - 1][t] : i번째 수를 포함하지 않는 경우
  dp[i][t] = max(dp[i][t], (t == 1 ? 0 : dp[y - 1][t - 1]) + a[i] - a[y]) : i번째 수를 포함하는 경우 i번째를 포함하므로 구간을 하나 빼고 그것에 i번째 수를 포함하는 구간을 더한다.
  max함수를 쓰므로 dp 초기화를 잘해줘야한다.
  코드: #include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;int a[101] = { 0 }, dp[101][52] = { 0 };int main(void) {int n, m, temp;cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;fill(dp[0] + 1, dp[0] + m + 1, -2147483646);for (int i = 1; i &amp;lt;= n; i++) {cin &amp;gt;&amp;gt; temp;a[i] = a[i - 1] + temp;for (int t = 1; t &amp;lt;= m; t++) {dp[i][t] = dp[i - 1][t];for (int y = i - 1; y / 2 &amp;gt;= t - 1; y--) {dp[i][t] = max(dp[i][t], (t == 1 ?</description>
    </item>
    
    <item>
      <title>[백준]7579 앱</title>
      <link>https://jyukki97.github.io/blog/2017-12-21-7579/</link>
      <pubDate>Thu, 21 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-12-21-7579/</guid>
      <description>https://www.acmicpc.net/problem/7579
풀이:  처음 문제를 풀때는 DP[메모리]로 풀었더니 시간초과가 났다. 그래서 DP[c]로 풀게되었다. 가격이 0이고 메모리가 0인 지점부터 하나하나 더해가면서 만들어나간다. 그 후 가격이 낮은 곳부터 검사하면서 메모리가 M값보다 높아지면 출력한다. iter = a.end(); 를 처음에 iter = a.begin(); 으로 했을 때 출력이 잘못되는 것을 발견하였다. 아마 작은 값부터 더해가는 과정에 겹치는 값이 생겼을 것이라고 본다.  코드: #include &amp;lt;iostream&amp;gt;#include &amp;lt;map&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;map&amp;lt;int, int&amp;gt; a;int k[101], c[101];int main(void) {int n, m, size, temp;cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;a[0] = 0;for (int i = 0; i &amp;lt; n; i++)cin &amp;gt;&amp;gt; k[i];for (int i = 0; i &amp;lt; n; i++)cin &amp;gt;&amp;gt; c[i];map&amp;lt;int, int&amp;gt;::iterator iter;for (int i = 0; i &amp;lt; n; i++) {size = a.</description>
    </item>
    
    <item>
      <title>[백준]1038 감소하는 수</title>
      <link>https://jyukki97.github.io/blog/2017-12-20-1038/</link>
      <pubDate>Wed, 20 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-12-20-1038/</guid>
      <description>https://www.acmicpc.net/problem/1038
풀이:  10, 321 등 감소하는 수를 찾는 문제 감소하는 수를 하나씩 만들어 가면서 카운트를 증가시킨다. 카운트의 값이 제시된 N값과 일치하면 출력한다. 제시된 N값이 9876543210의 위치인 1022 보다 크다면 -1을 출력한다.  코드: #include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std;vector&amp;lt;int&amp;gt; a;int main(void) {int n;int cnt = 11;cin &amp;gt;&amp;gt; n;if (n &amp;lt; 11) {cout &amp;lt;&amp;lt; n &amp;lt;&amp;lt; endl;}else if (n &amp;gt; 1022)cout &amp;lt;&amp;lt; &amp;#34;-1&amp;#34; &amp;lt;&amp;lt; endl;else {a.</description>
    </item>
    
    <item>
      <title>[백준]2629 양팔저울</title>
      <link>https://jyukki97.github.io/blog/2017-12-19-2629/</link>
      <pubDate>Tue, 19 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-12-19-2629/</guid>
      <description>https://www.acmicpc.net/problem/2629
풀이:  양팔저울에 추를 매달아 구할 수 있는 무게를 알아내는 문제 양팔저울에 한 곳에 놓았을 때, 양쪽에 서로 따로 놓았을 때 두 가지의 경우가 있다. 이 때 같이놓으면 + 따로 놓은것은 -로 놓고 배열에 저장한다. 구슬의 무게에 맞는 배열의 값이 1이면 구할 수 있고, 1이 아닌경우 구할 수 없는 것으로 취급한다.  코드: #include &amp;lt;iostream&amp;gt;#include &amp;lt;map&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std;map&amp;lt;int, int&amp;gt; a;vector&amp;lt;int&amp;gt; b;int main(void) {int n, temp, k, size;cin &amp;gt;&amp;gt; n;for (int i = 0; i &amp;lt; n; i++) {cin &amp;gt;&amp;gt; temp;map&amp;lt;int, int&amp;gt;::iterator iter;size = a.</description>
    </item>
    
    <item>
      <title>[백준]2698 인접한 비트의 개수</title>
      <link>https://jyukki97.github.io/blog/2017-12-18-2698/</link>
      <pubDate>Mon, 18 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-12-18-2698/</guid>
      <description>https://www.acmicpc.net/problem/2698
풀이:  a[n][k][0] : 크기가 n이고 인접비트의 수가 k이며, 끝에 비트가 0인 수 a[n][k][1] : 크기가 n이고 인접비트의 수가 k이며, 끝에 비트가 1인 수 a[n][k][0] = a[n - 1][k][0] + a[n - 1][k][1] a[n][k][1] = a[n - 1][k][0] + a[n - 1][k - 1][1]  코드: #include &amp;lt;iostream&amp;gt;using namespace std;int a[102][102][2] = { 0 };int main(void) {int T, n, k;int cnt = 2;cin &amp;gt;&amp;gt; T;a[1][0][1] = 1; a[1][0][0] = 1;for (int i = 0; i &amp;lt; T; i++) {cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; k;for (int t = cnt; t &amp;lt; n + 1; t++) {for (int y = 0; y &amp;lt; t; y++) {a[t][y][0] = a[t - 1][y][0] + a[t - 1][y][1];a[t][y][1] = a[t - 1][y][0] + a[t - 1][y - 1][1];}}cout &amp;lt;&amp;lt; a[n][k][0] + a[n][k][1] &amp;lt;&amp;lt; endl;cnt = n;}return 0;}</description>
    </item>
    
    <item>
      <title>[백준]1793 타일링</title>
      <link>https://jyukki97.github.io/blog/2017-12-17-1793/</link>
      <pubDate>Sun, 17 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-12-17-1793/</guid>
      <description>https://www.acmicpc.net/problem/1793
풀이: 11727 2XN 타일링2
 DP는 링크와 같으므로 링크를 참고 링크의 코드와 다르게 int 보다 큰 값을 출력해야하므로 어려움이 있다. vector를 사용하여 int를 한자리수 씩 계산하는 방법으로 풀었다. 만약 자릿수의 값이 10보다 커지면 다음 자릿수의 값을 그만큼 올려주는 식으로 풀었다.  코드: #include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std;vector&amp;lt;int&amp;gt; a[251];int main(void) {int	n, temp;int cnt = 3;a[0].push_back(1);a[1].push_back(1);a[2].push_back(3);while(cin &amp;gt;&amp;gt; n){if (a[n].size() == 0) {for (int t = cnt; t &amp;lt; n + 1; t++) {int carry = 0;for (int y = 0; y &amp;lt; a[t - 2].</description>
    </item>
    
    <item>
      <title>[백준]2718 타일 채우기</title>
      <link>https://jyukki97.github.io/blog/2017-12-16-2718/</link>
      <pubDate>Sat, 16 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-12-16-2718/</guid>
      <description>https://www.acmicpc.net/problem/2718
풀이:  a[t] 는 4 x t 크기의 타일을 채울 수 있는 경우의 수 a[t] = a[t - 1] + a[t - 2] * 5 + a[t - 3] - a[t - 4];  코드: #include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;int a[30] = { 1,5,11,36 };int main(void) {int T,n,cnt;cnt = 5;cin &amp;gt;&amp;gt; T;for (int i = 0; i &amp;lt; T; i++) {cin &amp;gt;&amp;gt; n;if (a[n - 1] == 0)for (int t = cnt-1; t &amp;lt; n; t++) {a[t] = a[t - 1] + a[t - 2] * 5 + a[t - 3] - a[t - 4];}cout &amp;lt;&amp;lt; a[n - 1] &amp;lt;&amp;lt; endl;cnt = max(cnt, n);}return 0;}</description>
    </item>
    
    <item>
      <title>[백준]11722 가장 긴 감소하는 부분 수열</title>
      <link>https://jyukki97.github.io/blog/2017-12-15-11722/</link>
      <pubDate>Fri, 15 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-12-15-11722/</guid>
      <description>https://www.acmicpc.net/problem/11722
풀이:  11053 가장 긴 증가하는 부분 수열의 문제와 똑같으므로 링크를 참고  코드: #include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;int main(void) {int n, temp;cin &amp;gt;&amp;gt; n;int a[1001] = { 0 };int b[1001];for (int i = 0; i &amp;lt; n; i++) {cin &amp;gt;&amp;gt; a[i];b[i] = 1;}for (int i = 0; i &amp;lt; n; i++) {temp = 0;for (int t = 0; t &amp;lt;= i; t++) {if (a[i] &amp;lt; a[i - t])temp = max(b[i - t], temp);}b[i] += temp;}for (int i = 0; i &amp;lt; n; i++) {temp = max(b[i], temp);}cout &amp;lt;&amp;lt; temp &amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
    <item>
      <title>[백준]4883 삼각 그래프</title>
      <link>https://jyukki97.github.io/blog/2017-12-14-4883/</link>
      <pubDate>Thu, 14 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-12-14-4883/</guid>
      <description>https://www.acmicpc.net/problem/4883
풀이:  N X 3 행렬에서 맨 위 중앙에서 출발하여 맨 아래 중앙까지 가는 경로 중 가장 최소 비용을 찾는 문제 각 i행의 1,2,3번째 열의 각각 최소비용은 i-1 번째 행에서의 최소 비용을 더해준 값이다. 맨 마지막 행의 2번째 열을 출력한다. 0이 출력되면 끝나므로 if문으로 while 문을 빠져나갈 수 있게한다. 하나의 테스트케이스마다 숫자를 출력해야하므로 count 값을 각 케이스마다 ++해준다.  코드: #include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;int a[100005][3], b[100005][3];int main(void) {int count = 1;while (true) {int n, temp, temp2;cin &amp;gt;&amp;gt; n;if (n == 0)break;for (int i = 0; i &amp;lt; n; i++) {for (int t = 0; t &amp;lt; 3; t++) {cin &amp;gt;&amp;gt; a[i][t];b[i][t] = a[i][t];}}b[0][2] += b[0][1];b[1][0] += b[0][1];b[1][1] += min(min(b[0][1],b[1][0]), b[0][2]);b[1][2] += min(min(b[1][1], b[0][1]), b[0][2]);for (int i = 2; i &amp;lt; n; i++) {for (int t = 0; t &amp;lt; 3; t++) {if (t == 0)b[i][t] += min(b[i - 1][t], b[i - 1][t + 1]);else if (t == 1)b[i][t] += min(min(b[i - 1][t], b[i - 1][t + 1]), min(b[i - 1][t - 1], b[i][t - 1]));else if (t == 2)b[i][t] += min(min(b[i - 1][t - 1], b[i - 1][t]), b[i][t - 1]);}}cout &amp;lt;&amp;lt; count &amp;lt;&amp;lt; &amp;#34;.</description>
    </item>
    
    <item>
      <title>[백준]10164 격자상의 경로</title>
      <link>https://jyukki97.github.io/blog/2017-12-13-10164/</link>
      <pubDate>Wed, 13 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-12-13-10164/</guid>
      <description>https://www.acmicpc.net/problem/10164
풀이:  N X M 행렬에서 K번째 수를 꼭 지나치면서 오른쪽 맨 아래까지 가는 최대 경우의 수 1~K 까지 가는 경우의 수 * K~M*N 까지 가는 경우의 수 DP[i][t] i행 t열로 갈 수 있는 경우의 수 DP[i][t] = DP[i-1][t] + DP[i][t-1]  코드: #include &amp;lt;iostream&amp;gt;using namespace std;int a[16][16] = { 0 };int b[16][16] = { 0 };int main(void) {int n, m, k, q, w, e, r;cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m &amp;gt;&amp;gt; k;q = k / m + 1;w = k%m;if (k !</description>
    </item>
    
    <item>
      <title>[백준]11053 가장 긴 증가하는 부분 수열</title>
      <link>https://jyukki97.github.io/blog/2017-12-12-11053/</link>
      <pubDate>Tue, 12 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-12-12-11053/</guid>
      <description>https://www.acmicpc.net/problem/11053
풀이:  1965 상자넣기의 문제와 똑같으므로 링크를 참고  코드: #include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;int main(void) {int n, temp;cin &amp;gt;&amp;gt; n;int a[1001] = { 0 };int b[1001];for (int i = 0; i &amp;lt; n; i++) {cin &amp;gt;&amp;gt; a[i];b[i] = 1;}for (int i = 0; i &amp;lt; n; i++) {temp = 0;for (int t = 0; t &amp;lt;= i; t++) {if (a[i] &amp;gt; a[i - t])temp = max(b[i - t], temp);}b[i] += temp;}for (int i = 0; i &amp;lt; n; i++) {temp = max(b[i], temp);}cout &amp;lt;&amp;lt; temp &amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
    <item>
      <title>[백준]6603 로또</title>
      <link>https://jyukki97.github.io/blog/2017-12-12-6603/</link>
      <pubDate>Tue, 12 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-12-12-6603/</guid>
      <description>https://www.acmicpc.net/problem/6603
풀이:  N 개의 로또 번호 중 6개를 선택하여 로또를 만드는 프로그램 6개의 번호를 사전순으로 하나씩 선택하면서 출력한다. 출력 사이사이에 빈칸을 만들어주고, 하나의 테스트 케이스가 끝나면 빈 줄을 하나 출력한다. 0이 출력되면 끝나므로 while 문 안에 if문으로 제한을 넣어준다.  코드: #include &amp;lt;iostream&amp;gt;using namespace std;int a[13];int main(void) {while (true) {int n;cin &amp;gt;&amp;gt; n;if (n == 0)break;for (int i = 0; i &amp;lt; n; i++) {cin &amp;gt;&amp;gt; a[i];}int b[6] = { 0,1,2,3,4,5 };while (true) {cout &amp;lt;&amp;lt; a[b[0]] &amp;lt;&amp;lt; &amp;#34;&amp;#34; &amp;lt;&amp;lt; a[b[1]] &amp;lt;&amp;lt; &amp;#34;&amp;#34; &amp;lt;&amp;lt; a[b[2]] &amp;lt;&amp;lt; &amp;#34;&amp;#34; &amp;lt;&amp;lt; a[b[3]] &amp;lt;&amp;lt; &amp;#34;&amp;#34; &amp;lt;&amp;lt; a[b[4]] &amp;lt;&amp;lt; &amp;#34;&amp;#34; &amp;lt;&amp;lt; a[b[5]] &amp;lt;&amp;lt; endl;if (b[0] &amp;gt;= n - 6)break;else if (b[1] &amp;gt;= n - 5) {b[0]++;for (int i = 0; i &amp;lt; 5; i++) {b[i + 1] = b[i] + 1;}}else if (b[2] &amp;gt;= n - 4) {b[1]++;for (int i = 1; i &amp;lt; 5; i++) {b[i + 1] = b[i] + 1;}}else if (b[3] &amp;gt;= n - 3) {b[2]++;for (int i = 2; i &amp;lt; 5; i++) {b[i + 1] = b[i] + 1;}}else if (b[4] &amp;gt;= n - 2) {b[3]++;for (int i = 3; i &amp;lt; 5; i++) {b[i + 1] = b[i] + 1;}}else if (b[5] &amp;gt;= n - 1) {b[4]++;b[5] = b[4] + 1;}elseb[5]++;}cout &amp;lt;&amp;lt; endl;}return 0;}</description>
    </item>
    
    <item>
      <title>[백준]11060 점프 점프</title>
      <link>https://jyukki97.github.io/blog/2017-12-10-11060/</link>
      <pubDate>Sun, 10 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-12-10-11060/</guid>
      <description>https://www.acmicpc.net/problem/11060
풀이:  cnt[i] 는 i번째 에서의 최소 가짓수 cnt를 모두 최댓값으로 채운 후 a[i] 이하의 값으로 점프할 때 마다 cnt[i + t] 값을 min(cnt[i + t], cnt[i] + 1) 로 해줌으로써 최소 가짓수를 찾는다 만약 도착점의 값이 처음 채운 1001과 같다면 갈 수 없는 경우이므로 -1을 출력한다.  코드: #include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;int a[1001], cnt[1001];int main(void) {int n;cin &amp;gt;&amp;gt; n;fill_n(cnt, n, 1001);for (int i = 0; i &amp;lt; n; i++) {cin &amp;gt;&amp;gt; a[i];}cnt[0] = 0;for (int i = 0; i &amp;lt; n; i++) {for (int t = 1; t &amp;lt;= a[i]; t++) {cnt[i + t] = min(cnt[i + t], cnt[i] + 1);}}if (cnt[n - 1] == 1001)cout &amp;lt;&amp;lt; &amp;#34;-1&amp;#34; &amp;lt;&amp;lt; endl;elsecout &amp;lt;&amp;lt; cnt[n - 1] &amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
    <item>
      <title>[백준]9084 동전</title>
      <link>https://jyukki97.github.io/blog/2017-12-09-9084/</link>
      <pubDate>Sat, 09 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-12-09-9084/</guid>
      <description>https://www.acmicpc.net/problem/9084
풀이:  첫번째 동전부터 경우의 수를 더해감.  코드: #include &amp;lt;iostream&amp;gt;using namespace std;int coin[10001] = { 0 };int main(void){int n, a, num;cin &amp;gt;&amp;gt; n;for (int t = 0; t &amp;lt; n; t++) {fill_n(coin, 10000, 0);cin &amp;gt;&amp;gt; a;int *q = new int[a];for (int i = 0; i &amp;lt; a; i++) {cin &amp;gt;&amp;gt; q[i];}cin &amp;gt;&amp;gt; num;for (int i = 0; i &amp;lt;= num; i++) {if (i%q[0] == 0)coin[i]++;}for (int i = 1; i &amp;lt; a; i++) {for (int t = q[i]; t &amp;lt;= num; t++) {coin[t] += coin[t - q[i]];}}cout &amp;lt;&amp;lt; coin[num] &amp;lt;&amp;lt; endl;}return 0;}</description>
    </item>
    
    <item>
      <title>[백준]1904 01타일</title>
      <link>https://jyukki97.github.io/blog/2017-12-08-1904/</link>
      <pubDate>Fri, 08 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-12-08-1904/</guid>
      <description>https://www.acmicpc.net/problem/1904
풀이:  a[i] 는 길이가 i인 모든 이진수열의 개수 a[i] = a[i - 1] + a[i - 2] 주어진 조건에 맞게 15746 으로 나눈 나머지를 출력  코드: #include &amp;lt;iostream&amp;gt;using namespace std;int a[1000001] = { 1,2 };int main(void) {int n;cin &amp;gt;&amp;gt; n;for (int i = 2; i &amp;lt; n; i++) {a[i] = (a[i - 1] % 15746 + a[i - 2] % 15746) % 15746;}cout &amp;lt;&amp;lt; a[n - 1] &amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
    <item>
      <title>[백준]11055 가장 큰 증가 부분 수열</title>
      <link>https://jyukki97.github.io/blog/2017-12-07-11055/</link>
      <pubDate>Thu, 07 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-12-07-11055/</guid>
      <description>https://www.acmicpc.net/problem/11055
풀이:  배열의 이전을 돌며 가장 합이 큰 값을 더함  코드: #include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;int a[1002], maxA[1002];int main(void) {int n;cin &amp;gt;&amp;gt; n;int maximum = 0;for (int i = 0; i &amp;lt; n; i++) {cin &amp;gt;&amp;gt; a[i];maxA[i] = a[i];}for (int i = 0; i &amp;lt; n; i++) {int temp = 0;for (int t = i-1; t &amp;gt;= 0; t--) {if (a[t] &amp;lt; a[i]) {temp = max(temp, maxA[t]);}}maxA[i] += temp;maximum = max(maximum, maxA[i]);}cout &amp;lt;&amp;lt; maximum &amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
    <item>
      <title>[백준]2957 이진 탐색 트리</title>
      <link>https://jyukki97.github.io/blog/2017-12-05-2957/</link>
      <pubDate>Tue, 05 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-12-05-2957/</guid>
      <description>https://www.acmicpc.net/problem/2957
풀이:  트리의 루트에서 부터 왼쪽 오른쪽에 삽입할때 마다 높이를 1씩 증가시켜 준다. cin , cout을 사용할 경우 시간초과가 나므로 scanf, printf 를 사용하도록 하자 출력의 사이즈가 int 사이즈를 넘어가므로 long long 을 사용하자  코드: #include &amp;lt;iostream&amp;gt;#include &amp;lt;map&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;stdio.h&amp;gt;using namespace std;int main(void) {int n, num;cin &amp;gt;&amp;gt; n;map&amp;lt;int, long long int&amp;gt; a;a[300001] = -1;a[0] = -1;long long temp = 0;for (int i = 0; i &amp;lt; n; i++) {scanf_s(&amp;#34;%d&amp;#34;, &amp;amp;num);a[num] = max((--a.</description>
    </item>
    
    <item>
      <title>[백준]2225 합분해</title>
      <link>https://jyukki97.github.io/blog/2017-12-03-2225/</link>
      <pubDate>Sun, 03 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-12-03-2225/</guid>
      <description>https://www.acmicpc.net/problem/2225
풀이:  a[i][t] 는 0~i+1 까지 정수 t+1 개를 더하여 그 합이 i+1 이 되는 경우의 수 이다. a[i][t] = a[i-1][t] + a[i][t-1] 로 나타낼 수 있다. 이때 수의 값이 너무 커져 오버플로우가 발생할 수 있으므로 1000000000으로 나눈 나머지를 출력한다.  코드: #include &amp;lt;iostream&amp;gt;using namespace std;long long a[201][201];int main(void) {int n, k;cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; k;for (int i = 0; i &amp;lt; n; i++) {a[i][0] = 1;for (int t = 1; t &amp;lt; k; t++) {if (i == 0)a[i][t] = t + 1;elsea[i][t] = ((a[i - 1][t]) % 1000000000 + (a[i][t - 1]) % 1000000000) % 1000000000;}}cout &amp;lt;&amp;lt; a[n - 1][k - 1] &amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
    <item>
      <title>[백준]11051 이항계수2</title>
      <link>https://jyukki97.github.io/blog/2017-12-02-11051/</link>
      <pubDate>Sat, 02 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-12-02-11051/</guid>
      <description>https://www.acmicpc.net/problem/11051
풀이:  nCk 를 나타내는 함수 Comb() 를 만든다. 재귀함수의 특성상 시간초과 때문에 배열에 값을 저장해놓는다.  참고: 1010 다리놓기 코드: #include &amp;lt;iostream&amp;gt;using namespace std;long long cnt[1001][1001] = { 0 };int Comb(int n, int r) {if (r == 0 || r == n)return 1;else if (r == n - 1 || r == 1)return n;if (cnt[n - 1][r] == 0)cnt[n - 1][r] = Comb(n - 1, r);if (cnt[n - 1][r - 1] == 0)cnt[n - 1][r - 1] = Comb(n - 1, r - 1);return (cnt[n - 1][r] % 10007 + cnt[n - 1][r - 1] % 10007) % 100007;}int main(void) {int n, k;cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; k;cout &amp;lt;&amp;lt; Comb(n, k) % 10007&amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
    <item>
      <title>[백준]1890 점프</title>
      <link>https://jyukki97.github.io/blog/2017-12-02-1890/</link>
      <pubDate>Sat, 02 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-12-02-1890/</guid>
      <description>https://www.acmicpc.net/problem/1890
풀이:  cnt[[x][y] 는 x열 y행 에서의 최대 경로의 개수 시간초과를 막기위해 if (cnt[x][y] &amp;gt;= 0) 를 넣어 중복을 피함  코드: #include &amp;lt;iostream&amp;gt;using namespace std;int n, a[101][101];long long cnt[101][101];long long jump(int x, int y) {if (x == n - 1 &amp;amp;&amp;amp; y == n - 1)return 1;if (cnt[x][y] &amp;gt;= 0)return cnt[x][y];cnt[x][y] = 0;if (a[x][y] + x &amp;lt; n)cnt[x][y] += jump(a[x][y] + x, y);if (a[x][y] + y &amp;lt; n)cnt[x][y] += jump(x, a[x][y] + y);return cnt[x][y];}int main(void) {cin &amp;gt;&amp;gt; n;for (int i = 0; i &amp;lt; n; i++) {for (int t = 0; t &amp;lt; n; t++) {cin &amp;gt;&amp;gt; a[i][t];}}fill(cnt[0], cnt[100], -1);cout &amp;lt;&amp;lt; jump(0, 0) &amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
    <item>
      <title>[백준]2096 내려가기</title>
      <link>https://jyukki97.github.io/blog/2017-12-02-2096/</link>
      <pubDate>Sat, 02 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-12-02-2096/</guid>
      <description>https://www.acmicpc.net/problem/2096
풀이:  b[i][0] 은 i번째 수를 골랐을 때의 최댓값 b[i][0] 은 i번째 수를 골랐을 때의 최솟값  참고: 1149 RGB거리 코드: #include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;int a[3],c[3];int main(void) {int n,temp;cin &amp;gt;&amp;gt; n;int b[2][3] = { 0 };for (int i = 0; i &amp;lt; n; i++) {cin &amp;gt;&amp;gt; a[0] &amp;gt;&amp;gt; a[1] &amp;gt;&amp;gt; a[2];c[0] = b[0][0];c[1] = b[0][1];c[2] = b[0][2];temp = max(c[1], c[0]);b[0][0] = a[0] + temp;b[0][1] = a[1] + max(temp, c[2]);b[0][2] = a[2] + max(c[1], c[2]);c[0] = b[1][0];c[1] = b[1][1];c[2] = b[1][2];temp = min(c[1], c[0]);b[1][0] = a[0] + temp;b[1][1] = a[1] + min(temp, c[2]);b[1][2] = a[2] + min(c[1], c[2]);}temp = max(b[0][1], b[0][0]);cout &amp;lt;&amp;lt; max(temp, b[0][2]) &amp;lt;&amp;lt; &amp;#34;&amp;#34;;temp = min(b[1][1], b[1][0]);cout &amp;lt;&amp;lt; min(temp, b[1][2]) &amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
    <item>
      <title>[백준]1309 동물원</title>
      <link>https://jyukki97.github.io/blog/2017-12-01-1309/</link>
      <pubDate>Fri, 01 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-12-01-1309/</guid>
      <description>https://www.acmicpc.net/problem/1309
풀이:  a[i] 가 2 x i 칸에 채울 수 있는 배치의 최댓값이라 하자. a[i] = 2 * a[i - 1] + a[i - 2] 로 구할 수 있다.  코드: #include &amp;lt;iostream&amp;gt;using namespace std;int main(void) {int n;cin &amp;gt;&amp;gt; n;int a[100001] = { 3,7,0 };for (int i = 2; i &amp;lt; n; i++) {a[i] = (2* a[i - 1] + a[i - 2]) % 9901;}cout &amp;lt;&amp;lt; a[n - 1] % 9901 &amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
    <item>
      <title>[백준]1520 내리막 길</title>
      <link>https://jyukki97.github.io/blog/2017-12-01-1520/</link>
      <pubDate>Fri, 01 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-12-01-1520/</guid>
      <description>https://www.acmicpc.net/problem/1520
풀이:  cnt[i][t] 가 i행 t열을 골랐을 때 최대 경로의 수 이다. 왼쪽 위 부터 차례대로 방문한다. 왼쪽, 오른쪽, 위, 아래 를 모두 검사하여 지금 계단의 지점보다 낮은 지점을 찾는다. 계속 검사하면서 가다가 오른쪽 끝 즉, (n,m) 을 만나면 return 1을 해준다. 시간초과 때문에 재방문을 피하기위해 cnt의 값을 모두 -1로 바꿔놓고 0이상이면 검사를 끝내도록 하였다.  코드: #include &amp;lt;iostream&amp;gt;using namespace std;int n, m;int a[501][501];int cnt[501][501];int downhill(int q, int w) {if (q == n &amp;amp;&amp;amp; w == m)return 1;if (cnt[q][w] &amp;gt;= 0)return cnt[q][w];cnt[q][w] = 0;int x[5] = { 0, 1, 0, -1, 0 };int y[5] = { 0, 0, 1, 0, -1 };for (int i = 0; i &amp;lt; 5; i++) {if (q + x[i] &amp;gt; 0 &amp;amp;&amp;amp; q + x[i] &amp;lt;= n &amp;amp;&amp;amp; w + y[i] &amp;gt; 0 &amp;amp;&amp;amp; w + y[i] &amp;lt;= m &amp;amp;&amp;amp; a[q + x[i]][w + y[i]] &amp;lt; a[q][w]) {cnt[q][w] += downhill(q + x[i], w + y[i]);}}return cnt[q][w];}int main(void) {cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;for (int i = 1; i &amp;lt;= n; i++) {for (int t = 1; t &amp;lt;= m; t++) {cin &amp;gt;&amp;gt; a[i][t];}}fill(cnt[0],cnt[500], -1);cout &amp;lt;&amp;lt; downhill(1,1) &amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
    <item>
      <title>[백준]1965 상자넣기</title>
      <link>https://jyukki97.github.io/blog/2017-12-01-1965/</link>
      <pubDate>Fri, 01 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-12-01-1965/</guid>
      <description>https://www.acmicpc.net/problem/1965
풀이:  b[i] 가 i 번째 상자를 골랐을 때의 상자의 최대 갯수라고 하자. b[i] = b[i] + 0~i 번째 까지 중 가장 큰 값 이다.  코드: #include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;int main(void) {int n,temp;cin &amp;gt;&amp;gt; n;int a[1001] = { 0 };int b[1001];for (int i = 0; i &amp;lt; n; i++) {cin &amp;gt;&amp;gt; a[i];b[i] = 1;}for (int i = 0; i &amp;lt; n; i++) {temp = 0;for (int t = 0; t &amp;lt;= i; t++) {if (a[i] &amp;gt; a[i - t])temp = max(b[i - t], temp);}b[i] += temp;}for (int i = 0; i &amp;lt; n; i++) {temp = max(b[i], temp);}cout &amp;lt;&amp;lt; temp &amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
    <item>
      <title>[백준]2133 타일 채우기</title>
      <link>https://jyukki97.github.io/blog/2017-12-01-2133/</link>
      <pubDate>Fri, 01 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-12-01-2133/</guid>
      <description>https://www.acmicpc.net/problem/2133
풀이:  N이 홀수라면 타일을 채울 수 없으므로 언제나 0을 출력한다. 짝수일경우 i를 N/2-1 로 생각하고 a[i] = 4 * a[i - 1] - a[i - 2] 로 구한다.  코드: #include &amp;lt;iostream&amp;gt;#include &amp;lt;math.h&amp;gt;using namespace std;int main(void) {int n;long long a[30] = { 3,11,0 };cin &amp;gt;&amp;gt; n;if (n % 2 == 1)cout &amp;lt;&amp;lt; &amp;#34;0&amp;#34; &amp;lt;&amp;lt; endl;else {for (int t = 2; t &amp;lt; n/2; t++) {a[t] = 4*a[t-1] - a[t-2];}cout &amp;lt;&amp;lt; a[n/2-1] &amp;lt;&amp;lt; endl;}return 0;}</description>
    </item>
    
    <item>
      <title>[백준]6359 만취한 상범</title>
      <link>https://jyukki97.github.io/blog/2017-12-01-6359/</link>
      <pubDate>Fri, 01 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-12-01-6359/</guid>
      <description>https://www.acmicpc.net/problem/6359
풀이:  n 개의 방이 있을 때 탈출할 수 있는 사람의 수는 sqrt(n)명이다.  코드: #include &amp;lt;iostream&amp;gt;#include &amp;lt;math.h&amp;gt;using namespace std;int main(void) {int n,T;cin &amp;gt;&amp;gt; T;for (int i = 0; i &amp;lt; T; i++) {cin &amp;gt;&amp;gt; n;cout &amp;lt;&amp;lt; (int)sqrt(n) &amp;lt;&amp;lt; endl;}return 0;}</description>
    </item>
    
    <item>
      <title>[백준]10844 쉬운 계단 수</title>
      <link>https://jyukki97.github.io/blog/2017-11-30-10844/</link>
      <pubDate>Thu, 30 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-11-30-10844/</guid>
      <description>https://www.acmicpc.net/problem/10844
풀이:  a[i][t] 는 길이가 i인 숫자에서 1의 자릿 수가 t일 때의 경우의 수 t가 0 이면 a[i][t] = a[i - 1][t + 1] t가 9 이면 a[i][t] = a[i - 1][t - 1] 둘다 아니면 a[i][t] = (a[i - 1][t - 1] + a[i - 1][t + 1]) 이 때 오버플로우가 발생하므로 각각의 계산에 1000000000을 나눠준다.  코드: #include &amp;lt;iostream&amp;gt;using namespace std;long long a[101][10] = { 0 };int main(void) {int n;cin &amp;gt;&amp;gt; n;long long cnt = 0;for (int i = 1; i &amp;lt; 10; i++) {a[0][i] = 1;}for (int i = 1; i &amp;lt; n; i++) {for (int t = 0; t &amp;lt; 10; t++) {if (t == 0)a[i][t] = a[i - 1][t + 1] % 1000000000;else if (t == 9)a[i][t] = a[i - 1][t - 1] % 1000000000;elsea[i][t] = (a[i - 1][t - 1] + a[i - 1][t + 1]) % 1000000000;}}for (int i = 0; i &amp;lt; 10; i++) {cnt += a[n - 1][i] % 1000000000;}cout &amp;lt;&amp;lt; cnt % 1000000000 &amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
    <item>
      <title>[백준]11057 오르막수</title>
      <link>https://jyukki97.github.io/blog/2017-11-30-11057/</link>
      <pubDate>Thu, 30 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-11-30-11057/</guid>
      <description>https://www.acmicpc.net/problem/11057
풀이:  a[i][t] 는 길이가 i인 수에서 1의 자리가 t인 수의 오르막 수의 개수 a[i][t] += max(a[i - 1][t], a[i][t - 1]);  코드: #include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;int a[1002][1002] = { 0 };int main(void) {int n, m;cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;for (int i = 1; i &amp;lt;= n; i++) {for (int t = 1; t &amp;lt;= m; t++) {cin &amp;gt;&amp;gt; a[i][t];}}for (int i = 1; i &amp;lt;= n; i++) {for (int t = 1; t &amp;lt;= m; t++) {a[i][t] += max(a[i - 1][t], a[i][t - 1]);}}cout &amp;lt;&amp;lt; a[n][m] &amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
    <item>
      <title>[백준]11727 2xN 타일링2</title>
      <link>https://jyukki97.github.io/blog/2017-11-30-11727/</link>
      <pubDate>Thu, 30 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-11-30-11727/</guid>
      <description>https://www.acmicpc.net/problem/11727
풀이:  a[i] 는 타일이 2xi 일때의 경우의 수 a[i] = (2 * a[i - 2] + a[i - 1] 주어진 조건에서 10007으로 나눈 나머지를 출력하라고 하였으므로 나눠줌.  코드: #include &amp;lt;iostream&amp;gt;using namespace std;int a[1001] = { 1,3,0 };int main(void) {int n;cin &amp;gt;&amp;gt; n;for (int i = 2; i &amp;lt; n; i++) {a[i] = (2 * a[i - 2] + a[i - 1])%10007;}cout &amp;lt;&amp;lt; a[n - 1] &amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
    <item>
      <title>[백준]1699 제곱수의 합</title>
      <link>https://jyukki97.github.io/blog/2017-11-30-1699/</link>
      <pubDate>Thu, 30 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-11-30-1699/</guid>
      <description>https://www.acmicpc.net/problem/1699
풀이:  q[i] 는 i 일 때 제곱수로 나타낼 수 있는 최소의 경우의 수 n 이 i + t^2 으로 나타내 질 때, 최소의 경우의 수를 찾음  코드: #include &amp;lt;iostream&amp;gt;#include &amp;lt;math.h&amp;gt;int q[100002] = { 0 };using namespace std;int main(void) {int n,a;cin &amp;gt;&amp;gt; n;a = sqrt(n);for (int i = 1; i &amp;lt;= n; i++){q[i] = 10001;for (int t = 1; t &amp;lt;= a; t++){if (i == t*t)q[i] = 1;}}for (int i = 1; i &amp;lt;= n; i++){for (int t = 1; t &amp;lt;= a; t++){if (i + (t*t) &amp;lt;= n &amp;amp;&amp;amp; q[i + (t*t)] &amp;gt; q[i] + 1)q[i + (t*t)] = q[i] + 1;}}cout &amp;lt;&amp;lt; q[n] &amp;lt;&amp;lt; endl;}</description>
    </item>
    
    <item>
      <title>[백준]1912 연속합</title>
      <link>https://jyukki97.github.io/blog/2017-11-30-1912/</link>
      <pubDate>Thu, 30 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-11-30-1912/</guid>
      <description>https://www.acmicpc.net/problem/1912
풀이:  a[i] 는 i번째를 골랐을 때, 최대값 만약 a[i-1] 이 0 보다 크다면, a[i] += a[i-1]  코드: #include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;int a[100001] = { 0 };int main(void) {int n;cin &amp;gt;&amp;gt; n;for (int i = 0; i &amp;lt; n; i++) {cin &amp;gt;&amp;gt; a[i];}int temp = a[0];for (int i = 1; i &amp;lt; n; i++) {if(a[i-1] &amp;gt; 0)a[i] += a[i - 1];temp = max(temp, a[i]);}cout &amp;lt;&amp;lt; temp &amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
    <item>
      <title>[백준]2163 초콜릿 자르기</title>
      <link>https://jyukki97.github.io/blog/2017-11-30-2163/</link>
      <pubDate>Thu, 30 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-11-30-2163/</guid>
      <description>https://www.acmicpc.net/problem/2163
풀이:  N x M 크기의 초콜릿을 자르는 최소의 경우의 수 N * M - 1  코드: #include &amp;lt;iostream&amp;gt;using namespace std;int main(void) {int n, m;cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;cout &amp;lt;&amp;lt; n*m - 1 &amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
    <item>
      <title>[백준]9461 파도반 수열</title>
      <link>https://jyukki97.github.io/blog/2017-11-30-9461/</link>
      <pubDate>Thu, 30 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-11-30-9461/</guid>
      <description>https://www.acmicpc.net/problem/9461
풀이:  a[i] 는 i 번째 수열 a[i] = a[i-1] + a[i-5]  코드: #include &amp;lt;iostream&amp;gt;using namespace std;long long a[101] = { 1,1,1,2,2,0 };int main(void) {int T,n;cin &amp;gt;&amp;gt; T;for (int i = 0; i &amp;lt; T; i++) {cin &amp;gt;&amp;gt; n;for (int t = 5; t &amp;lt; n; t++) {a[t] = a[t - 1] + a[t - 5];}cout &amp;lt;&amp;lt; a[n - 1] &amp;lt;&amp;lt; endl;}return 0;}</description>
    </item>
    
    <item>
      <title>[백준]2156 포도주 시식</title>
      <link>https://jyukki97.github.io/blog/2017-11-29-2156/</link>
      <pubDate>Wed, 29 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-11-29-2156/</guid>
      <description>https://www.acmicpc.net/problem/2156
풀이:  b[i][0] 은 i번째를 골랐을 때, i-1번째를 안고른 경우의 수 b[i][1] 은 i번째를 골랐을 때, i-1번째를 고른 경우의 수 b[i][2] 은 i번째를 골랐을 때, i-2번째를 안고른 경우의 수  코드: #include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;int main(void) {int n;cin &amp;gt;&amp;gt; n;int a[10001];for (int i = 0; i &amp;lt; n; i++) {cin &amp;gt;&amp;gt; a[i];}int b[10001][3] = { a[0],a[0],a[0],a[1],a[0] + a[1],a[1],0 };int temp;for (int i = 2; i &amp;lt; n; i++) {for (int t = 0; t &amp;lt; 3; t++) {if (t == 0) {temp = max(b[i - 2][0], b[i - 2][1]);b[i][t] = max(temp, b[i - 2][2]) + a[i];}if (t == 1)b[i][t] = max(b[i - 1][0], b[i - 1][2]) + a[i];if (t == 2)b[i][t] = b[i - 3][1] + a[i];}}temp = max(b[n - 1][0], b[n - 2][1]);temp = max(temp, b[n - 1][1]);cout &amp;lt;&amp;lt; max(temp, b[n - 1][2]) &amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
    <item>
      <title>[백준]1003 피보나치 함수</title>
      <link>https://jyukki97.github.io/blog/2017-11-28-1003/</link>
      <pubDate>Tue, 28 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-11-28-1003/</guid>
      <description>https://www.acmicpc.net/problem/1003
풀이:  0이 쓰이면 카운트 0을 ++ 1이 쓰이면 카운트 1을 ++  코드: #include &amp;lt;iostream&amp;gt;	// 재귀를 이용using namespace std;int cnt[2] = { 0 };int fibonacci(int n) {if (n == 0) {cnt[0]++;return 0;}else if (n == 1) {cnt[1]++;return 1;}elsereturn fibonacci(n-1) + fibonacci(n-2);}int main(void) {int T,n;cin &amp;gt;&amp;gt; T;for (int i = 0; i &amp;lt; T; i++) {cin &amp;gt;&amp;gt; n;cnt[0] = 0;cnt[1] = 0;fibonacci(n);cout &amp;lt;&amp;lt; cnt[0] &amp;lt;&amp;lt; &amp;#34;&amp;#34; &amp;lt;&amp;lt; cnt[1] &amp;lt;&amp;lt; endl;}return 0;}}#include &amp;lt;iostream&amp;gt;	// 포문 이용using namespace std;int main(void) {int T, n;int a[41] = { 0 };int b[41] = { 0 };cin &amp;gt;&amp;gt; T;for (int i = 0; i &amp;lt; T; i++) {cin &amp;gt;&amp;gt; n;a[0] = 1;a[1] = 0;b[0] = 0;b[1] = 1;for (int t = 2; t &amp;lt;= n; t++) {a[t] = a[t - 1] + a[t - 2];b[t] = b[t - 1] + b[t - 2];}cout &amp;lt;&amp;lt; a[n] &amp;lt;&amp;lt; &amp;#34;&amp;#34; &amp;lt;&amp;lt; b[n] &amp;lt;&amp;lt; endl;}}</description>
    </item>
    
    <item>
      <title>[백준]11726 2×n 타일링</title>
      <link>https://jyukki97.github.io/blog/2017-11-28-11726/</link>
      <pubDate>Tue, 28 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-11-28-11726/</guid>
      <description>https://www.acmicpc.net/problem/11726
풀이:  정수 i를 1,2 의 조합으로 나타낼 수 있는 경우의 수 a[i-1] a[i] = a[i-1] + a[i-2] 으로 구할 수 있다.  코드: #include &amp;lt;iostream&amp;gt;using namespace std;int main(void) {int n;int a[1001] = { 1,2,0 };cin &amp;gt;&amp;gt; n;for (int t = 2; t &amp;lt; n; t++) {a[t] = (a[t - 1] + a[t - 2]) % 10007;}cout &amp;lt;&amp;lt; a[n - 1]&amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
    <item>
      <title>[백준]1463 1로 만들기</title>
      <link>https://jyukki97.github.io/blog/2017-11-28-1463/</link>
      <pubDate>Tue, 28 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-11-28-1463/</guid>
      <description>https://www.acmicpc.net/problem/1463
풀이:  i 일때 연산 횟수를 a[i] 라고 둔다. 2와 3으로 동시에 나눠질때, 따로 나눠질때, 나눠지지 않을때로 나눠서 계산한다. n번까지 연산 후 a[n]을 출력한다.  코드: #include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;int a[1000002] = { 0 };int main(void) {int n;cin &amp;gt;&amp;gt; n;for (int i = 2; i &amp;lt;= n; i++) {if (i % 2 == 0 &amp;amp;&amp;amp; i % 3 == 0) {int temp = min(a[i / 2], a[i / 3]);a[i] = min(temp, a[i - 1]) + 1;}else if(i % 2 == 0 &amp;amp;&amp;amp; i % 3 !</description>
    </item>
    
    <item>
      <title>[백준]9095 1, 2, 3 더하기</title>
      <link>https://jyukki97.github.io/blog/2017-11-28-9095/</link>
      <pubDate>Tue, 28 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-11-28-9095/</guid>
      <description>https://www.acmicpc.net/problem/9095
풀이:  정수 i를 1,2,3의 조합으로 나타낼 수 있는 경우의 수 a[i-1] a[i] = a[i-1] + a[i-2] + a[i-3] 으로 구할 수 있다.  코드: #include &amp;lt;iostream&amp;gt;using namespace std;int main(void) {int T,n;cin &amp;gt;&amp;gt; T;for (int i = 0; i &amp;lt; T; i++) {int a[11] = { 1,2,4,0 };cin &amp;gt;&amp;gt; n;for (int t = 3; t &amp;lt; n; t++) {a[t] = a[t - 1] + a[t - 2] + a[t - 3];}cout &amp;lt;&amp;lt; a[n - 1] &amp;lt;&amp;lt; endl;}return 0;}</description>
    </item>
    
    <item>
      <title>[백준]1149 RGB거리</title>
      <link>https://jyukki97.github.io/blog/2017-11-27-1149/</link>
      <pubDate>Mon, 27 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-11-27-1149/</guid>
      <description>https://www.acmicpc.net/problem/1149
풀이:  r,g,b를 각각 b[0], b[1], b[2] 로 둠. r을 선택했다면 이전에서 g,b 중 작은값에 이번에 r값을 더하는 식으로 r,g,b 반복 r,g,b 최종값에서 가장 최소값 출력  코드: #include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;int main(void) {int n;cin &amp;gt;&amp;gt; n;int a[3001];int b[3];for (int i = 0; i &amp;lt; n*3; i++) {cin &amp;gt;&amp;gt; a[i];}for (int i = 1; i &amp;lt; n; i++) {b[0] = a[0];b[1] = a[1];b[2] = a[2];a[0] = min(b[1], b[2]) + a[i * 3];a[1] = min(b[0], b[2]) + a[(i * 3) + 1];a[2] = min(b[0], b[1]) + a[(i * 3) + 2];}int temp = min(a[0], a[1]);cout &amp;lt;&amp;lt; min(temp, a[2]) &amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
    <item>
      <title>[백준]11052 붕어빵 판매하기</title>
      <link>https://jyukki97.github.io/blog/2017-11-26-11052/</link>
      <pubDate>Sun, 26 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-11-26-11052/</guid>
      <description>https://www.acmicpc.net/problem/11052
풀이:  붕어의 개수가 i개 일 때를 b[i] 라고 놓고 b[i] = (t개 일때 가격 + 남은 붕어 빵의 가격) 과 b[i] 개중 큰값을 넣음. 구하고자 하는 n개 즉 b[n]을 찾음.  코드: #include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;int main(void) {int n, m, w;int a[1002];int b[1002] = { 0 };cin &amp;gt;&amp;gt; n;for (int i = 1; i &amp;lt;= n; i++) {cin &amp;gt;&amp;gt; a[i];}for (int i = 1; i &amp;lt;= n; i++) {for (int t = 0; t &amp;lt; i; t++) {b[i] = max(b[i], b[t] + a[i - t]);}}cout &amp;lt;&amp;lt; b[n] &amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
    <item>
      <title>[백준]1004 어린왕자</title>
      <link>https://jyukki97.github.io/blog/2017-11-25-1004/</link>
      <pubDate>Sat, 25 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-11-25-1004/</guid>
      <description>https://www.acmicpc.net/problem/1004
풀이:  시작점과 도착점이 같이 원안에 있지않을 때, 시작점, 도착점이 원 안에 있다면 카운트를 ++  코드: #include &amp;lt;iostream&amp;gt;#include &amp;lt;math.h&amp;gt;using namespace std;int main(void) {int T;cin &amp;gt;&amp;gt; T;for (int i = 0; i &amp;lt; T; i++) {int n, x1, x2, y1, y2;int x[50];int y[50];int r[50];int count = 0;cin &amp;gt;&amp;gt; x1 &amp;gt;&amp;gt; y1 &amp;gt;&amp;gt; x2 &amp;gt;&amp;gt; y2 &amp;gt;&amp;gt; n;for (int t = 0; t &amp;lt; n; t++) {cin &amp;gt;&amp;gt; x[t] &amp;gt;&amp;gt; y[t] &amp;gt;&amp;gt; r[t];}for (int t = 0; t &amp;lt; n; t++) {if (sqrt((x1 - x[t])*(x1 - x[t]) + (y1 - y[t])*(y1 - y[t])) &amp;lt; r[t]) {if (sqrt((x2 - x[t])*(x2 - x[t]) + (y2 - y[t])*(y2 - y[t])) &amp;gt;= r[t])count++;}if (sqrt((x2 - x[t])*(x2 - x[t]) + (y2 - y[t])*(y2 - y[t])) &amp;lt; r[t]) {if (sqrt((x1 - x[t])*(x1 - x[t]) + (y1 - y[t])*(y1 - y[t])) &amp;gt;= r[t])count++;}}cout &amp;lt;&amp;lt; count &amp;lt;&amp;lt; endl;}return 0;}</description>
    </item>
    
    <item>
      <title>[백준]1010 다리놓기</title>
      <link>https://jyukki97.github.io/blog/2017-11-25-1010/</link>
      <pubDate>Sat, 25 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-11-25-1010/</guid>
      <description>https://www.acmicpc.net/problem/1010
풀이:  서쪽 다리(N)에서 동쪽 다리(M)로 연결 이므로 조합인 mCn 을 사용  코드: #include &amp;lt;iostream&amp;gt;using namespace std;int Comb(int n, int r) {if (r == 0 || r == n)return 1;else if (r == n - 1 || r == 1)return n;return Comb(n - 1, r) + Comb(n - 1, r - 1);}int main(void) {int T,n,m;cin &amp;gt;&amp;gt; T;for (int i = 0; i &amp;lt; T; i++) {cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;cout &amp;lt;&amp;lt; Comb(m, n) &amp;lt;&amp;lt; endl;}return 0;}</description>
    </item>
    
    <item>
      <title>[백준]1718 암호</title>
      <link>https://jyukki97.github.io/blog/2017-11-25-1718/</link>
      <pubDate>Sat, 25 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-11-25-1718/</guid>
      <description>https://www.acmicpc.net/problem/1718
풀이:  평문에서 암호문을 뺀다. 만약 뺀 값이 0 이하일경우 z로 돌아간다.  코드: #include &amp;lt;iostream&amp;gt;#include &amp;lt;string&amp;gt;using namespace std;int main(void) {string a;getline(cin, a);string key;cin &amp;gt;&amp;gt; key;char cy[30001] = { NULL };for (int i = 0; i &amp;lt; a.length(); i++) {if (a[i] == &amp;#39;&amp;#39;)cy[i] = &amp;#39;&amp;#39;;else if ((int)a[i] - (int)key[i%key.length()] &amp;lt;= 0)cy[i] = (char)((int)a[i] - (int)key[i%key.length()] + 122);elsecy[i] = (char)((int)a[i] - (int)key[i%key.</description>
    </item>
    
    <item>
      <title>[백준]2578 빙고</title>
      <link>https://jyukki97.github.io/blog/2017-11-25-2578/</link>
      <pubDate>Sat, 25 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-11-25-2578/</guid>
      <description>https://www.acmicpc.net/problem/2578
풀이:  빙고를 저장 사회자가 말하는 번호에 빙고판에 1 저장 빙고판 가로 세로 대각선 2개 판별 빙고가 3개 넘어가면 끝  코드: #include &amp;lt;iostream&amp;gt;#include &amp;lt;map&amp;gt;using namespace std;int main(void) {map&amp;lt;int, int&amp;gt; a;int b[25] = { 0 };int c[25];int num;int count = 0;for (int i = 0; i &amp;lt; 25; i++) {cin &amp;gt;&amp;gt; num;a[num] = i;}for (int i = 0; i &amp;lt; 25; i++) {cin &amp;gt;&amp;gt; num;b[a[num]] = 1;if (b[(a[num] / 5) * 5] == 1 &amp;amp;&amp;amp; b[((a[num] / 5) * 5) + 1] == 1 &amp;amp;&amp;amp; b[((a[num] / 5) * 5) + 2] == 1 &amp;amp;&amp;amp; b[((a[num] / 5) * 5) + 3] == 1 &amp;amp;&amp;amp; b[((a[num] / 5) * 5) + 4] == 1)count++;if (b[a[num] % 5] == 1 &amp;amp;&amp;amp; b[a[num] % 5 + 5] == 1 &amp;amp;&amp;amp; b[a[num] % 5 + 10] == 1 &amp;amp;&amp;amp; b[a[num] % 5 + 15] == 1 &amp;amp;&amp;amp; b[a[num] % 5 + 20] == 1)count++;if ((a[num] % 4 == 0 &amp;amp;&amp;amp; a[num] !</description>
    </item>
    
    <item>
      <title>[백준]1932 숫자삼각형</title>
      <link>https://jyukki97.github.io/blog/2017-11-24-1932/</link>
      <pubDate>Fri, 24 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-11-24-1932/</guid>
      <description>https://www.acmicpc.net/problem/1932
풀이:  첫 줄부터 밑에줄까지 내려가면서 값을 더해감 더한 값중 제일 큰 값을 찾음  코드: #include &amp;lt;iostream&amp;gt;using namespace std;int q[501][501];int good[501][501];int main(void){int num;int big = 0;cin &amp;gt;&amp;gt; num;for (int i = 0; i &amp;lt; num; i++){for (int t = 0; t &amp;lt; i + 1; t++){cin &amp;gt;&amp;gt; q[i][t];}}good[0][0] = q[0][0];for (int i = 1; i &amp;lt; num; i++){for (int t = 0; t &amp;lt; i+1; t++){if(t==0)good[i][t] = good[i - 1][t] + q[i][t];else if (i == t)good[i][t] = good[i - 1][t - 1] + q[i][t];else{if (good[i - 1][t - 1] &amp;gt; good[i - 1][t])good[i][t] = good[i - 1][t - 1] + q[i][t];elsegood[i][t] = good[i - 1][t] + q[i][t];}}}for (int i = 0; i &amp;lt; num; i++){if (good[num - 1][i] &amp;gt; big)big = good[num - 1][i];}cout &amp;lt;&amp;lt; big &amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
    <item>
      <title>[백준]2293 동전1</title>
      <link>https://jyukki97.github.io/blog/2017-11-23-2293/</link>
      <pubDate>Thu, 23 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-11-23-2293/</guid>
      <description>https://www.acmicpc.net/problem/2293
풀이:  첫번째 동전부터 경우의 수를 더해감.  코드: #include &amp;lt;iostream&amp;gt;using namespace std;int coin[10001] = { 0 };int main(void){int a;int num;cin &amp;gt;&amp;gt; a;cin &amp;gt;&amp;gt; num;int *q = new int[a];for (int i = 0; i &amp;lt; a; i++){cin &amp;gt;&amp;gt; q[i];}for (int i = 0; i &amp;lt;= num; i++){if (i%q[0] == 0)coin[i]++;}for (int i = 1; i &amp;lt; a; i++){for (int t = q[i]; t &amp;lt;= num; t++){coin[t] += coin[t - q[i]];}}cout &amp;lt;&amp;lt; coin[num] &amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
    <item>
      <title>[백준]3613 Java vs C&#43;&#43;</title>
      <link>https://jyukki97.github.io/blog/2017-11-22-3613/</link>
      <pubDate>Wed, 22 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-11-22-3613/</guid>
      <description>https://www.acmicpc.net/problem/3613
풀이:  java 변수면 c++로 c++ 이면 java로 변경 예외처리  코드: #include &amp;lt;iostream&amp;gt;#include &amp;lt;string.h&amp;gt;using namespace std;int main(void) {char a[201];char b[201] = {&amp;#39;\n&amp;#39;};bool java = false;bool cplus = false;bool ero = true;cin &amp;gt;&amp;gt; a;int t = 0;for (int i = 0; i &amp;lt; strlen(a); i++) {if (65 &amp;lt;= (int)a[i] &amp;amp;&amp;amp; (int)a[i] &amp;lt;= 90) {if (i == 0 || cplus == true) {ero = false;break;}b[t] = &amp;#39;_&amp;#39;;t++;b[t] = a[i] + 32;java = true;}else if (a[i] == &amp;#39;_&amp;#39;) {if (i == 0 || i == strlen(a)-1 || a[i + 1] == &amp;#39;_&amp;#39; || java == true || (65 &amp;lt;= (int)a[i + 1] &amp;amp;&amp;amp; (int)a[i + 1] &amp;lt;= 90)) {ero = false;break;}b[t] = a[i + 1] - 32;i++;cplus = true;}else b[t] = a[i];t++;}if (ero == false)cout &amp;lt;&amp;lt; &amp;#34;Error!</description>
    </item>
    
    <item>
      <title>[sw]사다리</title>
      <link>https://jyukki97.github.io/blog/2017-11-21-sw-1210/</link>
      <pubDate>Tue, 21 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-11-21-sw-1210/</guid>
      <description>https://www.swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AV14ABYKADACFAYh&amp;amp;
풀이:  int[100][100] 배열에 사다리를 저장 사다리 끝에 있는 도착점을 찾음 사다리 위로 올라가며 옆에 길이 있나 확인 맨 위에 x값을 출력  코드: #include &amp;lt;iostream&amp;gt;#include &amp;lt;string&amp;gt;using namespace std;int lineup(int n[100][100], int yc, int xc, bool left, bool right) {if (yc == 0)return xc;if (xc &amp;gt; 0 &amp;amp;&amp;amp; right == false &amp;amp;&amp;amp; n[yc][xc - 1] == 1)return lineup(n, yc, xc - 1,true,false);else if (xc &amp;lt; 99 &amp;amp;&amp;amp; left==false &amp;amp;&amp;amp; n[yc][xc + 1] == 1)return lineup(n, yc, xc + 1,false,true);elsereturn lineup(n, yc - 1, xc,false,false);}int main(void) {for (int t = 1; t &amp;lt; 11; t++) {int a;cin &amp;gt;&amp;gt; a;int line[100][100];int count;for (int i = 0; i &amp;lt; 100; i++) {for (int y = 0; y &amp;lt; 100; y++) {cin &amp;gt;&amp;gt; line[i][y];}}for (int i = 0; i &amp;lt; 100; i++) {if (line[99][i] == 2) {count = i;break;}}cout &amp;lt;&amp;lt; &amp;#34;#&amp;#34; &amp;lt;&amp;lt; t &amp;lt;&amp;lt; &amp;#34;&amp;#34; &amp;lt;&amp;lt; lineup(line, 98, count, false, false) &amp;lt;&amp;lt; endl;}return 0;}}</description>
    </item>
    
    <item>
      <title>[백준]1065 한수</title>
      <link>https://jyukki97.github.io/blog/2017-11-20-1065/</link>
      <pubDate>Mon, 20 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-11-20-1065/</guid>
      <description>https://www.acmicpc.net/problem/1065
풀이: 한수이면 카운트를 ++ 하는 함수를 만듦
코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;using namespace std;int hannum(int n, int c) {int b = (n % 1000) / 100;int d = ((n % 1000) % 100) / 10;int f = ((n % 1000) % 100) % 10;if (n &amp;gt; 99) {if ((b - d == d - f) &amp;amp;&amp;amp; n != 1000)c++;}elsec++;if (n == 1)return c;elsereturn hannum(n - 1, c);}int main(void) {int a;cin &amp;gt;&amp;gt; a;cout &amp;lt;&amp;lt; hannum(a, 0);return 0;}</description>
    </item>
    
    <item>
      <title>[백준]1475 방번호</title>
      <link>https://jyukki97.github.io/blog/2017-11-20-1475/</link>
      <pubDate>Mon, 20 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-11-20-1475/</guid>
      <description>https://www.acmicpc.net/problem/1475
풀이:  방번호를 string에 저장 string 첫번째 자릿수부터 숫자를 확인 숫자에 맞는 배열에 ++ 배열에서 가장 큰 숫자를 가지고 있는 값을 출력  코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;string&amp;gt;using namespace std;int main(void) {string a;int b[10] = { 0 };cin &amp;gt;&amp;gt; a;for (int i = 0; i &amp;lt; a.length(); i++) {if (((int)a[i] - 48) == 6 &amp;amp;&amp;amp; b[6] &amp;gt; b[9])b[9] ++;else if (((int)a[i] - 48) == 9 &amp;amp;&amp;amp; b[6] &amp;lt; b[9])b[6] ++;elseb[(int)a[i] - 48]++;}int count = 0;for (int i = 0; i &amp;lt; 10; i++) {if (b[i] &amp;gt; count)count = b[i];}cout &amp;lt;&amp;lt; count &amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
    <item>
      <title>[백준]2098 외판원 순회</title>
      <link>https://jyukki97.github.io/blog/2019-06-01-2098/</link>
      <pubDate>Mon, 20 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-06-01-2098/</guid>
      <description>https://www.acmicpc.net/problem/2098
풀이:  dp[a][b]를 현제 위치가 a이고, 이때까지 방문한 도시들의 목록이 b인 여행비용의 최솟값이라고 한다. 방문한 도시들을 쉽게 나타내기 위해 비트마스크를 사용하였다. 최솟값을 구하는 문제이므로 r을 최대한 큰 수로 두고 min함수를 이용한다. 도시의 비용이 0인 경우 방문할 수 없으므로 제외시킨다. 방문 횟수가 많아 시간초과가 날 수 있으므로 메모이제이션을 한다. 순회 문제이기 때문에 시작위치는 상관없으므로 실행시간을 늘리지 않도록 주의한다.  코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;int w[17][17],d[17][100000], n;int T(int a, int b) {if ((1 &amp;lt;&amp;lt; n) - 1 == b &amp;amp;&amp;amp; w[a][0] !</description>
    </item>
    
    <item>
      <title>[백준]9507 Generations of Tribbles</title>
      <link>https://jyukki97.github.io/blog/2017-12-18-9507/</link>
      <pubDate>Mon, 20 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-12-18-9507/</guid>
      <description>https://www.acmicpc.net/problem/9507
풀이:  문제에 DP가 주어져 있으므로 그대로 하면된다. 다만 큰 수가 나오므로 long long을 써야할 것이다.  코드: #include &amp;lt;iostream&amp;gt;using namespace std;long long a[70] = {1,1,2,4,0};int main(void) {int T,n;int cnt = 4;cin &amp;gt;&amp;gt; T;for (int i = 0; i &amp;lt; T; i++) {cin &amp;gt;&amp;gt; n;for (int t = cnt; t &amp;lt; n + 1; t++) {a[t] = a[t - 1] + a[t - 2] + a[t - 3] + a[t - 4];}cout &amp;lt;&amp;lt; a[n] &amp;lt;&amp;lt; endl;cnt = n + 1;}return 0;}</description>
    </item>
    
    <item>
      <title>start</title>
      <link>https://jyukki97.github.io/blog/2017-11-19-start/</link>
      <pubDate>Sun, 19 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-11-19-start/</guid>
      <description>안녕하세요.</description>
    </item>
    
    <item>
      <title>1011 Fly me to the Alpha Centauri</title>
      <link>https://jyukki97.github.io/blog/2018-01-08-1011/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2018-01-08-1011/</guid>
      <description>https://www.acmicpc.net/problem/1011
풀이:  거리가 제곱수 일 때(d = s^2), 그 거리 까지 갈 수 있는 최소 작동수에서 최대 거리는 그 수의 제곱근(s) 이다. 최소 작동수는 대칭일때 만들어지므로 제곱수일 때 최소 작동수는 2*s - 1이 된다. 거리가 제곱수가 아니라면, 거리에서 그 거리보다 작은 제곱수를 뺀 나머지로 계산한다. (d - s^2) / s + 1 즉 제곱수 만큼 간 후 남은 거리를 갈 수 있는 최대 거리인 s로 나눈 값에 올림한 값과 같다.</description>
    </item>
    
    <item>
      <title>1016 제곱 ㄴㄴ 수</title>
      <link>https://jyukki97.github.io/blog/2018-02-05-1016/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2018-02-05-1016/</guid>
      <description>https://www.acmicpc.net/problem/1016
풀이:  min 수 부터 max 까지 제곱수의 배수가 되는 수를 찾는다. max-min+1 에서 위에서 찾은 제곱수의 배수의 개수를 뺀다.  코드: 사용언어 : Python 3
n,m=map(int,input().split())a,b=0,[0]*1000001for i in range(2,int(m**.5)+1):q=nif n%(i*i)!=0:q=(n//(i*i)+1)*i*ifor t in range(q,m+1,i*i):if b[t-n]==0:b[t-n]=1a+=1print(m-n+1-a)</description>
    </item>
    
    <item>
      <title>10569 다면체</title>
      <link>https://jyukki97.github.io/blog/2018-01-28-10569/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2018-01-28-10569/</guid>
      <description>https://www.acmicpc.net/problem/10569
풀이:  면의수 = 2 - 꼭짓점의 수 + 모서리의 수  코드: 사용언어 : Python 3
t=int(input())for i in range(t):v,e=map(int, input().split())print(2-v+e)</description>
    </item>
    
    <item>
      <title>1072 게임</title>
      <link>https://jyukki97.github.io/blog/2018-03-16-1072/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2018-03-16-1072/</guid>
      <description>https://www.acmicpc.net/problem/1072
풀이:  게임횟수 : x, 이긴게임 : y, 더해야하는 판수 a 100 * y/x + 1 = 100 * y+a/x+a 100 * y/x + 1 = c 로 놓고 c = 100 * y+a/x+a cx + ca = 100y + 100a (c - 100)a = 100y - cx a = (100y - cx) / (c - 100) 이렇게 나온 a값을 올림을 하면 더해야하는 판수가 나오게된다.  코드: 사용언어 : c++</description>
    </item>
    
    <item>
      <title>1075 나누기</title>
      <link>https://jyukki97.github.io/blog/2018-01-26-1075/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2018-01-26-1075/</guid>
      <description>https://www.acmicpc.net/problem/1075
풀이:  3자리 이후를 유지한 후 주어진 F로 나누어 지는 최솟값을 구하는 문제 답이 한자리 수일 경우 앞에 0을 붙이는 것을 주의하자.  코드: 사용언어 : Python 3
import mathn = int(input())f = int(input())print(&#39;%02d&#39; % (((math.ceil(((n//100) * 100) / f) * f) % 100)))</description>
    </item>
    
    <item>
      <title>1076 저항</title>
      <link>https://jyukki97.github.io/blog/2018-01-17-1076/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2018-01-17-1076/</guid>
      <description>https://www.acmicpc.net/problem/1076
풀이:  저항에 맞는 값을 하나씩 더한 후 마지막 값에 있는 저항에서 10의 index값만큼 제곱을 한 후 출력  코드: #include &amp;lt;iostream&amp;gt;#include &amp;lt;string&amp;gt;#include &amp;lt;math.h&amp;gt;using namespace std;string b[10] = { &amp;quot;black&amp;quot;, &amp;quot;brown&amp;quot;, &amp;quot;red&amp;quot;, &amp;quot;orange&amp;quot;, &amp;quot;yellow&amp;quot;, &amp;quot;green&amp;quot;, &amp;quot;blue&amp;quot;, &amp;quot;violet&amp;quot;, &amp;quot;grey&amp;quot;, &amp;quot;white&amp;quot; };int main(void) {string a[3];long long temp = 0, go = 0;for (int i = 0; i &amp;lt; 3; i++)cin &amp;gt;&amp;gt; a[i];for (int i = 0; i &amp;lt; 10; i++) {if (b[i] == a[0])temp += i * 10;if (b[i] == a[1])temp += i;if (b[i] == a[2])go += powl(10, i);}cout &amp;lt;&amp;lt; temp * go &amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
    <item>
      <title>10808 알파벳 개수</title>
      <link>https://jyukki97.github.io/blog/2018-02-04-10808/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2018-02-04-10808/</guid>
      <description>https://www.acmicpc.net/problem/10808
풀이:  알파벳 순서대로 나온 카운트를 계산하여 하나씩 출력  코드: 사용언어 : Python 3
n=input()for i in range(97,123):print(n.count(chr(i)),end=&#39; &#39;)</description>
    </item>
    
    <item>
      <title>1094 막대기</title>
      <link>https://jyukki97.github.io/blog/2018-01-16-1094/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2018-01-16-1094/</guid>
      <description>https://www.acmicpc.net/problem/1094
풀이:  자른 막대기 중 주어진 막대기보다 작은 값 중 최댓값을 주어진 막대기에 계속 뺀다. 뺄때마다 카운트를 증가시키면서 반복한다  코드: #include &amp;lt;iostream&amp;gt;using namespace std;int main(void) {int x, temp = 64, cnt = 0;cin &amp;gt;&amp;gt; x;while (x != 0) {if (x &amp;gt;= temp) {cnt++;x -= temp;}elsetemp /= 2;}cout &amp;lt;&amp;lt; cnt &amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
    <item>
      <title>10987 모음의 개수</title>
      <link>https://jyukki97.github.io/blog/2018-02-04-10987/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2018-02-04-10987/</guid>
      <description>https://www.acmicpc.net/problem/10987
풀이:  모음의 개수를 출력  코드: 사용언어 : Python 3
n=input()print(sum(n.count(i)for i in &#39;aeiou&#39;))</description>
    </item>
    
    <item>
      <title>1100 하얀 칸</title>
      <link>https://jyukki97.github.io/blog/2017-12-22-1100/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-12-22-1100/</guid>
      <description>https://www.acmicpc.net/problem/1100
풀이:  8x8 의 체스칸 중 홀수행 홀수열, 짝수행 짝수열인 곳이 하얀 칸이다. 이 하얀칸 위에 말이 몇개있는지 카운트하여 출력한다.  코드: #include &amp;lt;iostream&amp;gt;using namespace std;char a[8][8];int main(void){ int cnt = 0; for(int i=0;i&amp;lt;8;i++){ for(int j=0;j&amp;lt;8;j++) cin &amp;gt;&amp;gt; a[i][j]; } for(int i=0;i&amp;lt;8;i++){ for(int j=0;j&amp;lt;8;j++){ if(((j%2 == 0 &amp;amp;&amp;amp; i%2 == 0) || (j%2 == 1 &amp;amp;&amp;amp; i%2 == 1)) &amp;amp;&amp;amp; a[i][j] == &#39;F&#39;) cnt ++; } } cout &amp;lt;&amp;lt; cnt &amp;lt;&amp;lt; endl; return 0;}</description>
    </item>
    
    <item>
      <title>11006 남욱의의 닭장</title>
      <link>https://jyukki97.github.io/blog/2018-02-01-11006/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2018-02-01-11006/</guid>
      <description>https://www.acmicpc.net/problem/11006
풀이:  다리가 잘린 닭의 수 : 닭의 수 * 2 - 다리의 수 멀쩡한 닭의 수 : 닭의 수 - 다리가 잘린 닭의 수  코드: 사용언어 : Python 3
t=int(input())for i in range(t):n,m=map(int,input().split())print(m*2-n,m-(m*2-n))</description>
    </item>
    
    <item>
      <title>11048 이동하기</title>
      <link>https://jyukki97.github.io/blog/2017-11-30-11048/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-11-30-11048/</guid>
      <description>+++ author = &amp;ldquo;jyukki&amp;rdquo; categories = [&amp;ldquo;백준&amp;rdquo;] tags = [&amp;ldquo;algorithm&amp;rdquo;, &amp;ldquo;C++&amp;rdquo;, &amp;ldquo;DP&amp;rdquo;] date = &amp;ldquo;2017-11-30&amp;rdquo; description = &amp;ldquo;algorithm&amp;rdquo; featured = &amp;quot;&amp;rdquo; featuredalt = &amp;quot;&amp;rdquo; featuredpath = &amp;ldquo;date&amp;rdquo; linktitle = &amp;quot;&amp;rdquo; title = &amp;ldquo;[백준]11048 이동하기&amp;rdquo; type = &amp;ldquo;post&amp;rdquo;
+++
https://www.acmicpc.net/problem/11048
풀이:  a[i][t] 는 i행 t열로 갈 때 사탕의 최대 갯수 a[i][t] 는 위에서 올때와 왼쪽에서 올때 중 최대값으로 구할 수 있다. a[i][t] += max(a[i - 1][t], a[i][t - 1]);  코드: #include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;int a[1002][1002] = { 0 };int main(void) {int n, m;cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;for (int i = 1; i &amp;lt;= n; i++) {for (int t = 1; t &amp;lt;= m; t++) {cin &amp;gt;&amp;gt; a[i][t];}}for (int i = 1; i &amp;lt;= n; i++) {for (int t = 1; t &amp;lt;= m; t++) {a[i][t] += max(a[i - 1][t], a[i][t - 1]);}}cout &amp;lt;&amp;lt; a[n][m] &amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
    <item>
      <title>11656 접미사 배열</title>
      <link>https://jyukki97.github.io/blog/2018-02-04-11656/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2018-02-04-11656/</guid>
      <description>https://www.acmicpc.net/problem/11656
풀이:  접미사를 모두 리스트에 넣는다. 리스트를 사전순으로 정렬하고 출력한다.  코드: 사용언어 : Python 3
n=input()l=[]for i in range(len(n)):l.append(n[i:])l.sort()for i in range(len(n)):print(l[i])</description>
    </item>
    
    <item>
      <title>1267 핸드폰 요금</title>
      <link>https://jyukki97.github.io/blog/2018-03-16-1267/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2018-03-16-1267/</guid>
      <description>https://www.acmicpc.net/problem/1267
풀이:  핸드폰 사용시간을 각각 요금제 시간에 맞게 나눈 몫을 구한다 몫을 요금제에 가격에 곱하고 그 가격을 비교한다.  코드: 사용언어 : Python 3
a,c,d=int(input()),0,0b=list(map(int,input().split()))for i in range(a):c+=b[i]//30+ 1d+=b[i]//60+ 1if(c*10&amp;lt;d*15):print(&amp;quot;Y %d&amp;quot; % (c*10))elif(c*10==d*15):print(&amp;quot;Y M %d&amp;quot; % (c*10))else:print(&amp;quot;M %d&amp;quot; % (d*15))</description>
    </item>
    
    <item>
      <title>1297 TV 크기</title>
      <link>https://jyukki97.github.io/blog/2018-02-06-1297/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2018-02-06-1297/</guid>
      <description>https://www.acmicpc.net/problem/1297
풀이:  대각선길이, 높이비율, 너비비율을 각각 a,b,c라고 할 때 a^2 = (bx)^2 + (cx)^2 로 나타낼 수 있다. 이때 x 값이 a/((bb+cc)^0.5) 로 나타내지고 진짜 길이를 각각 bx, cx로 나타낼 수 있다.  코드: 사용언어 : Python 3
a,b,c=map(int,input().split())x=a/((b*b+c*c)**.5)print(&amp;quot;%d %d&amp;quot;%(int(b*x),int(c*x)))</description>
    </item>
    
    <item>
      <title>1302 베스트셀러</title>
      <link>https://jyukki97.github.io/blog/2018-01-31-1302/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2018-01-31-1302/</guid>
      <description>https://www.acmicpc.net/problem/1302
풀이:  문자열을 하루 동안 팔린 책의 개수 N만큼 받아드린다. 책 제목이 같을경우 책의 개수를 1씩 증가시킨다. 팔린 책의 개수가 가장 많은 책을 출력한다. 만약 팔린 책의 개수가 같다면 사전순으로 먼저 나오는 것을 출력한다.  코드: 사용언어 : Python 3
n=int(input())s={}q=&#39;&#39;w=0for i in range(n):k=input()if(k in s):s[k]+=1else:s[k]=1if(s[k]&amp;gt;w):w=s[k]q=kelif(s[k]==w):if(q&amp;gt;k):q=kprint(q)</description>
    </item>
    
    <item>
      <title>1315 RPG</title>
      <link>https://jyukki97.github.io/blog/2017-12-28-1315/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-12-28-1315/</guid>
      <description>https://www.acmicpc.net/problem/1315
풀이:  a[i][t] : 힘이 i이고, 지력이 t일 때, 깰 수 있는 퀘스트의 수 초기 능력치를 S, I 라고 했을 때, 깰 수 있는 퀘스트를 모두 클리어한다. 클리어 한 후 모인 스텟 포인트를 힘과 지력에 포인트를 적절히 분배한다. 분배한 힘과 지력으로 못 깬 퀘스트를 클리어 할 수 있는지 확인한다.  주의 사항:  시간이 너무 많이 걸리므로 메모이제이션을 통해 a[i][t] 가 값을 가지고 있다면 바로 리턴하도록 만든다. 이전에 방문했었던 visit이 누적될 수 있으므로 초기화해주는 것을 잊지말자.</description>
    </item>
    
    <item>
      <title>1357 뒤집힌 덧셈</title>
      <link>https://jyukki97.github.io/blog/2018-02-04-1357/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2018-02-04-1357/</guid>
      <description>https://www.acmicpc.net/problem/1357
풀이:  두 숫자를 뒤집어서 입력을 받는다. 입력받은 두 숫자를 더한 후 다시 뒤집는다.  코드: 사용언어 : Python 3
x,y=map(int,input()[::-1].split())print(int(str(x+y)[::-1]))```</description>
    </item>
    
    <item>
      <title>1398 동전 문제</title>
      <link>https://jyukki97.github.io/blog/2018-01-04-1398/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2018-01-04-1398/</guid>
      <description>https://www.acmicpc.net/problem/1398
풀이:  a[i] : i원의 가격의 차를 사기위한 동전 개수의 최솟값 동전의 크기가 1, 10 25, 100, 1000, 2500 &amp;hellip;. 즉, 1, 10, 25가 100단위로 바뀌고있다. 이를 토대로 뒤의 2자리만 계산하여 구한다. cnt += a[n % 100] 10에 자리까지의 동전 개수를 구한 후 n을 100으로 나누고 계속 10에 자리까지의 동전 개수를 구한다.  코드: #include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;int a[101] = { 0 }, b[3] = { 1,10,25 };int main(void) {int T;cin &amp;gt;&amp;gt; T;for (int t = 1; t &amp;lt; 100; t++) {a[t] = INT32_MAX;for (int y = 0; y &amp;lt; 3; y++) {if (t - b[y] &amp;gt;= 0) a[t] = min(a[t], a[t - b[y]] + 1);}}for (int i = 0; i &amp;lt; T; i++) {long long n;int cnt = 0;cin &amp;gt;&amp;gt; n;while (n &amp;gt; 0) {cnt += a[n % 100];n /= 100;}cout &amp;lt;&amp;lt; cnt &amp;lt;&amp;lt; endl;}return 0;}</description>
    </item>
    
    <item>
      <title>14501 퇴사</title>
      <link>https://jyukki97.github.io/blog/2019-05-25-14501/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-05-25-14501/</guid>
      <description>https://www.acmicpc.net/problem/14501
풀이:  남은일이 N일 일때, M일의 상담을 완료하는데 걸리는 기간을 T(M)라고 가정한다. 1일에 상담을 했다면 할 수 있는 상담은 1+T(1) ~ N 까지가 있다. 1+T(1) 일에 상담을 했다면 할 수 있는 삼담은 1 + T(1) + T(1+T(1) ~ N 까지가 있다. N을 넘지않도록 주의하며 반복한 후 받을 수 있는 금액에 최대를 출력한다.  코드: 사용언어 : c++ {% highlight c++ %} #include using namespace std; int a, b[16], c[16]; int ts(int q) { int max = 0; for (int i = q; i &amp;lt; a; i++) { int w = c[i] + ts(i + b[i]); if (i + b[i] &amp;gt; a) w = 0; max = max &amp;gt; w ?</description>
    </item>
    
    <item>
      <title>1568 새</title>
      <link>https://jyukki97.github.io/blog/2018-01-30-1568/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2018-01-30-1568/</guid>
      <description>https://www.acmicpc.net/problem/1568
풀이:  처음 새의 수 n에서 숫자 k를 노래할 때 나중 새의 수 = n - k 노래의 숫자 수를 1씩 증가시켜가며 새의 수보다 많아질 경우 1로 돌아간다. 만약 새의 수가 0이되면 카운트를 출력한다.  코드: 사용언어 : Python 3
k=int(input())cnt,s=0,1while True:if k==0:breakif s&amp;gt;k:s=1cnt+=1k-=ss+=1print(cnt)</description>
    </item>
    
    <item>
      <title>1629 곱셈</title>
      <link>https://jyukki97.github.io/blog/2018-02-05-1629/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2018-02-05-1629/</guid>
      <description>https://www.acmicpc.net/problem/1629
풀이:  a, 19 일 때 a*a^18 a*(a^9)^2 a*(a*(a^4)^2)^2 a*(a*((a^2)^2)^2)^2 이런 식으로 풀면 된다.  코드: pow함수 이용 사용언어 : Python 3
a,b,c=map(int,input().split())print(pow(a,b,c))코드: 사용언어 : Python 3
a,b,c=map(int,input().split())def q(k):if(k==0):return 1w=q(k/2)n=(w*w)%cif(k%2):n=(n*a)%creturn nprint(q(b))</description>
    </item>
    
    <item>
      <title>1660 캡틴 이다솜</title>
      <link>https://jyukki97.github.io/blog/2017-12-31-1660/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-12-31-1660/</guid>
      <description>https://www.acmicpc.net/problem/1660
풀이:  b[i] : i개의 대포알의 개수로 만들 수 있는 사면체의 최소 개수 a[i] : 사면체의 사이즈가 i인 대포알의 개수 b[i] = min(b[i], b[num - a[i]] + 1)  주의사항:  시간초과에 유의하여 메모이제이션을 하도록한다. min함수를 사용하므로 초기값을 매우 크게 잡아주는 것을 잊지말자.  코드: #include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;int a[200] = { 0 }, b[300010] = { 0 }, q = 1;int	cap(int num) {if (num &amp;lt;= 0 )	return 0;if (b[num])	return b[num];b[num] = 300000;for (int i = q; i &amp;gt; 0; i--) {if (a[i] &amp;lt;= num)b[num] = min(b[num], cap(num - a[i]) + 1);}return b[num];}int main(void) {int n, cnt = 1;cin &amp;gt;&amp;gt; n;while(true) {a[q] = a[q - 1] + cnt;cnt += q + 1;if (a[q] &amp;gt; n)break;q++;}cout &amp;lt;&amp;lt; cap(n) &amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
    <item>
      <title>1668 트로피 진열</title>
      <link>https://jyukki97.github.io/blog/2018-01-31-1668/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2018-01-31-1668/</guid>
      <description>https://www.acmicpc.net/problem/1668
풀이:  왼쪽에서부터 높이를 세며, 더 높은 트로피가 나올때마다 카운트를 증가 오른쪽도 똑같이 한 후 카운트를 출력  코드: 사용언어 : Python 3
n,cnt1,cnt2,k1,k2=int(input()),0,0,0,0h={}for i in range(n):h[i]=int(input())for i in range(0,n):if(h[i]&amp;gt;k1):k1=h[i]cnt1+=1if(h[n-1-i]&amp;gt;k2):k2=h[n-1-i]cnt2+=1print(cnt1)print(cnt2)</description>
    </item>
    
    <item>
      <title>1720 타일 코드</title>
      <link>https://jyukki97.github.io/blog/2017-12-23-1720/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-12-23-1720/</guid>
      <description>https://www.acmicpc.net/problem/1720
풀이:  a[i] : 2Xi인 타일을 채울 수 있는 경우의 수(중복 포함) b[i] : 2Xi인 타일을 채울 수 있는 경우의 수(중복 미포함) 짝수 일때와 홀수일때 대칭의 경우의 수가 다르므로 나눠서 계산한다.  코드: #include &amp;lt;iostream&amp;gt;using namespace std;int a[32] = { 1,1,3 };int b[32] = { 1,1,3 };int main(void) {int n;cin &amp;gt;&amp;gt; n;for (int i = 3; i &amp;lt;= n; i++) {a[i] = a[i - 1] + a[i - 2] * 2;b[i] = a[i];}int t = 0;if (n % 2 == 1) {while (n - t &amp;gt;= 2 &amp;amp;&amp;amp; t &amp;lt; n / 2 + 1) {b[n] -= a[n - t - 2];t++;}}else {while (n - t &amp;gt;= 2 &amp;amp;&amp;amp; t + 1 &amp;lt; n / 2) {b[n] -= a[n - t - 2];t++;}}cout &amp;lt;&amp;lt; b[n] &amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
    <item>
      <title>1789 수들의 합</title>
      <link>https://jyukki97.github.io/blog/2018-02-04-1789/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2018-02-04-1789/</guid>
      <description>https://www.acmicpc.net/problem/1789
풀이:  입력받은 숫자를 N 이라고 할 때 (-1 + (1+8*N)^0.5)/2 에 소수점을 버린 값이 최대 개수이다. n(n+1)/2 &amp;gt;= k n^2+n-2k &amp;gt;= 0 n의 최솟값이다.  코드: 사용언어 : Python 3
print(int((-1+(1+8*int(input()))**.5)/2))</description>
    </item>
    
    <item>
      <title>1834 나머지와 몫이 같은 수</title>
      <link>https://jyukki97.github.io/blog/2018-02-05-1834/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2018-02-05-1834/</guid>
      <description>https://www.acmicpc.net/problem/1834
풀이:  나머지와 몫이 같은 수는 N+1에 배수의 형태로 나타난다. 3일때 4,8 , 4일때 5,10,15 등 n+1의 배수가 n-1번 나타난다. 즉 (n+1)Σ(n-1) 이다. (n+1)n(n-1)/2 (n^3-n)/2  코드: 사용언어 : Python 3
n=int(input())print((n**3-n)//2)</description>
    </item>
    
    <item>
      <title>1940 주몽</title>
      <link>https://jyukki97.github.io/blog/2018-02-05-1940/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2018-02-05-1940/</guid>
      <description>https://www.acmicpc.net/problem/1940
풀이:  재료들이 가진 고유의 번호를 가진 리스트를 a라고 하자 이 때 갑옷을 만드는데 필요한 숫자인 M에서 i번째 고유번호인 a[i]를 뺀 값이 리스트 a에 있다면 갑옷을 1개 만들 수 있는 것이므로 카운트를 1 증가시킨다. 계속 증가시키다 보면 서로 짝이되는 수 2개를 모두 카운트를 시키게 되므로 2로 나눠준다.  코드: 사용언어 : Python 3
n,m=int(input()),int(input())a=input().split()print(sum(a.count(str(m-int(a[i])))for i in range(n))//2)</description>
    </item>
    
    <item>
      <title>1947 선물 전달</title>
      <link>https://jyukki97.github.io/blog/2018-01-01-1947/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2018-01-01-1947/</guid>
      <description>https://www.acmicpc.net/problem/1947
풀이:  a[i] : i명이 선물을 나눠갖는 경우의 수 a[i - 1] * (i - 1) : i번 째 사람이 i - 1 번째 사람의 선물을 골랐을 경우 a[i - 2] * (i - 1) : i번 째 사람이 i - 1 번째 사람의 선물을 고르지 않았을 경우  주의사항:  a[1] 일 때 즉, 1명 일 때 경우의 수가 아무것도 하지않는 것 1개일줄 알았으나 0개로 취급. 너무 큰 수가 계산되므로 주어진 수로 나눈 나머지를 출력한다.</description>
    </item>
    
    <item>
      <title>1964 오각형, 오각형, 오각형…</title>
      <link>https://jyukki97.github.io/blog/2018-02-05-1964/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2018-02-05-1964/</guid>
      <description>https://www.acmicpc.net/problem/1964
풀이:  1,5,12,22&amp;hellip;. 더해가는 숫자가 3씩 증가되므로 1+3*Σn+n 이라고 할 수 있다. 3*n(n+1)/2+n+1 이 되고 (n+1)로 묶어서 정리하면 (n+1)(3n+2)/2 가 된다. 이를 45678로 나눈 나머지로 출력하면 된다.  코드: 사용언어 : Python 3
n=int(input())print((n+1)*(3*n+2)//2%45678)</description>
    </item>
    
    <item>
      <title>1977 완전제곱수</title>
      <link>https://jyukki97.github.io/blog/2018-01-18-1977/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2018-01-18-1977/</guid>
      <description>https://www.acmicpc.net/problem/1977
풀이:  m 이상 n이하의 완전제곱수를 다 더한 후 최솟값을 출력 만약 sum이 0이라면 -1을 출력  코드: #include &amp;lt;iostream&amp;gt;using namespace std;int main(void) {int m, n, mini = 0, sum = 0, i = 1;cin &amp;gt;&amp;gt; m &amp;gt;&amp;gt; n;while (true) {if (i*i &amp;gt;= m) {if (i * i &amp;gt; n)break;if (mini == 0)mini = i * i;sum += i * i;}i++;}if (sum == 0)cout &amp;lt;&amp;lt; &amp;quot;-1&amp;quot; &amp;lt;&amp;lt; endl;elsecout &amp;lt;&amp;lt; sum &amp;lt;&amp;lt; endl &amp;lt;&amp;lt; mini &amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
    <item>
      <title>2011 암호코드</title>
      <link>https://jyukki97.github.io/blog/2019-06-03-2011/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-06-03-2011/</guid>
      <description>https://www.acmicpc.net/problem/2011
풀이:  dp[a]를 a자리 까지 숫자를 암호화 할 수 있는 가짓수 라고 하자. (a - 1) * 10 + a 가 10~26 사이라면 dp[a] = dp[a - 1] + dp[a - 2] 가 된다. 10~26 사이가 아니라면, dp[a] = dp[a - 1] 이 된다. 이 때, a 가 0 이라면, 암호를 해석 할 수 없으므로 0을 출력한다. (이 때, (a - 1 * 10 + a) 가 10 ~ 26 사이라면 가능하므로 주의하자) 정답이 매우 클 수 있으므로, 1000000으로 나눈 나머지를 출력한다.</description>
    </item>
    
    <item>
      <title>2018 수들의 합5</title>
      <link>https://jyukki97.github.io/blog/2018-02-02-2018/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2018-02-02-2018/</guid>
      <description>https://www.acmicpc.net/problem/2018
풀이:  (i + 1) + (i + 2) + (i + 3) + &amp;hellip; + (i + j) = n i * j + (1 + 2 + 3 + &amp;hellip; + j) = n n - (1 + 2 + 3 + &amp;hellip; + j) = i * j n - j*(j+1)/2 = i * j (n - j*(j+1)/2) / j = i 즉 (n - j*(j+1)/2) / j 가 정수 (n - j*(j+1)/2) % j == 0  코드: 사용언어 : Python 3</description>
    </item>
    
    <item>
      <title>2240 자두나무</title>
      <link>https://jyukki97.github.io/blog/2019-05-26-2240/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-05-26-2240/</guid>
      <description>https://www.acmicpc.net/problem/2240
풀이:  s[t][w]를 자두의 남은 이동수가 w이고, 1 ~ t번째 자두까지 받아먹을 수 있는 최대 갯수 t의 숫자를 늘리며 이전 번째 자두수에서 +1을 해준다. 자두나무가 같다면 w를 같게 다르다면 +1해준다. 이때 w가 최대 이동횟수를 넘지않도록 주의한다.  코드: 사용언어 : c++ {% highlight c++ %} #include #include using namespace std; int T, w, a[1002]; int s[1002][32] = { 0 }; int main(void) { cin &amp;raquo; T &amp;raquo; w; int m = 0; a[0] = 1; s[0][w] = 1; for (int i = 1; i &amp;lt;= T; i++) cin &amp;raquo; a[i]; for (int i = 1; i &amp;lt;= T; i++) for (int t = 0; t &amp;lt; i; t++) for (int y = 0; y &amp;lt;= w; y++) { if (a[i] !</description>
    </item>
    
    <item>
      <title>2579 계단 오르기</title>
      <link>https://jyukki97.github.io/blog/2017-11-29-2579/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-11-29-2579/</guid>
      <description>+++ author = &amp;ldquo;jyukki&amp;rdquo; categories = [&amp;ldquo;백준&amp;rdquo;] tags = [&amp;ldquo;algorithm&amp;rdquo;, &amp;ldquo;C++&amp;rdquo;, &amp;ldquo;DP&amp;rdquo;] date = &amp;ldquo;2017-11-29&amp;rdquo; description = &amp;ldquo;algorithm&amp;rdquo; featured = &amp;quot;&amp;rdquo; featuredalt = &amp;quot;&amp;rdquo; featuredpath = &amp;ldquo;date&amp;rdquo; linktitle = &amp;quot;&amp;rdquo; title = &amp;ldquo;[백준]2579 계단 오르기&amp;rdquo; type = &amp;ldquo;post&amp;rdquo;
+++
https://www.acmicpc.net/problem/2579
풀이:  b[i][0] 은 i번째를 골랐을 때, i-1번째를 안고른 경우의 수 b[i][1] 은 i번째를 골랐을 때, i-1번째를 고른 경우의 수  코드: #include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;int main(void) {int n;cin &amp;gt;&amp;gt; n;int a[301];for (int i = 0; i &amp;lt; n; i++) {cin &amp;gt;&amp;gt; a[i];}int b[301][2] = { a[0],0,a[1],a[0] + a[1],0 };for (int i = 2; i &amp;lt; n; i++) {for (int t = 0; t &amp;lt; 2; t++) {if (t == 0)b[i][t] = max(b[i - 2][0], b[i - 2][1]) + a[i];if (t == 1)b[i][t] = b[i - 1][0] + a[i];}}cout &amp;lt;&amp;lt; max(b[n - 1][0], b[n - 1][1]) &amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
    <item>
      <title>2616 소형기관차</title>
      <link>https://jyukki97.github.io/blog/2017-12-30-2616/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-12-30-2616/</guid>
      <description>https://www.acmicpc.net/problem/2616
풀이:  a[i][t] : i 번째 까지의 소형 기관차 들이 t번째 객차까지 끌 수 있는 최대 승객의 수 첫 번째 소형기관차부터 앞으로 m칸만큼 객차칸수를 증가시켜가며 최댓값을 구한다. 만약 앞에 값이 더 크다면 앞에값을 선택한다. 객차의 칸이 겹칠 수 없으므로 이번 소형기관차(a[i][t])보다 m보다 작은 객차수를 가지고 있는 이전의 소형기관차(a[i - 1][t - m])를 이번 소형기관창의 t번째 최대 승객 수에 더해준다. a[i][t] = max(a[i][t - 1], sum[t] - sum[t - m] + a[i - 1][t - m];  코드: #include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;int n, m, sum[50002] = { 0 }, a[4][50002] = { 0 };int main(void) {cin &amp;gt;&amp;gt; n;for (int i = 1; i &amp;lt;= n; i++) {cin &amp;gt;&amp;gt; sum[i];sum[i] += sum[i - 1];}cin &amp;gt;&amp;gt; m;for (int i = 1; i &amp;lt;= 3; i++) {for (int t = i * m; t &amp;lt;= n; t++) {a[i][t] = max(a[i][t - 1], sum[t] - sum[t - m] + a[i - 1][t - m]);}}cout &amp;lt;&amp;lt; a[3][n] &amp;lt;&amp;lt; endl;return 0;}시간 초과 코드: #include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;int a[50001];int main(void) {int n, m;cin &amp;gt;&amp;gt; n;for (int i = 0; i &amp;lt; n; i++) {cin &amp;gt;&amp;gt; a[i];}cin &amp;gt;&amp;gt; m;int num = 0;for (int i = 0; i &amp;lt;= n - 3 * m; i++) {for (int t = i + m; t &amp;lt;= n - 2 * m; t++) {for (int y = t + m; y &amp;lt;= n - m; y++) {int cnt = 0;for (int q = 0; q &amp;lt; m; q++) {cnt += a[i + q] + a[t + q] + a[y + q];}num = max(num, cnt);}}}cout &amp;lt;&amp;lt; num &amp;lt;&amp;lt; endl;return 0;}메모리 초과 코드: #include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;int n, m;int sum[50002] = { 0 };int small(int a,int b,int c) {if (a + 3 * m &amp;gt; n) return 0;if (b + 2 * m &amp;gt; n) return small(a + 1, a + m + 1, a + 2 * m + 1);if (c + m &amp;gt; n)	return small(a, b + 1, b + m + 1);int num = 0;num += sum[a + m] - sum[a] + sum[b + m] - sum[b] + sum[c + m] - sum[c];return num = max(num, small(a, b, c + 1));}int main(void) {cin &amp;gt;&amp;gt; n;for (int i = 1; i &amp;lt;= n; i++) {cin &amp;gt;&amp;gt; sum[i];sum[i] += sum[i - 1];}cin &amp;gt;&amp;gt; m;cout &amp;lt;&amp;lt; small(0, m, 2 * m) &amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
    <item>
      <title>2688 줄어들지 않아</title>
      <link>https://jyukki97.github.io/blog/2017-12-24-2688/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-12-24-2688/</guid>
      <description>https://www.acmicpc.net/problem/2688
풀이:  a[t][y] : t + 1 개의 자릿수에서의 줄어들지 않는 수의 갯수 a[t][y] = a[t][y - 1] + a[t - 1][y] 앞자리의 갯수가 1 증가할 때 마다 이전 자릿수의 개수를 더해가는 방식으로 구한다. 최종 자릿수 9가되면 모든 수가 누적되어 있으므로 출력한다.  코드: #include &amp;lt;iostream&amp;gt;using namespace std;long long a[65][10] = { 1,2,3,4,5,6,7,8,9,10,0 };int main(void) {int T, n;cin &amp;gt;&amp;gt; T;for (int i = 0; i &amp;lt; T; i++) {cin &amp;gt;&amp;gt; n;for (int t = 1; t &amp;lt; n; t++) {a[t][0] = 1;for (int y = 1; y &amp;lt; 10; y++) {a[t][y] = a[t][y - 1] + a[t - 1][y];}}cout &amp;lt;&amp;lt; a[n - 1][9] &amp;lt;&amp;lt; endl;}return 0;}사간 초과 풀이:  처음 풀이를 할 때 저번 1038 감소하는 수를 푸는 것처럼 하나하나 만들어 가면서 카운트를 하려 했으나 시간초과가 난다.</description>
    </item>
    
    <item>
      <title>2743 단어 길이 재기</title>
      <link>https://jyukki97.github.io/blog/2017-12-25-2743/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-12-25-2743/</guid>
      <description>https://www.acmicpc.net/problem/2743
풀이:  단어의 길이를 출력  코드: #include &amp;lt;iostream&amp;gt;#include &amp;lt;string&amp;gt;using namespace std;int main(void) {string a;cin &amp;gt;&amp;gt; a;cout &amp;lt;&amp;lt; a.length() &amp;lt;&amp;lt; endl;}</description>
    </item>
    
    <item>
      <title>2749 피보나치 수3</title>
      <link>https://jyukki97.github.io/blog/2018-01-06-2749/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2018-01-06-2749/</guid>
      <description>https://www.acmicpc.net/problem/2749
풀이:  코드 설명은 피보나치 코드 참고 참고의 문제와는 다르게 매우 큰 수가 들어온다. 피보나치를 n으로 나누면 주기가 생성되는데 주기로 끊어서 풀도록 한다.  코드: #include &amp;lt;iostream&amp;gt;using namespace std;long long a[3] = { 0,1 }, n;int main() {cin &amp;gt;&amp;gt; n;for (int i = 2; i &amp;lt;= n % 1500000; i++)a[i % 3] = (a[(i - 1) % 3] + a[(i - 2) % 3]) % 1000000;cout &amp;lt;&amp;lt; a[(n % 1500000) % 3] &amp;lt;&amp;lt; endl;}참고: https://www.</description>
    </item>
    
    <item>
      <title>2858 기숙사 바닥</title>
      <link>https://jyukki97.github.io/blog/2018-02-02-2858/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2018-02-02-2858/</guid>
      <description>https://www.acmicpc.net/problem/2858
풀이:  전체 사각형의 면적으로 가로 세로를 찾은 후 그 가로 세로에서 2를 뺀것의 넓이가 안쪽 갈색의 면적과 같다면 그 가로 세로가 각각 L, W 라고 할 수 있다.  코드: 사용언어 : Python 3
r,b=map(int,input().split())for i in range(3,(r+b)//2):if((r+b)%i==0 and (i-2)*(((r+b)/i)-2)==b):print(((r+b)//i),i)break</description>
    </item>
    
    <item>
      <title>2896 무알콜 칵테일</title>
      <link>https://jyukki97.github.io/blog/2018-03-16-2896/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2018-03-16-2896/</guid>
      <description>https://www.acmicpc.net/problem/2896
풀이:  주스의 비율을 주스의 양으로 나눈 값이 가장 작은 주스를 찾는다. 주스의 비율에서 주스의 양 * 1번에서 구한 값 을 출력한다.  코드: 사용언어 : Python 3
a,b,c=map(int,input().split())d,e,f=map(int,input().split())g=min(a/d,b/e,c/f)print(&amp;quot;%.4f %.4f %.4f&amp;quot;%(a-d*g,b-e*g,c-f*g))</description>
    </item>
    
    <item>
      <title>2902 KMP는 왜 KMP일까?</title>
      <link>https://jyukki97.github.io/blog/2018-01-09-2902/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2018-01-09-2902/</guid>
      <description>https://www.acmicpc.net/problem/2902
풀이:  대문자를 출력  코드: #include &amp;lt;iostream&amp;gt;#include &amp;lt;string&amp;gt;using namespace std;string a;int main(void) {cin &amp;gt;&amp;gt; a;for (int i = 0; i &amp;lt; a.length(); i++) {if (a[i] &amp;gt; 64 &amp;amp;&amp;amp; a[i] &amp;lt; 91)cout &amp;lt;&amp;lt; a[i];}cout &amp;lt;&amp;lt; endl;}</description>
    </item>
    
    <item>
      <title>2903 중앙 이동 알고리즘</title>
      <link>https://jyukki97.github.io/blog/2018-02-04-2903/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2018-02-04-2903/</guid>
      <description>https://www.acmicpc.net/problem/2903
풀이:  N 단계를 진행할 경우 ((2^N) +1)^2 만큼 점의 개수가 생긴다.  코드: 사용언어 : Python 3
print(((2**int(input()))+1)**2)</description>
    </item>
    
    <item>
      <title>2914 저작권</title>
      <link>https://jyukki97.github.io/blog/2018-01-25-2914/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2018-01-25-2914/</guid>
      <description>https://www.acmicpc.net/problem/2914
풀이:  올림을 했으므로 평균값에서 1을 뺀 후 수록된 곡의 갯수와 곱한 뒤 1을 더해준다.  코드: 사용언어 : Python 3
a, b = map(int, input().split(&#39; &#39;))print(a * (b-1) + 1)</description>
    </item>
    
    <item>
      <title>2921 도미노</title>
      <link>https://jyukki97.github.io/blog/2018-02-01-2921/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2018-02-01-2921/</guid>
      <description>https://www.acmicpc.net/problem/2921
풀이:  세트의 크기가 N인 도미노 세트의 점의 개수 : N*(N+1)*(N+2)/2  코드: 사용언어 : Python 3
n=int(input())print(n*(n+1)*(n+2)//2)</description>
    </item>
    
    <item>
      <title>2965 캥거루 세마리</title>
      <link>https://jyukki97.github.io/blog/2018-01-25-2965/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2018-01-25-2965/</guid>
      <description>https://www.acmicpc.net/problem/2965
풀이:  A 캥거루와 B 캥거루,C 캥거루와 B 캥거루 사이 거리 중 최댓값에서 1을 뺀 값을 출력  코드: 사용언어 : Python 3
a, b, c= map(int, input().split(&#39; &#39;))print(max(b - a, c - b) - 1)</description>
    </item>
    
    <item>
      <title>3046 R2</title>
      <link>https://jyukki97.github.io/blog/2018-01-03-3046/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2018-01-03-3046/</guid>
      <description>https://www.acmicpc.net/problem/3046
풀이:  R2 = 2 * S - R1  코드: #include &amp;lt;iostream&amp;gt;using namespace std;int main(){int r, s;cin &amp;gt;&amp;gt; r &amp;gt;&amp;gt; s;cout &amp;lt;&amp;lt; 2 * s - r &amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
    <item>
      <title>3049 다각형의 대각선</title>
      <link>https://jyukki97.github.io/blog/2018-02-06-3049/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2018-02-06-3049/</guid>
      <description>https://www.acmicpc.net/problem/3049
풀이:  교차점은 N각형 블록에서 꼭짓점 4개를 선택하여 그 사각형의 내부에 생기는 점의 합이라고 할 수 있다. 그러므로 N개의 꼭짓점 중 4개를 선택하는 경우의 수가 교차점의 개수라고 할 수 있다. 그러므로 답은 nC4  코드: 사용언어 : Python 3
n=int(input())print(n*(n-1)*(n-2)*(n-3)//24)</description>
    </item>
    
    <item>
      <title>3067 Coins</title>
      <link>https://jyukki97.github.io/blog/2017-12-29-3067/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-12-29-3067/</guid>
      <description>https://www.acmicpc.net/problem/3067
풀이:  출처의 문제와 같으므로 출처를 참고.  코드: #include &amp;lt;iostream&amp;gt;using namespace std;int main(void){int T, a, num;cin &amp;gt;&amp;gt; T;for (int y = 0; y &amp;lt; T; y++) {int coin[10001] = { 0 };cin &amp;gt;&amp;gt; a;int *q = new int[a];for (int i = 0; i &amp;lt; a; i++)cin &amp;gt;&amp;gt; q[i];cin &amp;gt;&amp;gt; num;for (int i = 0; i &amp;lt;= num; i++) {if (i%q[0] == 0)coin[i]++;}for (int i = 1; i &amp;lt; a; i++) {for (int t = q[i]; t &amp;lt;= num; t++)coin[t] += coin[t - q[i]];}cout &amp;lt;&amp;lt; coin[num] &amp;lt;&amp;lt; endl;}return 0;}**출처 : 2293 동전1 ** https://jyukki97.</description>
    </item>
    
    <item>
      <title>3474 교수가 된 현우</title>
      <link>https://jyukki97.github.io/blog/2018-03-16-3474/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2018-03-16-3474/</guid>
      <description>https://www.acmicpc.net/problem/3474
풀이:  오른쪽 끝에있는 0에 갯수를 알기 위해서는 팩토리얼 안에서 10의 갯수가 얼마나 있는지를 알면된다. 이 때 2의 갯수는 매우 많으므로 팩토리얼 내에서 5가 몇번 곱해지는지를 세면 간단하게 알 수 있다. 주어진 수를 5로 나눈 몫이 5의 갯수이다 그러나 25, 125 등 5가 여러번 들어가는 경우도 있으므로 각각으로 나누어준 값을 더해주어야한다.  코드: 사용언어 : Python 3 {% highlight Python %} for i in range(int(input())): a,b,c=int(input()),5,0 while b&amp;lt;=a: c+=a//b b*=5 print(c) {% endhighlight %}</description>
    </item>
    
    <item>
      <title>4504 배수 찾기</title>
      <link>https://jyukki97.github.io/blog/2018-02-04-4504/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2018-02-04-4504/</guid>
      <description>https://www.acmicpc.net/problem/4504
풀이:  배수인지 아닌지 확인 후 주어진 조건에 맞게 출력 만약 받아드리는 수가 0이라면 반복을 끝낸다.  코드: 사용언어 : Python 3
n=int(input())while True:k=int(input())if k==0:breakif(k%n==0):print(k,&amp;quot;is a multiple of %d.&amp;quot;%(n))else:print(k,&amp;quot;is NOT a multiple of %d.&amp;quot;%(n))</description>
    </item>
    
    <item>
      <title>5218 알파벳 거리</title>
      <link>https://jyukki97.github.io/blog/2018-02-04-5218/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2018-02-04-5218/</guid>
      <description>https://www.acmicpc.net/problem/5218
풀이:  알파벳 거리를 출력 만약 음수라면 26을 더한다.  코드: 사용언어 : Python 3
n=int(input())for i in range(n):a,b=map(str,input().split())print(&amp;quot;Distances:&amp;quot;,end=&#39; &#39;)for t in range(len(a)):if(ord(a[t])&amp;gt;ord(b[t])):print(ord(b[t])-ord(a[t])+26,end=&#39; &#39;)else:print(ord(b[t])-ord(a[t]),end=&#39; &#39;)print()</description>
    </item>
    
    <item>
      <title>9184 신나는 함수 실행</title>
      <link>https://jyukki97.github.io/blog/2018-01-12-9184/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2018-01-12-9184/</guid>
      <description>https://www.acmicpc.net/problem/9184
풀이:  DP함수가 주어져 있으므로 메모이제이션을 하면된다. 단, a, b, c 의 최대 크기가 주어져있지않으므로 20이 넘어간 값은 생략하도록한다. -1, -1, -1 이 입력으로 들어올 경우 루프를 끝날 수 있게 만든다.  코드: #include &amp;lt;iostream&amp;gt;#include &amp;lt;string.h&amp;gt;using namespace std;int fuc[21][21][21];int w(int a,int b,int c) {if (a &amp;lt;= 0 || b &amp;lt;= 0 || c &amp;lt;= 0)return 1;if (a &amp;gt; 20 || b &amp;gt; 20 || c &amp;gt; 20)return fuc[20][20][20] = w(20, 20, 20);if (fuc[a][b][c] &amp;gt; -1)	return fuc[a][b][c];if (a &amp;lt; b &amp;amp;&amp;amp; b &amp;lt; c)return fuc[a][b][c] = w(a, b, c - 1) + w(a, b - 1, c - 1) - w(a, b - 1, c);return	fuc[a][b][c] = w(a - 1, b, c) + w(a - 1, b - 1, c) + w(a - 1, b, c - 1) - w(a - 1, b - 1, c - 1);}int main(void) {int a, b, c;memset(fuc, -1, sizeof(fuc));while(true){cin &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b &amp;gt;&amp;gt; c;if (a == -1 &amp;amp;&amp;amp; b == -1 &amp;amp;&amp;amp; c == -1)break;cout &amp;lt;&amp;lt; &amp;quot;w(&amp;quot; &amp;lt;&amp;lt; a &amp;lt;&amp;lt; &amp;quot;, &amp;quot; &amp;lt;&amp;lt; b &amp;lt;&amp;lt; &amp;quot;, &amp;quot; &amp;lt;&amp;lt; c &amp;lt;&amp;lt; &amp;quot;) = &amp;quot; &amp;lt;&amp;lt; w(a, b, c) &amp;lt;&amp;lt; endl;}return 0;}</description>
    </item>
    
    <item>
      <title>9251 LCS</title>
      <link>https://jyukki97.github.io/blog/2019-05-31-9251/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-05-31-9251/</guid>
      <description>https://www.acmicpc.net/problem/9251
풀이:  dp[a][b]를 1 ~ a번째 까지의 문자열과 1 ~ b 까지의 문자열로 이루어진 최장 공통 부분수열이라고 하자. a번째 문자와 b번째 문자가 같다면, dp[a - 1][b - 1] 에 1을 더해준다. 즉, dp[a][b] = dp[a - 1][b - 1] + 1 이 된다. a번째 문자와 b번째 문자가 다르다면, a번째 문자를 제거한 문자열과 b번째 문자를 제거한 문자열을 비교하여 최댓값을 받는다. 즉, dp[a][b] = max(dp[a - 1][b], dp[a][b - 1]) 이 된다.</description>
    </item>
    
    <item>
      <title>9322 철벽 보안 알고리즘</title>
      <link>https://jyukki97.github.io/blog/2018-02-04-9322/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2018-02-04-9322/</guid>
      <description>https://www.acmicpc.net/problem/9322
풀이:  제 1 공개키에 각각에 단어들이 제 2 공개키에 어디에 있는지 확인한다. 제 1 공개키에 첫번째 단어부터 제 2 공개키에서의 위치에 있는 암호키를 출력한다.  코드: 사용언어 : Python 3
a,b,c=[],[],[]for i in range(int(input())):n=int(input())a,b,c=input().split(),input().split(),input().split()for t in range(n):print(c[b.index(a[t])],end=&amp;quot; &amp;quot;)</description>
    </item>
    
    <item>
      <title>9465 스티커</title>
      <link>https://jyukki97.github.io/blog/2017-11-30-9465/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-11-30-9465/</guid>
      <description>+++ author = &amp;ldquo;jyukki&amp;rdquo; categories = [&amp;ldquo;백준&amp;rdquo;] tags = [&amp;ldquo;algorithm&amp;rdquo;, &amp;ldquo;C++&amp;rdquo;, &amp;ldquo;DP&amp;rdquo;] date = &amp;ldquo;2017-11-30&amp;rdquo; description = &amp;ldquo;algorithm&amp;rdquo; featured = &amp;quot;&amp;rdquo; featuredalt = &amp;quot;&amp;rdquo; featuredpath = &amp;ldquo;date&amp;rdquo; linktitle = &amp;quot;&amp;rdquo; title = &amp;ldquo;[백준]9465 스티커&amp;rdquo; type = &amp;ldquo;post&amp;rdquo;
+++
https://www.acmicpc.net/problem/9465
풀이:  a[i][t] 는 i행 t열의 스티커를 골랐을 때 최대 점수 a[t][i] += max(a[(t + 1) % 2][i - 2], a[(t + 1) % 2][i - 1])  코드: #include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;int a[2][100001] = { 0 };int main(void) {int T,n;cin &amp;gt;&amp;gt; T;for (int y = 0; y &amp;lt; T; y++) {cin &amp;gt;&amp;gt; n;for (int t = 0; t &amp;lt; 2; t++) {for (int i = 0; i &amp;lt; n; i++) {cin &amp;gt;&amp;gt; a[t][i];}}for (int i = 1; i &amp;lt; n; i++) {for (int t = 0; t &amp;lt; 2; t++) {a[t][i] += max(a[(t + 1) % 2][i - 2], a[(t + 1) % 2][i - 1]);}}cout &amp;lt;&amp;lt; max(a[0][n - 1], a[1][n - 1]) &amp;lt;&amp;lt; endl;}}</description>
    </item>
    
    <item>
      <title>9546 3000번 버스</title>
      <link>https://jyukki97.github.io/blog/2018-01-29-9546/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2018-01-29-9546/</guid>
      <description>https://www.acmicpc.net/problem/9546
풀이:  처음 사람의 수 = 2^k - 1  코드: 사용언어 : Python 3
t=int(input())for i in range(t):k=int(input())print((2**k)-1)</description>
    </item>
    
    <item>
      <title>9550 아이들은 사탕을 좋아해</title>
      <link>https://jyukki97.github.io/blog/2018-01-27-9550/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2018-01-27-9550/</guid>
      <description>https://www.acmicpc.net/problem/9550
풀이:  사탕개수를 최소 K개 만큼 주어야 하므로 각각의 사탕을 K로 나눈 몫을 모두 더한 값을 출력한다.  코드: 사용언어 : Python 3
T = int(input())for i in range(T):cnt = 0 n,k = map(int,input().split(&#39; &#39;))c = input().split(&#39; &#39;)for t in range(n):cnt += int(c[t]) // kprint(cnt)</description>
    </item>
    
    <item>
      <title>9764 서로 다른 자연수의 합</title>
      <link>https://jyukki97.github.io/blog/2017-12-27-9764/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-12-27-9764/</guid>
      <description>https://www.acmicpc.net/problem/9764
풀이:  a[i][t] : 정수 i를 나타낼 때, 처음 더하는 수가 t인 경우의 수 a[i][t]는 i에서 t만큼 뺀 수에서 t보다 큰 수를 더한 값과 동일하다. 예를들어 5 : 1 + 4 = 2 + 3 = 5 로 나타낼 수 있는데 맨 앞자리를 1을 고를 경우 4의 앞자리가 1보다 큰 경우의 수를 모두 더한값과 같다. 이와 동일하게 2,3,4,5를 모두 할 경우 5의 경우의 수는 3개가 나오게 된다.  주의 사항:  n의 경우의 수를 구할 때 값이 매우 커지므로 100999로 나눈 나머지로 출력한다.</description>
    </item>
    
  </channel>
</rss>