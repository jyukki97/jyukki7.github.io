<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>백준 on 1 Day 1 Problem</title>
    <link>https://jyukki97.github.io/categories/%EB%B0%B1%EC%A4%80/</link>
    <description>Recent content in 백준 on 1 Day 1 Problem</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>kr-ko</language>
    <lastBuildDate>Fri, 06 Mar 2020 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://jyukki97.github.io/categories/%EB%B0%B1%EC%A4%80/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>[백준]1015 수열 정렬</title>
      <link>https://jyukki97.github.io/blog/2020-03-06-1015/</link>
      <pubDate>Fri, 06 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-03-06-1015/</guid>
      <description>https://www.acmicpc.net/problem/1015
풀이: 배열 A를 정렬한 배열을 배열 B라고 하자.
현재 위치가 i 일 때, A[i] 값이 배열 B의 어디에 위치해 있는지 찾아서 출력한다.
ex)
A
2 3 1
B
1 2 3
답:
1 2 0
수의 중복이 있을 수 있으므로 주의하자. 코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;int N, a[52], b[52], d[52], c;int main(void) {cin &amp;gt;&amp;gt; N;for (int i = 0; i &amp;lt; N; i++) {cin &amp;gt;&amp;gt; a[i];b[i] = a[i];}sort(a, a + N);for (int i = 0; i &amp;lt; N; i++) {c = lower_bound(a, a + N, b[i]) - a;while (d[c])	c++;cout &amp;lt;&amp;lt; c &amp;lt;&amp;lt; &amp;#34;&amp;#34;;d[c] = 1;}cout &amp;lt;&amp;lt; endl;}</description>
    </item>
    
    <item>
      <title>[백준]1024 수열의 합</title>
      <link>https://jyukki97.github.io/blog/2020-03-06-1024/</link>
      <pubDate>Fri, 06 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-03-06-1024/</guid>
      <description>https://www.acmicpc.net/problem/1024
풀이: 길이가 적어도 L인 수열은 다음과 같이 나타낼 수 있다.
n	n + 1	n + 2	...	n + L - 2	n + L - 1즉, 길이가 L인 수열들의 합은
L * n + Σ k (k = 1 ~ L - 1) = N
( N - Σ k (k = 1 ~ L - 1) ) % L == 0
인 L을 찾는다면, 답을 구할 수 있다.</description>
    </item>
    
    <item>
      <title>[백준]1051 숫자 정사각형</title>
      <link>https://jyukki97.github.io/blog/2020-03-06-1051/</link>
      <pubDate>Fri, 06 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-03-06-1051/</guid>
      <description>https://www.acmicpc.net/problem/1051
풀이: N, M 중 더 작은 값이 정사각형의 한 변의 길이의 최댓값이 된다.
최댓값을 1씩 줄여 가면서, 만들 수 있는 정사각형이 있는지 확인한다.
만들 수 있다면, 반복을 중지하고, 변을 제곱한 넓이를 출력한다.
코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std;int N, M, b, c = 1;int main(void) {cin &amp;gt;&amp;gt; N &amp;gt;&amp;gt; M;vector&amp;lt;string&amp;gt; a(N);for (int i = 0; i &amp;lt; N; i++)cin &amp;gt;&amp;gt; a[i];b = N &amp;gt; M ?</description>
    </item>
    
    <item>
      <title>[백준]1062 가르침</title>
      <link>https://jyukki97.github.io/blog/2020-03-06-1062/</link>
      <pubDate>Fri, 06 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-03-06-1062/</guid>
      <description>https://www.acmicpc.net/problem/1062
풀이: a ~ z 중에 K개의 글자를 배웠을 떄,
N개의 단어 중 몇개의 단어를 읽을 수 있는지 구한 후 그것들 중 최댓값을 출력한다.
a, c, i, n, t 다섯개의 글자는 무조건 들어가므로 넣고 시작하자. 코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;int N, K, b, c = 0, d, f;vector&amp;lt;string&amp;gt; a;void T(int x, int y) {if (y == K) {d = 0;for (int i = 0; i &amp;lt; N; i++) {f = 1;for (char s : a[i])	if (!</description>
    </item>
    
    <item>
      <title>[백준]1080 행렬</title>
      <link>https://jyukki97.github.io/blog/2020-03-06-1080/</link>
      <pubDate>Fri, 06 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-03-06-1080/</guid>
      <description>https://www.acmicpc.net/problem/1080
풀이: (0, 0) 부터 하나씩 비교해 나간다.
만약 A 와 B 의 숫자가 다르다면, 현재 위치부터 3 * 3 전체를 반전시킨다.
반전 시켰다면, 뒤집은 횟수를 +1 해준다.
순환이 끝난 후 행렬 A 와 B 가 다르다면 -1을 같다면 뒤집은 횟수를 출력해준다.
코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std;int N, M, c = 0, i, t, u, y;int main() {cin &amp;gt;&amp;gt; N &amp;gt;&amp;gt; M;vector&amp;lt;string&amp;gt; a(N), b(N);for (i = 0; i &amp;lt; N; i++)cin &amp;gt;&amp;gt; a[i];for (i = 0; i &amp;lt; N; i++)cin &amp;gt;&amp;gt; b[i];for (i = 0; i &amp;lt; N - 2; i++)for (t = 0; t &amp;lt; M - 2; t++)if (a[i][t] !</description>
    </item>
    
    <item>
      <title>[백준]1005 ACM Craft</title>
      <link>https://jyukki97.github.io/blog/2020-03-05-1005/</link>
      <pubDate>Thu, 05 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-03-05-1005/</guid>
      <description>https://www.acmicpc.net/problem/1005
풀이: b[i] : i 건물을 짓는데 드는 최소시간
b[i] = max(b[i 건물을 짓는데 필요한 건물들])
-&amp;gt; 바로 전 단계의 건물 중 건설시간이 오래 걸리는 것을 짓는다면, 그 시간동안 다른 건물은 다 지을 수 있기 떄문에, max값만 생각한다.
코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;int T, N, K, q, e, w, a[1002], m, n, b[1002];vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; v;int A(int x) {if (b[x] !</description>
    </item>
    
    <item>
      <title>[백준]1049 기타줄</title>
      <link>https://jyukki97.github.io/blog/2020-03-05-1049/</link>
      <pubDate>Thu, 05 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-03-05-1049/</guid>
      <description>https://www.acmicpc.net/problem/1049
풀이: 여러 브랜드 중 6줄 패키지 가격의 최솟값과 낱개 가격의 최솟값을 저장해 놓는다.
낱개 * 6 보다 패키지 가격이 더 높다면, 패키지로 살 이유가 없으므로 낱개 가격을 출력한다.
필요한 줄의 갯수가 6개 이하라면, 낱개 가격과 패키지 가격 중 낮은 가격을 출력한다.
둘 다 아니라면, (전체를 패키지로 사는 것) 과 (6개로 나눠지는 만큼 패키지로 사고 나머지는 낱개로 사는 것) 둘 중 낮은 가격을 출력한다.
코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;int N, M, q, w, a = 1001, b = 1001, dp[102] = { 0 };int main(void) {cin &amp;gt;&amp;gt; N &amp;gt;&amp;gt; M;for (int i = 0; i &amp;lt; M; i++) {cin &amp;gt;&amp;gt; q &amp;gt;&amp;gt; w;a = min(a, q);b = min(b, w);}for (int i = 1; i &amp;lt;= N; i++) {dp[i] = (((i - 1) / 6) + 1) * a;dp[i] = min(dp[i], dp[i - 1] + b);}cout &amp;lt;&amp;lt; dp[N] &amp;lt;&amp;lt; endl;}코드: 사용언어 : c++</description>
    </item>
    
    <item>
      <title>[백준]1068 트리</title>
      <link>https://jyukki97.github.io/blog/2020-03-05-1068/</link>
      <pubDate>Thu, 05 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-03-05-1068/</guid>
      <description>https://www.acmicpc.net/problem/1068
풀이: v[i] : i의 자식 노드들이 들어있다.
삭제 해야하는 노드가 w 라면,
w를 큐에 푸쉬한다.
w의 자식노드를 큐에 푸쉬한 후 w를 삭제한다.
자식노드가 없어질 때까지 반복한다.
v[ 0 ~ N - 1 ] 까지 모두 순환한다.
노드가 현제 존재하며, 자식노드가 없다면, 리프 노드이므로 +1 해준다.
코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;queue&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std;int N, a;bool b[52], c;int main(void) {cin &amp;gt;&amp;gt; N;vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; v(N);queue&amp;lt;int&amp;gt; q;for (int i = 0; i &amp;lt; N; i++) {cin &amp;gt;&amp;gt; a;if(a !</description>
    </item>
    
    <item>
      <title>[백준]1057 토너먼트</title>
      <link>https://jyukki97.github.io/blog/2020-03-04-1057/</link>
      <pubDate>Wed, 04 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-03-04-1057/</guid>
      <description>https://www.acmicpc.net/problem/1057
풀이: ​	1	2
​	1	2	3	4
1	2	3	4	5	6	7	8
현재 번호가 i 라고 할 때,
위로 갈 수록 배정받는 번호는 (i + 1) / 2 가 된다.
즉, 김지민과 임한수의 번호가 x, y 라고 할 때,
( x + 1 ) / 2 == ( y + 1 ) / 2
가 되는 순간이 둘이 대결하는 순간이다.
토너먼트가 끝날 때까지 둘이 대결하지 않는 경우는 없으므로 -1 출력은 하지않는다.</description>
    </item>
    
    <item>
      <title>[백준]1074 집합</title>
      <link>https://jyukki97.github.io/blog/2020-03-04-1074/</link>
      <pubDate>Wed, 04 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-03-04-1074/</guid>
      <description>https://www.acmicpc.net/problem/1074
풀이: 배열의 크기를 점차 줄여가면서,
위에 방문할 수 있는 배열의 크기를 계산하여, 더해가면서 구한다.
ex)
3 7 7
8 * 8 배열에서
왼쪽위, 오른쪽 위, 왼쪽 아래 4 * 4 배열은 필요없으니까 48 만큼 뺀 후,
오른쪽 아래 배열로만 4 * 4 배열로 줄여서 다시 만든다.
그렇다면, ( 7, 7 ) 은 ( 3, 3 )이 되어야 하므로 (7 % 4, 7 % 4) 가 된다.
배열의 크기가 0이 될때까지 반복한다.</description>
    </item>
    
    <item>
      <title>[백준]11723 집합</title>
      <link>https://jyukki97.github.io/blog/2020-03-04-11723/</link>
      <pubDate>Wed, 04 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-03-04-11723/</guid>
      <description>https://www.acmicpc.net/problem/11723
풀이: [C++]비트연산자 참고
add : or 연산을 통해 값을 추가한다.
remove : 값이 있는지 확인 후 있다면, xor 연산으로 삭제한다.
check : 값이 있는지 and 연산으로 확인 후 있다면 1, 없다면 0을 출력한다.
toggle : 값이 있다면 삭제하고, 없다면 추가한다.
all : 비트값을 (2^20) - 1 로 바꿔주어, 1 ~ 20 까지 채워놓는다.
empty : 비트값을 0으로 바꿔주어, 공집합으로 만들어놓는다.
시간제한이있으므로 비트마스크를 통해 연산하도록한다. cin, cout 을 사용할 경우 시간초과가 나므로 주의하자.</description>
    </item>
    
    <item>
      <title>[백준]11404 웜홀</title>
      <link>https://jyukki97.github.io/blog/2020-03-03-11404/</link>
      <pubDate>Tue, 03 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-03-03-11404/</guid>
      <description>https://www.acmicpc.net/problem/11404
풀이: [C++]플로이드-와샬 알고리즘(Bellman-Ford Algorithm) 참고
코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;int	n, m, i, a1, a2, a3, a[102][102];int main() {cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;fill(a[0], a[0] + 10404, 987654321);for (i = 0; i &amp;lt; m; i++) {cin &amp;gt;&amp;gt; a1 &amp;gt;&amp;gt; a2 &amp;gt;&amp;gt; a3;a[a1][a2] = min(a[a1][a2], a3);}for (i = 1; i &amp;lt;= n; i++) for (int t = 1; t &amp;lt;= n; t++)for (int y = 1; y &amp;lt;= n; y++)if (t == y) a[t][y] = 0;else	a[t][y] = min(a[t][y], a[t][i] + a[i][y]);for (i = 1; i &amp;lt;= n; i++) {for (int t = 1; t &amp;lt;= n; t++)if (a[i][t] == 987654321)	cout &amp;lt;&amp;lt; &amp;#34;0 &amp;#34;;else	cout &amp;lt;&amp;lt; a[i][t] &amp;lt;&amp;lt; &amp;#34;&amp;#34;;cout &amp;lt;&amp;lt; endl;}}</description>
    </item>
    
    <item>
      <title>[백준]1865 웜홀</title>
      <link>https://jyukki97.github.io/blog/2020-03-03-1865/</link>
      <pubDate>Tue, 03 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-03-03-1865/</guid>
      <description>https://www.acmicpc.net/problem/1865
풀이: [C++]벨만-포드 알고리즘(Bellman-Ford Algorithm) 참고
벨만-포드 알고리즘으로 모든 정점을 순환 한 뒤, 음수 사이클이 있는지 판단 후 있다면, &amp;ldquo;YES&amp;rdquo; 를 없다면 &amp;ldquo;NO&amp;quot;를 출력한다. 코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std;int	T, n, m, k, i, d[502], a1, a2, a3;int main() {cin &amp;gt;&amp;gt; T;while (T--) {bool b = true;cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m &amp;gt;&amp;gt; k;vector&amp;lt;pair&amp;lt;pair&amp;lt;int, int&amp;gt;, int&amp;gt;&amp;gt; a;for (i = 0; i &amp;lt; m; i++) {cin &amp;gt;&amp;gt; a1 &amp;gt;&amp;gt; a2 &amp;gt;&amp;gt; a3;a.</description>
    </item>
    
    <item>
      <title>[백준]11657 타임머신</title>
      <link>https://jyukki97.github.io/blog/2020-03-02-11657/</link>
      <pubDate>Mon, 02 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-03-02-11657/</guid>
      <description>https://www.acmicpc.net/problem/11657
풀이: [C++]벨만-포드 알고리즘(Bellman-Ford Algorithm) 참고
코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;using namespace std;#define INF 987654321int	n, m, i, d[502], a1, a2, a3;pair&amp;lt;pair&amp;lt;int, int&amp;gt;, int&amp;gt; a[6002];int main() {cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;for (i = 0; i &amp;lt; m; i++)cin &amp;gt;&amp;gt; a[i].first.first &amp;gt;&amp;gt; a[i].first.second &amp;gt;&amp;gt; a[i].second;fill(d, d + n + 1, INF);d[1] = 0;for (i = 1; i &amp;lt;= n; i++)for (auto t : a)if (d[t.</description>
    </item>
    
    <item>
      <title>[백준]9370 미확인 도착지</title>
      <link>https://jyukki97.github.io/blog/2020-03-02-9370/</link>
      <pubDate>Mon, 02 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-03-02-9370/</guid>
      <description>https://www.acmicpc.net/problem/9370
풀이: [C++]다익스트라 알고리즘(Dijkstra Algorithm) 참고
s -&amp;gt; g -&amp;gt; h -&amp;gt; x
s -&amp;gt; h -&amp;gt; g -&amp;gt; x
두 가지 경로가 있는데, 둘 중 하나라도 최단 경로일 경우 x를 배열에 저장한다.
저장된 x를 오름차순으로 출력한다.
코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;queue&amp;gt;using namespace std;int T, n, m, t, u, v, w, i, s, g, h, v1, v2, a1, c, d[2002];bool b[2002];priority_queue&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; p;priority_queue&amp;lt;int, vector&amp;lt;int&amp;gt;, greater&amp;lt;int&amp;gt;&amp;gt; q;int main() {cin &amp;gt;&amp;gt; T;while (T--) {cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m &amp;gt;&amp;gt; t;vector&amp;lt;vector&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt;&amp;gt; a(n + 1);cin &amp;gt;&amp;gt; s &amp;gt;&amp;gt; g &amp;gt;&amp;gt; h;for (i = 0; i &amp;lt; m; i++) {cin &amp;gt;&amp;gt; u &amp;gt;&amp;gt; v &amp;gt;&amp;gt; w;a[u].</description>
    </item>
    
    <item>
      <title>[백준]1504 최단 경로</title>
      <link>https://jyukki97.github.io/blog/2020-03-01-1504/</link>
      <pubDate>Sun, 01 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-03-01-1504/</guid>
      <description>https://www.acmicpc.net/problem/1504
풀이: [C++]다익스트라 알고리즘(Dijkstra Algorithm) 참고
지나야 하는 두 개의 정점을 v1, v2 라고 할때,
1 ~ v1 ~ v2 ~ N
1 ~ v2 ~ v1 ~ N
으로 나눠서 풀어본다.
1~v1, v2 과 v1 ~ v2 과 v1, v2 ~ N 을 다익스트라 알고리즘으로 각각 구하여 더한값이
최소인 값을 구한다. 만약 경로가 없다면 -1을 출력한다.
코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;queue&amp;gt;using namespace std;int V, E, u, v, w, i, d[805], v1, v2, a1, a2;priority_queue&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; p;bool b[805];int main() {cin &amp;gt;&amp;gt; V &amp;gt;&amp;gt; E;vector&amp;lt;vector&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt;&amp;gt;a(V + 1);for (i = 0; i &amp;lt; E; i++) {cin &amp;gt;&amp;gt; u &amp;gt;&amp;gt; v &amp;gt;&amp;gt; w;a[u].</description>
    </item>
    
    <item>
      <title>[백준]1753 최단 경로</title>
      <link>https://jyukki97.github.io/blog/2020-03-01-1753/</link>
      <pubDate>Sun, 01 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-03-01-1753/</guid>
      <description>https://www.acmicpc.net/problem/1753
풀이: [C++]다익스트라 알고리즘(Dijkstra Algorithm) 참고
코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;queue&amp;gt;using namespace std;int V, E, k, u, v, w, i;vector&amp;lt;int&amp;gt; d;priority_queue&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; p;bool b[20002];int main() {cin &amp;gt;&amp;gt; V &amp;gt;&amp;gt; E &amp;gt;&amp;gt; k;vector&amp;lt;vector&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt;&amp;gt;a(V + 1);for (i = 0; i &amp;lt;= V; i++)d.push_back(987654321);for (i = 0; i &amp;lt; E; i++) {cin &amp;gt;&amp;gt; u &amp;gt;&amp;gt; v &amp;gt;&amp;gt; w;a[u].</description>
    </item>
    
    <item>
      <title>[백준]1697 숨바꼭질</title>
      <link>https://jyukki97.github.io/blog/2020-02-29-1697/</link>
      <pubDate>Sat, 29 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-02-29-1697/</guid>
      <description>https://www.acmicpc.net/problem/1697
풀이: 현재 위치를 x라고 할 때, x + 1, x - 1, x * 2 위치를 BFS 를 통해 하나씩 찾아간다.
동생의 위치와 같아진다면 몇번 이동했는지 출력한다.
x + 1 은 동생의 위치보다 커질 필요가없으므로 동생의 위치보다 작을때만 이동한다. x * 2 는 동생의 위치 + 1 보다 크다면 (x - 2) * 2 를 하는 것이 이득이므로 제외한다. 현재 위치는 0보다 작아질 수 없으므로 제외한다. 이미 한번 방문한 위치는 다시 방문할 필요없으므로 제외시킨다.</description>
    </item>
    
    <item>
      <title>[백준]2206 벽 부수고 이동하기</title>
      <link>https://jyukki97.github.io/blog/2020-02-29-2206/</link>
      <pubDate>Sat, 29 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-02-29-2206/</guid>
      <description>https://www.acmicpc.net/problem/2206
풀이: [백준]2178 미로 탐색 참고
코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;queue&amp;gt;using namespace std;int n, m, k = -1, q, w, e, dps;vector&amp;lt;string&amp;gt; a;queue&amp;lt;pair&amp;lt;int, pair&amp;lt;int, int&amp;gt;&amp;gt;&amp;gt; dp;bool b[2][1002][1002];int main() {cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;a.resize(n);for (int i = 0; i &amp;lt; n; i++)cin &amp;gt;&amp;gt; a[i];dp.push({ 1, { 0,0 } });for (int i = 1; i &amp;lt; n * m + 1; i++) {dps = dp.</description>
    </item>
    
    <item>
      <title>[백준]7569 토마토</title>
      <link>https://jyukki97.github.io/blog/2020-02-29-7569/</link>
      <pubDate>Sat, 29 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-02-29-7569/</guid>
      <description>https://www.acmicpc.net/problem/7569
풀이: [백준]7576 토마토 참고
코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;queue&amp;gt;using namespace std;int n, m, h, k, q, w, e, a[102][102][102];queue&amp;lt;pair&amp;lt;int, pair&amp;lt;int, int&amp;gt;&amp;gt;&amp;gt; dp2;int main() {cin &amp;gt;&amp;gt; m &amp;gt;&amp;gt; n &amp;gt;&amp;gt; h;for (int y = 0; y &amp;lt; h; y++)for (int i = 0; i &amp;lt; n; i++)for (int t = 0; t &amp;lt; m; t++) {cin &amp;gt;&amp;gt; a[y][i][t];if (a[y][i][t] == 1)	dp2.</description>
    </item>
    
    <item>
      <title>[백준]1012 유기농 배추</title>
      <link>https://jyukki97.github.io/blog/2020-02-28-1012/</link>
      <pubDate>Fri, 28 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-02-28-1012/</guid>
      <description>https://www.acmicpc.net/problem/1012
풀이: [백준]2667 단지번호붙이기 참고
코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;string.h&amp;gt;using namespace std;int n, T, m, k, q, w, sum, a[52][52];bool b[52][52];void num(int x, int y) {b[x][y] = true;if (x + 1 &amp;lt; n &amp;amp;&amp;amp; a[x + 1][y] &amp;amp;&amp;amp; !b[x + 1][y])num(x + 1, y);if (y + 1 &amp;lt; m &amp;amp;&amp;amp; a[x][y + 1] &amp;amp;&amp;amp; !b[x][y + 1])num(x, y + 1);if (x - 1 &amp;gt;= 0 &amp;amp;&amp;amp; a[x - 1][y] &amp;amp;&amp;amp; !</description>
    </item>
    
    <item>
      <title>[백준]2178 미로 탐색</title>
      <link>https://jyukki97.github.io/blog/2020-02-28-2178/</link>
      <pubDate>Fri, 28 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-02-28-2178/</guid>
      <description>https://www.acmicpc.net/problem/2178
풀이: 이동횟수가 i 일때,
이동횟수가 i - 1 인 값들에서 왼쪽, 오른쪽, 위, 아래 중 값이 1이고, 방문한적 없는 곳을 찾아 좌표를 큐에 넣는다.
만약 현재 좌표가 도착위치라면, 이동횟수 i를 출력한다.
코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;queue&amp;gt;using namespace std;int n, m, k, q, w;vector&amp;lt;string&amp;gt; a;queue&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; dp2;bool b[102][102];int main() {cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;a.resize(n);for (int i = 0; i &amp;lt; n; i++)cin &amp;gt;&amp;gt; a[i];dp2.</description>
    </item>
    
    <item>
      <title>[백준]7576 토마토</title>
      <link>https://jyukki97.github.io/blog/2020-02-28-7576/</link>
      <pubDate>Fri, 28 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-02-28-7576/</guid>
      <description>https://www.acmicpc.net/problem/7576
풀이: [백준]2178 미로 탐색 참고
코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;queue&amp;gt;using namespace std;int n, m, k, q, w, a[1002][1002];queue&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; dp2;int main() {cin &amp;gt;&amp;gt; m &amp;gt;&amp;gt; n;for (int i = 0; i &amp;lt; n; i++)for (int t = 0; t &amp;lt; m; t++) {cin &amp;gt;&amp;gt; a[i][t];if (a[i][t] == 1)	dp2.push({ i,t });}for (int i = 0;; i++) {queue&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; dp1;while (!</description>
    </item>
    
    <item>
      <title>[백준]10942 팰린드롬?</title>
      <link>https://jyukki97.github.io/blog/2020-02-27-10942/</link>
      <pubDate>Thu, 27 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-02-27-10942/</guid>
      <description>https://www.acmicpc.net/problem/10942
풀이: DP[i][t] : i 번쨰 수 부터 t 번째 까지 수가 팰린드롬을 이룬다면 1, 아니라면 0
a[i] == a[t] 라면,
DP[i][t] = DP[i + 1][t - 1]
a[i] != a[t] 라면,
DP[i][t] = 0
테스트 케이스가 많아 시간초과가 날 수 있으므로 메모이제이션을 하자! 코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;string.h&amp;gt;using namespace std;int m, n, q, w, a[2002], dp[2002][2002];int p(int x, int y) {if (dp[x][y] !</description>
    </item>
    
    <item>
      <title>[백준]1260 DFS와 BFS</title>
      <link>https://jyukki97.github.io/blog/2020-02-27-1260/</link>
      <pubDate>Thu, 27 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-02-27-1260/</guid>
      <description>https://www.acmicpc.net/problem/1260
풀이: DFS 와 BFS를 출력한다.
코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;queue&amp;gt;#include &amp;lt;string.h&amp;gt;using namespace std;int n, m, v, q, w, a[1002][1002] = {};bool b[1002];void dfs(int x) {b[x] = true;cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &amp;#34;&amp;#34;;for (int i = 1; i &amp;lt;= n; i++)if (a[x][i] &amp;amp;&amp;amp; !b[i])	dfs(i);}int main() {cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m &amp;gt;&amp;gt; v;for (int i = 0; i &amp;lt; m; i++) {cin &amp;gt;&amp;gt; q &amp;gt;&amp;gt; w;a[q][w] = 1;a[w][q] = 1;}dfs(v);cout &amp;lt;&amp;lt; endl;memset(b, 0, n + 1);queue&amp;lt;int&amp;gt; c;c.</description>
    </item>
    
    <item>
      <title>[백준]1520 내리막 길</title>
      <link>https://jyukki97.github.io/blog/2020-02-27-1520/</link>
      <pubDate>Thu, 27 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-02-27-1520/</guid>
      <description>https://www.acmicpc.net/problem/1520
풀이: DP[i][t] : (1,1) ~ (i, t) 까지 내리막으로 갈 수 있는 경우의 수
현재 값에서 왼쪽, 오른쪽, 위, 아래 값이 각각 현재 값보다 크다면,
DP[현재] += DP[왼쪽, 오른쪽, 위, 아래] 로 구할 수 있다.
시간초과가 날 수 있으므로 메모이제이션을 하자! 코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;string.h&amp;gt;using namespace std;int m, n, a[502][502], dp[502][502];int r(int x, int y) {if (dp[x][y] != -1)	return dp[x][y];dp[x][y] = 0;if (a[x][y] &amp;lt; a[x - 1][y])dp[x][y] += r(x - 1, y);if (a[x][y] &amp;lt; a[x + 1][y])dp[x][y] += r(x + 1, y);if (a[x][y] &amp;lt; a[x][y + 1])dp[x][y] += r(x, y + 1);if (a[x][y] &amp;lt; a[x][y - 1])dp[x][y] += r(x, y - 1);return dp[x][y];}int main() {cin &amp;gt;&amp;gt; m &amp;gt;&amp;gt; n;for (int i = 1; i &amp;lt;= m; i++)for (int t = 1; t &amp;lt;= n; t++)cin &amp;gt;&amp;gt; a[i][t];memset(dp, -1, sizeof(dp));dp[1][1] = 1;cout &amp;lt;&amp;lt; r(m, n) &amp;lt;&amp;lt; endl;}</description>
    </item>
    
    <item>
      <title>[백준]2618 경찰차</title>
      <link>https://jyukki97.github.io/blog/2020-02-27-2618/</link>
      <pubDate>Thu, 27 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-02-27-2618/</guid>
      <description>https://www.acmicpc.net/problem/2618
풀이: DP[i][t] : 첫번째 경찰차가 i 번째 사건을, 두번째 경찰차가 t 번째 사건을 처리했을 때, 이동하는 거리의 합의 최소값
i 와 t 의 차이가 1 이라면,
DP[i][t] = DP[i][0 ~ t - 1] (t 번째와 0 ~ t - 1 번째 사이의 거리)까지의 최소값
1이 아니라면,
DP[i][t] = DP[i][t - 1] + (t 번째와 t - 1 번째 사이의 거리)
을 통해 최솟값을 구할 수 있다.
최솟값을 구한 후, 최솟값을 구한 경로를 역순으로 추적하여, 맡겨진 경찰차의 번호를 구한다.</description>
    </item>
    
    <item>
      <title>[백준]2667 단지번호붙이기</title>
      <link>https://jyukki97.github.io/blog/2020-02-27-2667/</link>
      <pubDate>Thu, 27 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-02-27-2667/</guid>
      <description>https://www.acmicpc.net/problem/2667
풀이: 전체를 순회한다.
만약 집이있는 곳 ( 배열에 1인 곳 ) 을 찾았다면, 연결된 모든 단지를 찾아 단지 크기를 배열에 저장한다.
순회가 끝났다면, 배열의 사이즈 (총 단지수) 를 출력한다.
그 후 단지내 집의 수를 오름차순으로 정렬하여 출력하여야하므로
배열을 정렬한 후 배열의 원소를 출력한다.
코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;string&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;int n;bool b[26][26];vector&amp;lt;string&amp;gt; a;vector&amp;lt;int&amp;gt; c;void num(int x, int y) {b[x][y] = true;c.</description>
    </item>
    
    <item>
      <title>[백준]10816 숫자 카드2</title>
      <link>https://jyukki97.github.io/blog/2020-02-26-10816/</link>
      <pubDate>Wed, 26 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-02-26-10816/</guid>
      <description>https://www.acmicpc.net/problem/10816
풀이: 배열에 숫자 카드들을 넣는다.
배열을 정렬한다.
몇 개 가지고 있는지 구해야 할 카드를 k 라고 할 때,
k가 최초로 나오는 위치 = lower_bound,
k보다 큰 값이 최초로 나오는 위치 = upper_bound
로 구할 수 있다.
즉 upper_bound - lower_bound를 실행한다면 답을 구할 수 있다.
cout과 cin 을 쓰면 시간초과가 나므로 주의하자. 코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;int n, m, k, a[500001];int main() {scanf(&amp;#34;%d&amp;#34;, &amp;amp;n);for (int i = 0; i &amp;lt; n; i++)scanf(&amp;#34;%d&amp;#34;, &amp;amp;a[i]);sort(a, a + n);scanf(&amp;#34;%d&amp;#34;, &amp;amp;m);for (int i = 0; i &amp;lt; m; i++) {scanf(&amp;#34;%d&amp;#34;, &amp;amp;k);auto l = lower_bound(a, a + n, k);auto r = upper_bound(a, a + n, k);printf(&amp;#34;%d &amp;#34;, r - l);}printf(&amp;#34;\n&amp;#34;);return 0;}</description>
    </item>
    
    <item>
      <title>[백준]11049 행렬 곱셈 순서</title>
      <link>https://jyukki97.github.io/blog/2020-02-26-11049/</link>
      <pubDate>Wed, 26 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-02-26-11049/</guid>
      <description>https://www.acmicpc.net/problem/11049
풀이: DP[i][t] : i ~ t 까지의 행렬을 곱하는데 필요한 곱셈 연산 횟수의 최솟값
dp[x][y] = min(dp[x][y], f(x, i) + f(i + 1, y) + a[x] * b[i] * b[y])
x ~ i 까지의 행렬 곱셈 + (i + 1) ~ y 까지의 행렬 곱셈 + 그 둘의 곱셈
코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;long long n, a[502], b[502], dp[502][502] = {};long long f(int x, int y) {if (x == y || dp[x][y])	return dp[x][y];dp[x][y] = f(x, x) + f(x + 1, y) + a[x] * b[x] * b[y];for (int i = x + 1; i &amp;lt; y; i++)dp[x][y] = min(dp[x][y], f(x, i) + f(i + 1, y) + a[x] * b[i] * b[y]);return dp[x][y];}int main() {cin &amp;gt;&amp;gt; n;for (int i = 1; i &amp;lt;= n; i++)cin &amp;gt;&amp;gt; a[i] &amp;gt;&amp;gt; b[i];cout &amp;lt;&amp;lt; f(1, n) &amp;lt;&amp;lt; endl;}</description>
    </item>
    
    <item>
      <title>[백준]11066 파일 합치기</title>
      <link>https://jyukki97.github.io/blog/2020-02-26-11066/</link>
      <pubDate>Wed, 26 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-02-26-11066/</guid>
      <description>https://www.acmicpc.net/problem/11066
풀이: dp[i][t] = i 장 부터 t 장까지 수록한 파일을 합쳤을 때, 필요한 최소비용
sum[i] = 1 ~ i 까지의 파일 크기의 합
dp[i][t] = min(dp[i][t], dp[i][i] ~ dp[i][t - 1] + dp[i + 1][t] ~ dp[t][t]) 로 구할 수 있다.
겹치는 숫자들이 있으므로,
dp를 구할 때 마다, dp[i][t] += sum[t] - sum[i - 1] 을 해주어야 한다.
코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;int T, n, a[502], dp[502][502] = {}, sum[502];int f(int a, int b) {if (dp[a][b] !</description>
    </item>
    
    <item>
      <title>[백준]11286 절댓값 힘</title>
      <link>https://jyukki97.github.io/blog/2020-02-26-11286/</link>
      <pubDate>Wed, 26 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-02-26-11286/</guid>
      <description>https://www.acmicpc.net/problem/11286
풀이: 0이 나온다면, 배열에 있는 값중 절댓값이 가장 작은 값을 출력한다.(절댓값이 같다면, 가장 작은 값을 출력한다.) 그 값을 배열에서 제외시킨다.
만약 배열이 비어있다면, 0을 출력한다.
0이 아닌 다른 숫자가 나온다면, 그 값을 배열에 넣는다.
cout, cin 을 사용하면, 시간초과가 나므로 주의하자. 코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;queue&amp;gt;using namespace std;int n, i, m;bool com(int a, int b) {if (abs(a) == abs(b))return a &amp;gt; b;return abs(a) &amp;gt; abs(b);}int main() {priority_queue&amp;lt;int, vector&amp;lt;int&amp;gt;, decltype(&amp;amp;com)&amp;gt; a(&amp;amp;com);scanf(&amp;#34;%d&amp;#34;, &amp;amp;n);for (i = 0; i &amp;lt; n; i++) {scanf(&amp;#34;%d&amp;#34;, &amp;amp;m);if (!</description>
    </item>
    
    <item>
      <title>[백준]1654 랜선 자르기</title>
      <link>https://jyukki97.github.io/blog/2020-02-26-1654/</link>
      <pubDate>Wed, 26 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-02-26-1654/</guid>
      <description>https://www.acmicpc.net/problem/1654
풀이: 배열을 받아온다.
배열의 들어있는 랜선의 길이 중 최댓값이
만들 수 있는 최대 길이의 랜선이므로 최댓값을 설정한다.
최솟값은 1로 설정한다.
최댓값과 최솟값의 중간값을 m이라고 하자.
모든 배열의 원소를 m으로 나눈 몫을 모두 더한다.
더한 값이 필요한 랜선의 갯수보다 작다면, m값이 너무 크다는 것이므로 최댓값을 m - 1 로 바꿔준다.
더한 값이 필요한 랜선의 갯수보다 크거나 같다면, 만들 수 있다는 것이므로 답에 저장해 놓는다.
이때, 랜선의 최대 길이를 찾아야 하므로, 랜선의 갯수와 같다고 바로 끝내지 말고 위로 가면서 최댓값을 찾아야한다.</description>
    </item>
    
    <item>
      <title>[백준]1655 가운데를 말해요</title>
      <link>https://jyukki97.github.io/blog/2020-02-26-1655/</link>
      <pubDate>Wed, 26 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-02-26-1655/</guid>
      <description>https://www.acmicpc.net/problem/1655
풀이: 하나씩 숫자를 받아온다.
첫번째 숫자를 mid 라고 할 때,
현재 숫자가 mid보다 크거나 같다면, 배열 r 에 작다면, 배열 l 에 저장한다.
mid를 배열 r 에 넣고, 배열 l 의 값 중 가장 큰 값으로 바꾼다.
만약, 배열 r과 l의 사이즈 차이가 2이상 난다면, mid값을 조정해준다.
cout, cin 을 사용하면, 시간초과가 나므로 주의하자. 코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;queue&amp;gt;using namespace std;int n, m, mid;int main() {priority_queue&amp;lt;int, vector&amp;lt;int&amp;gt;, greater&amp;lt;int&amp;gt;&amp;gt; r;priority_queue&amp;lt;int&amp;gt; l;scanf(&amp;#34;%d %d&amp;#34;, &amp;amp;n, &amp;amp;mid);printf(&amp;#34;%d\n&amp;#34;, mid);while (--n) {scanf(&amp;#34;%d&amp;#34;, &amp;amp;m);m &amp;lt; mid ?</description>
    </item>
    
    <item>
      <title>[백준]2110 공유기 설치</title>
      <link>https://jyukki97.github.io/blog/2020-02-26-2110/</link>
      <pubDate>Wed, 26 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-02-26-2110/</guid>
      <description>https://www.acmicpc.net/problem/2110
풀이: [백준]1654 랜선 자르기 참고
최대 거리를 설정하고,
그 거리를 기준으로 공유기를 설치할 수 있는지 확인하고,
이분탐색으로 최대 거리를 조절해 나간다.
코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;long long n, k, i, a[200001], sum, m, l = 1, r, c = 0, d;int main() {cin &amp;gt;&amp;gt; k &amp;gt;&amp;gt; n;for (i = 0; i &amp;lt; k; i++)cin &amp;gt;&amp;gt; a[i];sort(a, a + k);r = a[k - 1];while (l &amp;lt;= r) {sum = 1;m = (r + l) / 2;d = a[0];for (i = 1; i &amp;lt; k; i++)if (d + m &amp;lt;= a[i]) {d = a[i];sum++;}if (sum &amp;lt; n)	r = m - 1;else {c = max(c, m);l = m + 1;}}cout &amp;lt;&amp;lt; c &amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
    <item>
      <title>[백준]2805 나무 자르기</title>
      <link>https://jyukki97.github.io/blog/2020-02-26-2805/</link>
      <pubDate>Wed, 26 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-02-26-2805/</guid>
      <description>https://www.acmicpc.net/problem/2805
풀이: [백준]1654 랜선 자르기 참고
m값이 배열의 값보다 작은데 a[i] - m을 할 경우 -값이 나오므로 주의하자. 코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;long long n, k, i, a[1000001], sum, m, l = 1, r = 0, c = 0;int main() {cin &amp;gt;&amp;gt; k &amp;gt;&amp;gt; n;for (i = 0; i &amp;lt; k; i++) {cin &amp;gt;&amp;gt; a[i];r = max(r, a[i]);}while (l &amp;lt;= r) {sum = 0;m = (r + l) / 2;for (i = 0; i &amp;lt; k; i++)sum += a[i] &amp;lt; m ?</description>
    </item>
    
    <item>
      <title>[백준]k번째 수</title>
      <link>https://jyukki97.github.io/blog/2020-02-26-1300/</link>
      <pubDate>Wed, 26 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-02-26-1300/</guid>
      <description>https://www.acmicpc.net/problem/1300
풀이: [백준]1654 랜선 자르기 참고
현재 숫자의 순서가 k를 넘어간다면,
오른쪽 탐색을, 아니라면 왼쪽으로 탐색한다.
int형 사이즈를 넘어가니 long long으로 바꿔주자. 코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;long long n, k, i, sum, m, l = 1, r, c;int main() {cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; k;r = n * n;c = r;while (l &amp;lt;= r) {sum = 0;m = (r + l) / 2;for (i = 1; i &amp;lt;= n; i++)sum += min(n, m / i);if (sum &amp;lt; k)	l = m + 1;else {c = min(c, m);r = m - 1;}}cout &amp;lt;&amp;lt; c &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;}</description>
    </item>
    
    <item>
      <title>[백준]1780 종이의 개수</title>
      <link>https://jyukki97.github.io/blog/2020-02-25-1780/</link>
      <pubDate>Tue, 25 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-02-25-1780/</guid>
      <description>https://www.acmicpc.net/problem/1780
풀이: [백준]2630 색종이 만들기 참고
코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;using namespace std;int n, c[2200][2200], W = 0, B = 0, D = 0;void se(int x, int y, int a) {bool w = true, b = true, d = true;for (int i = 0; i &amp;lt; a; i++)for (int t = 0; t &amp;lt; a; t++)if (!w &amp;amp;&amp;amp; !b &amp;amp;&amp;amp; !d) break;else if (c[x + i][y + t] == -1) {w = false;b = false;}else if (c[x + i][y + t]) {w = false;d = false;}else {d = false;b = false;}W += 1 &amp;amp; w;B += 1 &amp;amp; b;D += 1 &amp;amp; d;if (!</description>
    </item>
    
    <item>
      <title>[백준]1992 쿼드트리</title>
      <link>https://jyukki97.github.io/blog/2020-02-25-1992/</link>
      <pubDate>Tue, 25 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-02-25-1992/</guid>
      <description>https://www.acmicpc.net/problem/1992
풀이: [백준]2630 색종이 만들기 참고
코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;string&amp;gt;using namespace std;int n;string s, c[65];void se(int x, int y, int a) {if (x &amp;gt;= n || y &amp;gt;= n || !a)	return;bool w = true, b = true;for (int i = 0; i &amp;lt; a; i++)for (int t = 0; t &amp;lt; a; t++)if (!w &amp;amp;&amp;amp; !b) break;else if (c[x + i][y + t] == &amp;#39;1&amp;#39;)	w = false;else b = false;if (w)	s += &amp;#39;0&amp;#39;;else if (b) s += &amp;#39;1&amp;#39;;else{s += &amp;#39;(&amp;#39;;a /= 2;se(x, y, a);se(x, y + a, a);se(x + a, y, a);se(x + a, y + a, a);s += &amp;#39;)&amp;#39;;}}int main() {cin &amp;gt;&amp;gt; n;for (int i = 0; i &amp;lt; n; i++)cin &amp;gt;&amp;gt; c[i];se(0, 0, n);cout &amp;lt;&amp;lt; s &amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
    <item>
      <title>[백준]2630 색종이 만들기</title>
      <link>https://jyukki97.github.io/blog/2020-02-25-2630/</link>
      <pubDate>Tue, 25 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-02-25-2630/</guid>
      <description>https://www.acmicpc.net/problem/2630
풀이: n을 2로 나누어 가며 1로 이루어진 곳인지 0으로 이루어진 곳인지 판단한다.
0으로 이루어져있다면 W를 +1 , 1로 이루어져있다면 B를 +1 해준다.
하얀색 색종이와 파란색 색종이의 갯수를 출력한다.
코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;using namespace std;int n, c[129][129], W = 0, B = 0;void se(int x, int y, int a) {if (x &amp;gt;= n || y &amp;gt;= n || !a)	return;bool w = true, b = true;for (int i = 0; i &amp;lt; a; i++)for (int t = 0; t &amp;lt; a; t++)if (!</description>
    </item>
    
    <item>
      <title>[백준]6549 히스토그램에서 가장 큰 직사각형</title>
      <link>https://jyukki97.github.io/blog/2020-02-25-6549/</link>
      <pubDate>Tue, 25 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-02-25-6549/</guid>
      <description>https://www.acmicpc.net/problem/6549
풀이: 값을 하나씩 받아온다.
현재 값보다 스택에 있는 값이 더 크다면,
max(현재 max값, 스택의 탑값 * (스택의 탑 바로 전 값의 위치와 현재 위치의 차이)) 을 수행하고, 현재 탑에 있는 값을 pop한다.
스택에 모든 값이 현재 있는 값보다 작거나 같다면, 스택에 현재 값을 push한다.
모든 값을 받았다면, 스택이 빌 때까지
max(현재 max값, 스택의 탑값 * (스택의 탑 바로 전 값의 위치와 전체 히스토그램의 길이의 차이))
를 수행한다.
히스토그램의 길이가 0일경우 반복을 중지한다.</description>
    </item>
    
    <item>
      <title>[백준]11054 가장 긴 바이토닉 부분 수열</title>
      <link>https://jyukki97.github.io/blog/2020-02-24-11054/</link>
      <pubDate>Mon, 24 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-02-24-11054/</guid>
      <description>https://www.acmicpc.net/problem/11054
풀이: b[i] = i 위치 왼쪽에 있는 값들 중 m[i] 보다 작은 수들의 최대 갯수
s[i] = i 위치 오른쪽에 있는 값들 중 m[i] 보다 작은 수들의 최대 갯수
가장 긴 수열의 길이 = 모든 i 에 대해 (b[i] + s[i] + 1) 의 최댓값
코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;int n, m[1001], b[1001], s[1001], ma = 0;int main() {cin &amp;gt;&amp;gt; n;for (int i = 0; i &amp;lt; n; i++)cin &amp;gt;&amp;gt; m[i];for (int i = n - 2; i &amp;gt;= 0; i--)for (int t = n - 1; t &amp;gt; i; t--)if (m[i] &amp;gt; m[t])s[i] = max(s[i], s[t] + 1);for (int i = 0; i &amp;lt; n; i++) {for (int t = 0; t &amp;lt; i; t++)if (m[i] &amp;gt; m[t])b[i] = max(b[i], b[t] + 1);ma = max(ma, b[i] + s[i] + 1);}cout &amp;lt;&amp;lt; ma &amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
    <item>
      <title>[백준]12865 평범한 배낭</title>
      <link>https://jyukki97.github.io/blog/2020-02-24-12865/</link>
      <pubDate>Mon, 24 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-02-24-12865/</guid>
      <description>https://www.acmicpc.net/problem/12865
풀이: DP[i] : i 무게일 때, 배낭에 넣을 수 있는 물건의 가치의 최댓값
DP[i + w] = max(DP[i + w], DP[i] + v)
무게가 i + w 일 때, 최댓값은 이전에 있었던 i + w 일때의 값과, i 에 있는 값에 w 무게 물건의 가치인 v를 더한 값 중 최댓값이다.
(DP를 DP[2][100001] 처럼 두개로 나누어 놓은 이유는 물건의 갯수가 1개씩이기 때문에 물건 중복을 피하기위해 나누어놓았다.)
ex) 무게가 4이고, 가치가 5일때, DP[4] = 5 가 되지만, DP[8] = DP[4] + 5 가 되어 10이 되는 불상사가 일어날 수 있기 때문에, 두개로 나누어 놓앗다.</description>
    </item>
    
    <item>
      <title>[백준]14888 연산자 끼워넣기</title>
      <link>https://jyukki97.github.io/blog/2020-02-24-14888/</link>
      <pubDate>Mon, 24 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-02-24-14888/</guid>
      <description>https://www.acmicpc.net/problem/14888
풀이: 각 숫자를 순서대로 배열에 넣어놓는다.
+, -, *, / 를 갯수만큼 각 숫자사이의 끼워넣어 식을 만든다.
만들 식의 값들을 배열에 저장해놓는다.
배열에 들어있는 수 중 최댓값, 최솟값을 출력한다.
코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;int n, num[101], op[4];vector&amp;lt;int&amp;gt; sumn;void o(int a, int b) {if (a == n - 1) {sumn.push_back(b);return;}if (op[0] &amp;gt; 0) {op[0]--;o(a + 1, b + num[a + 1]);op[0]++;}if (op[1] &amp;gt; 0) {op[1]--;o(a + 1, b - num[a + 1]);op[1]++;}if (op[2] &amp;gt; 0) {op[2]--;o(a + 1, b * num[a + 1]);op[2]++;}if (op[3] &amp;gt; 0) {op[3]--;o(a + 1, b / num[a + 1]);op[3]++;}}int main() {cin &amp;gt;&amp;gt; n;for (int i = 0; i &amp;lt; n; i++)cin &amp;gt;&amp;gt; num[i];cin &amp;gt;&amp;gt; op[0] &amp;gt;&amp;gt; op[1] &amp;gt;&amp;gt; op[2] &amp;gt;&amp;gt; op[3];o(0, num[0]);sort(sumn.</description>
    </item>
    
    <item>
      <title>[백준]14889 스타트와 링크</title>
      <link>https://jyukki97.github.io/blog/2020-02-24-14889/</link>
      <pubDate>Mon, 24 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-02-24-14889/</guid>
      <description>https://www.acmicpc.net/problem/14889
풀이: n / 2 명의 스타트 팀과 n / 2 팀의 링크팀을 만든다.
스타트팀만 만든다면, 자동적으로 남는 사람들은 링크팀이된다.
구하는 팀에 1은 무조건 들어가도록한다. (1을 포함한 팀을 전부 구한다면, 1을 포함하지 않는 팀은 상대팀에 모두 있기 때문에)
스타트팀의 모든 Sij 값의 합과 링크팀의 모든 Sij 값의 합의 차이를 구한다.
구한 차이들 중 가장 작은 값을 출력한다.
코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;int n, m[21][21], mn = 100000, start, link;bool s[21];void st(int a, int b) {if (a == n / 2) {start = 0;link = 0;for (int i = 0; i &amp;lt; n; i++)if (s[i]) {for (int t = i + 1; t &amp;lt; n; t++)if (s[t])start += m[i][t] + m[t][i];}elsefor (int t = i + 1; t &amp;lt; n; t++)if (!</description>
    </item>
    
    <item>
      <title>[백준]1541 잃어버린 괄호</title>
      <link>https://jyukki97.github.io/blog/2020-02-24-1541/</link>
      <pubDate>Mon, 24 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-02-24-1541/</guid>
      <description>https://www.acmicpc.net/problem/1541
풀이: 문자열을 하나씩 확인한다.
+ 라면, 괄호를 치지않는다.
- 라면, 괄호를 친다.
즉, -가 나오면 시작괄호를 치고, 다음 -가 나오면, 끝나는 괄호가 된다.
ex) 45 + 55 - 65 + 45 - 67 + 67
= 45 + 55 - (65 + 45) - (67 + 67)
코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;string&amp;gt;using namespace std;int main() {string s;vector&amp;lt;int&amp;gt; a;int n = 0;cin &amp;gt;&amp;gt; s;a.</description>
    </item>
    
    <item>
      <title>[백준]1676 팩도리얼 0의 개수</title>
      <link>https://jyukki97.github.io/blog/2020-02-24-1676/</link>
      <pubDate>Mon, 24 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-02-24-1676/</guid>
      <description>https://www.acmicpc.net/problem/1676
풀이: 뒤에서 0이 나오려면 팩토리얼을 곱할때, 5 가 곱해져야한다.
즉, 5의 배수가 지나간다면, 팩토리얼의 갯수가 1씩 늘어날 것이다.
팩토리얼을 만드는 동안 5가 몇번 곱해지는지 계산한다면, 0의 갯수를 구할 수 있다.
(이 문제는 N의 제한이 500 까지이기 때문에, 팩토리얼을 전체 계산해서 구하기는 힘들다.)
코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;using namespace std;int main() {int n, m = 0;cin &amp;gt;&amp;gt; n;while (n) {n /= 5;m += n;}cout &amp;lt;&amp;lt; m &amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
    <item>
      <title>[백준]1931 회의실배정</title>
      <link>https://jyukki97.github.io/blog/2020-02-24-1931/</link>
      <pubDate>Mon, 24 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-02-24-1931/</guid>
      <description>https://www.acmicpc.net/problem/1931
풀이: 회의 정보를 배열에 저장한다.
저장된 배열을 끝나는 시간을 기준으로 정렬한다. (끝나는 시간이 같다면, 시작하는 시간을 기준으로 정렬)
배열을 처음부터 순회해간다.
저장된 끝값보다 현재 시작시간이 더 크다면, 끝값을 현재 끝나는 시간으로 바꾸고 사용할 수 있는 회의 수를 +1 해준다.
코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;int n, ma = 0, e = -1;int main() {cin &amp;gt;&amp;gt; n;vector&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; v(n);for (int i = 0; i &amp;lt; n; i++)cin &amp;gt;&amp;gt; v[i].</description>
    </item>
    
    <item>
      <title>[백준]2565 전깃줄</title>
      <link>https://jyukki97.github.io/blog/2020-02-24-2565/</link>
      <pubDate>Mon, 24 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-02-24-2565/</guid>
      <description>https://www.acmicpc.net/problem/2565
풀이: c[i] = i 위치 이전 값 중 겹치는 것이 없는 갯수의 최대
연결된 전깃줄 A와 전깃줄 B 를 배열에 저장한다.
저장된 배열을 전깃줄 A를 기준으로 정렬한다.
첫번째 원소부터, 이전 원소 중 전깃줄 B가 더 작은 값 중 c[i] 의 최댓값 + 1을 저장한다.
max값에 c[i]의 최댓값 + 1 중 최댓값을 저장한다.
n - max값을 출력한다.
코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;int n, a, b, c[101], ma = 0;vector&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; v;int main() {cin &amp;gt;&amp;gt; n;for (int i = 0; i &amp;lt; n; i++) {cin &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b;v.</description>
    </item>
    
    <item>
      <title>[백준]5430 AC</title>
      <link>https://jyukki97.github.io/blog/2020-02-24-5430/</link>
      <pubDate>Mon, 24 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-02-24-5430/</guid>
      <description>https://www.acmicpc.net/problem/5430
풀이: 배열안에 들어있는 원소를
R이 나오면 뒤집고,
D가 나오면 맨 앞 숫자를 버린다.
만약 D가 나왔는데, 배열이 비어있다면, error 를 출력한다.
시간초과에 주의하자 : cout &amp;raquo; printf, cin &amp;raquo; scanf
특히 strlen을 주의하자 시간을 많이잡아먹는다.
코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;string.h&amp;gt;#include &amp;lt;queue&amp;gt;using namespace std;int main() {int T, n, m;cin &amp;gt;&amp;gt; T;while (T--) {deque&amp;lt;int&amp;gt; a;char p[100001], s[300001], *tok;bool b = true, l = true;scanf(&amp;#34;%s %d %s&amp;#34;, &amp;amp;p, &amp;amp;n, &amp;amp;s);if (n) {tok = strtok(s, &amp;#34;[,]&amp;#34;);do {a.</description>
    </item>
    
    <item>
      <title>[백준]9375 패션왕 신해빈</title>
      <link>https://jyukki97.github.io/blog/2020-02-24-9375/</link>
      <pubDate>Mon, 24 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-02-24-9375/</guid>
      <description>https://www.acmicpc.net/problem/9375
풀이: 프로그래머스]위장 을 참고
코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;string&amp;gt;#include &amp;lt;map&amp;gt;using namespace std;int main() {int n, m, ma;cin &amp;gt;&amp;gt; n;while (n--) {ma = 1;cin &amp;gt;&amp;gt; m;string s;map&amp;lt;string, int&amp;gt; a;for (int i = 0; i &amp;lt; m; i++) {cin &amp;gt;&amp;gt; s &amp;gt;&amp;gt; s;a[s]++;}for (auto i = a.begin(); i != a.end(); i++)ma *= i-&amp;gt;second + 1;cout &amp;lt;&amp;lt; ma - 1 &amp;lt;&amp;lt; endl;}return 0;}</description>
    </item>
    
    <item>
      <title>[백준]9663 N-Queen</title>
      <link>https://jyukki97.github.io/blog/2020-02-23-9663/</link>
      <pubDate>Sun, 23 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-02-23-9663/</guid>
      <description>https://www.acmicpc.net/problem/9663
풀이: https://jyukki97.github.io/blog/2020-02-23-nqueen/ 을 참고
코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;using namespace std;bool visit[16][16];int n, sum = 0;bool po(int a, int b) {for (int i = 1; i &amp;lt;= a || i &amp;lt;= b; i++) {if ((a - i &amp;gt;= 0 &amp;amp;&amp;amp; b - i &amp;gt;= 0 &amp;amp;&amp;amp; visit[a - i][b - i]) ||(a - i &amp;gt;= 0 &amp;amp;&amp;amp; b + i &amp;lt; n &amp;amp;&amp;amp; visit[a - i][b + i]) ||(a - i &amp;gt;= 0 &amp;amp;&amp;amp; visit[a - i][b]))	return false;}return true;}void nq(int a) {for (int i = 0; i &amp;lt; n; i++) {if (po(a, i)) {if (a == n - 1)	sum++;else {visit[a][i] = true;nq(a + 1);visit[a][i] = false;}}}}int main() {cin &amp;gt;&amp;gt; n;nq(0);cout &amp;lt;&amp;lt; sum &amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
    <item>
      <title>[백준]1181 단어 정렬</title>
      <link>https://jyukki97.github.io/blog/2020-02-22-1181/</link>
      <pubDate>Sat, 22 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-02-22-1181/</guid>
      <description>https://www.acmicpc.net/problem/1181
풀이: 배열에 들어있는 string을 길이 순서로 정렬 후
길이가 같다면, 사전순으로 정렬한다.
이 때, 중복된 문자가 있다면, 제거한다.
코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;set&amp;gt;#include &amp;lt;string&amp;gt;using namespace std;bool com(string a, string b) {if (a.size() == b.size())return a &amp;lt; b;return a.size() &amp;lt; b.size();}int main() { int n;cin &amp;gt;&amp;gt; n;string s;set&amp;lt;string, decltype(&amp;amp;com)&amp;gt; a(&amp;amp;com);for (int i = 0; i &amp;lt; n; i++) {cin &amp;gt;&amp;gt; s;a.</description>
    </item>
    
    <item>
      <title>[백준]1018 체스판 다시 칠하기</title>
      <link>https://jyukki97.github.io/blog/2020-02-21-1018/</link>
      <pubDate>Fri, 21 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-02-21-1018/</guid>
      <description>https://www.acmicpc.net/problem/1018
풀이: (0, 0) ~ (8, 8) &amp;hellip;.. (n - 8, m - 8) ~ (n, m) 까지의 모든 8 X 8 체스판을 서치한다.
체스판이 WBWBWB&amp;hellip; 순서로 되어있는지 확인 후 안되어 있는 칸이 몇 칸인지 찾는다.
찾아낸 수를 C라고 할 때, 64 - C와 C 중 더 작은 값을 저장한다.
저장된 값들 중 가장 작은 값을 출력한다.
코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;string&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;int main() { int n, m, c, ma = 64;cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;vector&amp;lt;string&amp;gt; a(n);for (int i = 0; i &amp;lt; n; i++)cin &amp;gt;&amp;gt; a[i];for (int i = 0; i &amp;lt; n - 7; i++) {for (int t = 0; t &amp;lt; m - 7; t++) {c = 0;for (int y = 0; y &amp;lt; 8; y++)for (int u = 0; u &amp;lt; 8; u++) {bool b = (y % 2) ^ (u % 2) ^ (a[i + y][t + u] == &amp;#39;B&amp;#39; ?</description>
    </item>
    
    <item>
      <title>[백준]2231 분해합</title>
      <link>https://jyukki97.github.io/blog/2020-02-20-2231/</link>
      <pubDate>Thu, 20 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-02-20-2231/</guid>
      <description>https://www.acmicpc.net/problem/2231
풀이: n - (n의 자릿수 * 9) ~ n 까지의 수 중 n의 생성자를 찾아 출력한다.
없다면 0을 출력
n의 자릿수 * 9를 뺀 수부터 시작하는 이유는 생성자가 n + (n의 각 자릿수의 합) 이므로
각 자릿수의 최댓값인 9를 자릿수 만큼 곱한 후 n에서 빼준 값이 생성자의 최소 조건이 된다.
코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;string&amp;gt;using namespace std;int c(int a) {int n = a;while (a) {n += a % 10;a /= 10;}return n;}int main() { string m;bool b = true;cin &amp;gt;&amp;gt; m;int n = stoi(m), a = n - 9 * m.</description>
    </item>
    
    <item>
      <title>[백준]2798 블랙잭</title>
      <link>https://jyukki97.github.io/blog/2020-02-19-2798/</link>
      <pubDate>Wed, 19 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-02-19-2798/</guid>
      <description>https://www.acmicpc.net/problem/2798
풀이: 3장을 뽑을 수 있는 모든 경우의 수를 확인하여 3장의 합이 M값을 넘지않는 최댓값을 출력한다.
코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;int main() { int n, m, ma = 0;cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;vector&amp;lt;int&amp;gt; a(n, 0);for (int i = 0; i &amp;lt; n; i++)cin &amp;gt;&amp;gt; a[i];for (int i = 0; i &amp;lt; n - 2; i++)for (int t = i + 1; t &amp;lt; n - 1; t++)for (int y = t + 1; y &amp;lt; n; y++)if (a[i] + a[t] + a[y] &amp;lt;= m)ma = max(ma, a[i] + a[t] + a[y]);cout &amp;lt;&amp;lt; ma &amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
    <item>
      <title>[백준]11729 하노이 탑 이동 순서</title>
      <link>https://jyukki97.github.io/blog/2020-02-18-11729/</link>
      <pubDate>Tue, 18 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2020-02-18-11729/</guid>
      <description>https://www.acmicpc.net/problem/11729
풀이: https://jyukki97.github.io/blog/2020-02-18-towerofhanoi/ 를 참고
코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;using namespace std;void h(int n, int a, int b, int c) {if (!n) return;else {h(n - 1, a, c, b);printf(&amp;#34;%d %d\n&amp;#34;, a, b);h(n - 1, c, b, a);}}int main() { int n, a = 1;cin &amp;gt;&amp;gt; n;for (int i = 0; i &amp;lt; n; i++)a *= 2;cout &amp;lt;&amp;lt; a - 1 &amp;lt;&amp;lt; endl;h(n, 1, 3, 2);return 0;}</description>
    </item>
    
    <item>
      <title>[백준]11399 ATM</title>
      <link>https://jyukki97.github.io/blog/2019-06-20-11399/</link>
      <pubDate>Thu, 20 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-06-20-11399/</guid>
      <description>https://www.acmicpc.net/problem/11399
풀이:  돈을 인출하는데 필요한 시간을 입력받는다. 입력받은 시간을 정렬한다. 정렬한 값을 n-i를 곱해서 더해준다.  코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;int main() {int n,r=0,a[1001];cin &amp;gt;&amp;gt; n;for (int i = 0; i &amp;lt; n; i++)cin &amp;gt;&amp;gt; a[i];sort(&amp;amp;a[0], &amp;amp;a[n]);for (int i = 0; i &amp;lt; n; i++)r += a[i] * (n - i);cout &amp;lt;&amp;lt; r &amp;lt;&amp;lt; endl;}</description>
    </item>
    
    <item>
      <title>[백준]2609 최대공약수와 최소공배수</title>
      <link>https://jyukki97.github.io/blog/2019-06-19-2609/</link>
      <pubDate>Wed, 19 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-06-19-2609/</guid>
      <description>https://www.acmicpc.net/problem/2609
풀이:  두 수를 입력받는다. 두 수의 최대공약수와 최소공배수를 출력한다.  코드: 사용언어 : Python 3
import matha,b=map(int,input().split())c=math.gcd(a,b)print(c,a//c*b)</description>
    </item>
    
    <item>
      <title>[백준]14490 백대열</title>
      <link>https://jyukki97.github.io/blog/2019-06-18-14490/</link>
      <pubDate>Tue, 18 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-06-18-14490/</guid>
      <description>https://www.acmicpc.net/problem/14490
풀이:  두 수를 입력받는다(:을 사이에 두고 주어지므로 주의) 두 수의 최대공약수를 구한다. 두 수를 최대공약수로 나눠서 출력한다(최대한으로 약분은 최대공약수로 나누어주면 가능하다)(이때 :을 사이에 두고 출력한다.)  코드: 사용언어 : Python 3
import matha,b=map(int,input().split(&amp;#39;:&amp;#39;))c=math.gcd(a,b)print(a//c,b//c,sep=&amp;#39;:&amp;#39;)</description>
    </item>
    
    <item>
      <title>[백준]1850 최대공약수</title>
      <link>https://jyukki97.github.io/blog/2019-06-17-1850/</link>
      <pubDate>Mon, 17 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-06-17-1850/</guid>
      <description>https://www.acmicpc.net/problem/1850
풀이:  두 수를 입력받는다 두 수의 최대공약수를 구한다. 최대공약수만큼 1을 반복해서 출력한다.  코드: 사용언어 : Python 3
a,b=map(int,input().split())while b: a,b=b,a%bprint(&amp;#39;1&amp;#39;*a)</description>
    </item>
    
    <item>
      <title>[백준]10757 큰 수 A&#43;B</title>
      <link>https://jyukki97.github.io/blog/2019-06-16-10757/</link>
      <pubDate>Sun, 16 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-06-16-10757/</guid>
      <description>https://www.acmicpc.net/problem/10757
풀이:  두 수를 입력받은 후 더해서 출력한다.  코드: 사용언어 : Python 3
print(sum(map(int,input().split())))</description>
    </item>
    
    <item>
      <title>[백준]10826 피보나치 수 4</title>
      <link>https://jyukki97.github.io/blog/2019-06-15-10826/</link>
      <pubDate>Sat, 15 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-06-15-10826/</guid>
      <description>https://www.acmicpc.net/problem/10826
풀이:  n을 입력받는다 n번째 피보나치 수를 출력한다  코드: 사용언어 : Python 3
s,t=0,1for i in range(int(input())):t,s=s,s+tprint(s)</description>
    </item>
    
    <item>
      <title>[백준]11050 이항 계수 1</title>
      <link>https://jyukki97.github.io/blog/2019-06-14-11050/</link>
      <pubDate>Fri, 14 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-06-14-11050/</guid>
      <description>https://www.acmicpc.net/problem/11050
풀이:  n, k 를 입력받고, nCk를 출력한다  코드: 사용언어 : Python 3
n,k=map(int,input().split())r=1for i in range(k): r*=(n-i)/(i+1)print((int)(r))</description>
    </item>
    
    <item>
      <title>[백준]11365 !밀비 급일</title>
      <link>https://jyukki97.github.io/blog/2019-06-13-11365/</link>
      <pubDate>Thu, 13 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-06-13-11365/</guid>
      <description>https://www.acmicpc.net/problem/11365
풀이:  문자열을 입력받고, 그 문자열을 뒤집어서 출력한다. 문자열이 END라면 반복을 중지한다.  코드: 사용언어 : Python 3
while 1:a=input()if a==&amp;#39;END&amp;#39;:breakprint(a[::-1])</description>
    </item>
    
    <item>
      <title>[백준]10952 A&#43;B - 5</title>
      <link>https://jyukki97.github.io/blog/2019-06-12-10952/</link>
      <pubDate>Wed, 12 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-06-12-10952/</guid>
      <description>https://www.acmicpc.net/problem/10952
풀이:  반복 횟수를 무한히 한 후 입력받은 두 수의 합을 출력 입력받은 두 수가 0 0 이라면 반복문을 빠져나간다.  코드: 사용언어 : Python 3
while 1:a,b=map(int,input().split())if a==0:breakprint(a+b)</description>
    </item>
    
    <item>
      <title>[백준]15552 빠른 A&#43;B</title>
      <link>https://jyukki97.github.io/blog/2019-06-11-15552/</link>
      <pubDate>Tue, 11 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-06-11-15552/</guid>
      <description>https://www.acmicpc.net/problem/15552
풀이:  반복 횟수를 입력받은 후 입력받은 두 수의 합을 출력 간단한 문제이지만 매우 많은 테스트케이스의 수가 있으므로 input() 대신 sys.stdin().readline()을 사용한다.  코드: 사용언어 : Python 3
import sysfor i in range(int(input())):print(sum(map(int,sys.stdin.readline().split())))</description>
    </item>
    
    <item>
      <title>[백준]10950 A&#43;B - 3</title>
      <link>https://jyukki97.github.io/blog/2019-06-10-10950/</link>
      <pubDate>Mon, 10 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-06-10-10950/</guid>
      <description>https://www.acmicpc.net/problem/10950
풀이:  반복 횟수를 입력받은 후 입력받은 두 수의 합을 출력  코드: 사용언어 : Python 3
for i in range(int(input())):print(sum(map(int,input().split())))</description>
    </item>
    
    <item>
      <title>[백준]10971 외판원 순회 2</title>
      <link>https://jyukki97.github.io/blog/2019-06-09-10971/</link>
      <pubDate>Sun, 09 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-06-09-10971/</guid>
      <description>https://www.acmicpc.net/problem/10971
풀이:  [백준]2098 외판원순회 와 같으므로 참고  코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;int w[17][17],d[17][100000], n;int T(int a, int b) {if ((1 &amp;lt;&amp;lt; n) - 1 == b &amp;amp;&amp;amp; w[a][0] != 0)return w[a][0];int &amp;amp;r = d[a][b];if (r &amp;gt; 0)return r;r = 100000000;for (int i = 0; i &amp;lt; n; i++)if (w[a][i] != 0 &amp;amp;&amp;amp; (b &amp;amp; (1 &amp;lt;&amp;lt; i)) == 0)r = min(r, w[a][i] + T(i, b | (1 &amp;lt;&amp;lt; i)));return r;}int main(void) {cin &amp;gt;&amp;gt; n;for (int i = 0; i &amp;lt; n; i++)for (int t = 0; t &amp;lt; n; t++)cin &amp;gt;&amp;gt; w[i][t];cout &amp;lt;&amp;lt; T(0, 1) &amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
    <item>
      <title>[백준]11047 동전 0</title>
      <link>https://jyukki97.github.io/blog/2019-06-08-11047/</link>
      <pubDate>Sat, 08 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-06-08-11047/</guid>
      <description>https://www.acmicpc.net/problem/11047
풀이:  동전에 가격이 높은 것 부터 내가 필요한 가격에서 빼준다. 빼준 횟수만큼 카운트를 높여준다. 카운트를 출력한다. ( i ≥ 2인 경우에 Ai는 Ai-1의 배수) 조건으로 인해 그냥 높은 것 부터 빼줘도 문제가 생기지않는다.  코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;using namespace std;int main() {int n, k, s[12], c = 0;cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; k;while (n--)cin &amp;gt;&amp;gt; s[n];while (k) {c += k / s[++n]; k %= s[n];}cout &amp;lt;&amp;lt; c &amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
    <item>
      <title>[백준]2164 카드2</title>
      <link>https://jyukki97.github.io/blog/2019-06-07-2164/</link>
      <pubDate>Fri, 07 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-06-07-2164/</guid>
      <description>https://www.acmicpc.net/problem/2164
풀이:  카드의 갯수가 2 ^ i 개일 경우 남게 되는 카드의 번호는 2 ^ i 이다. 카드의 갯수가 (2 ^ i) + n 개 일 경우 남게 되는 카드의 번호는 2 * n 이다.  코드: 사용언어 : Python 3
n,s=int(input()),1while s&amp;lt;n:s*=2print(s if s==n else 2*n-s)</description>
    </item>
    
    <item>
      <title>[백준]12015 가장 긴 증가하는 부분 수열 2</title>
      <link>https://jyukki97.github.io/blog/2019-06-06-12015/</link>
      <pubDate>Thu, 06 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-06-06-12015/</guid>
      <description>https://www.acmicpc.net/problem/12015
풀이:  https://jyukki97.github.io/2352/ 와 같은 문제이므로 참고  코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std;vector&amp;lt;int&amp;gt;d;int main(void) {int n, s, l;cin &amp;gt;&amp;gt; n;while (n--) {cin &amp;gt;&amp;gt; s;l = lower_bound(d.begin(), d.end(), s) - d.begin();if (l == d.size())d.push_back(s);elsed[l] = s;}cout &amp;lt;&amp;lt; d.size() &amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
    <item>
      <title>[백준]1365 꼬인 전깃줄</title>
      <link>https://jyukki97.github.io/blog/2019-06-05-1365/</link>
      <pubDate>Wed, 05 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-06-05-1365/</guid>
      <description>https://www.acmicpc.net/problem/1365
풀이:  https://jyukki97.github.io/2352/ 와 같은 문제이므로 참고  코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std;vector&amp;lt;int&amp;gt;d;int main(void) {int n, s, l;cin &amp;gt;&amp;gt; n;for (int i = 0; i &amp;lt; n; i++) {cin &amp;gt;&amp;gt; s;l = lower_bound(d.begin(), d.end(), s) - d.begin();if (l == d.size())d.push_back(s);elsed[l] = s;}cout &amp;lt;&amp;lt; n - d.size() &amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
    <item>
      <title>[백준]2352 반도체 설계</title>
      <link>https://jyukki97.github.io/blog/2019-06-04-2352/</link>
      <pubDate>Tue, 04 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-06-04-2352/</guid>
      <description>https://www.acmicpc.net/problem/2352
풀이:  맨 처음 값부터 하나 하나 입력받는다. 입력받은 값이 벡터 안에 있는 값들 보다 크다면 벡터에 맨 뒤에 넣는다. 벡터의 처음부터 검색했을 때, 입력받은 값보다 큰 값이 있다면, 그 값과 교체한다. 벡터의 원소 갯수를 출력한다. 일반적으로 for문을 두개 쓴 O(n^2)의 코드는 시간초과가 나므로 주의하자  코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std;vector&amp;lt;int&amp;gt;d;int main(void) {int n, s, l;cin &amp;gt;&amp;gt; n;while(n--) {cin &amp;gt;&amp;gt; s;l = lower_bound(d.</description>
    </item>
    
    <item>
      <title>[백준]1495 기타리스트</title>
      <link>https://jyukki97.github.io/blog/2019-06-02-1495/</link>
      <pubDate>Sun, 02 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-06-02-1495/</guid>
      <description>https://www.acmicpc.net/problem/1495
풀이:  dp[a][b]를 a 번째 곡을 연주 할 때, b 볼륨으로 연주 할 수 있는가? 라고 하자. dp[0][S]는 0 번째 곡을 연주 할 때, S 볼륨으로 연주할 수 있으므로(시작지점) 1을 할당한다. 0번째 곡을 연주할 때, S볼륨으로 연주가 가능하다면, 1번째 곡을 연주할 때, S+s[1] or S-s[1] 볼륨도 연주 가능하다(0&amp;lt;=볼륨&amp;lt;=m 일때) 즉, dp[i][t + s[i]] = dp[i - 1][t] or dp[i][t - s[i]] = dp[i - 1][t] 마지막에 dp[N]값을 모두 순환하며, 가장 높은 값을 출력하고, 가능한 볼륨이 없다면 -1을 출력한다.</description>
    </item>
    
    <item>
      <title>[백준]4781 사탕 가게</title>
      <link>https://jyukki97.github.io/blog/2019-05-30-4781/</link>
      <pubDate>Thu, 30 May 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-05-30-4781/</guid>
      <description>https://www.acmicpc.net/problem/4781
풀이:  dp[a]를 a원으로 구매할 수 있는 가장 높은 칼로리라고 한다. 사탕의 칼로리를 s, 가격을 d라고 했을 때, 현제 a원으로 구매할 수 있는 가장 높은 칼로리와 a-d원 으로 구매할 수 있는 가장높을칼로리 + s 를 비교하여 높은 값으로 교체한다. 즉, dp[t] = max(dp[t], dp[t - d] + s) 를 반복하여 do[m]값을 구한다.  코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;double M1, d1;int N, M, s, d, dp[10002];int main(void) {while (1) {memset(dp, 0, sizeof(dp));cin &amp;gt;&amp;gt; N &amp;gt;&amp;gt; M1;if (N == 0)break;M = M1 * 100;for (int i = 0; i &amp;lt; N; i++) {cin &amp;gt;&amp;gt; s &amp;gt;&amp;gt; d1;d = d1 * 100;for (int t = d; t &amp;lt;= M; t++) dp[t] = max(dp[t], dp[t - d] + s);}cout &amp;lt;&amp;lt; dp[M] &amp;lt;&amp;lt; endl;}return 0;}</description>
    </item>
    
    <item>
      <title>[백준]2662 기업 투자</title>
      <link>https://jyukki97.github.io/blog/2019-05-29-2662/</link>
      <pubDate>Wed, 29 May 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-05-29-2662/</guid>
      <description>https://www.acmicpc.net/problem/2662
풀이:  dp[a][b]를 남은 금액이 a원 일 때, b번째 기업에 투자해서 얻을 수 있는 최대 이익이라고 하자. 첫번째 기업에 0원을 투자하는 것 부터 M번째 기업에 N원을 투자하는 것 까지 반복하여 최대 이익금을 구한다. 최대 이익금일 때 각 기업에 얼마를 투자했는지 구한 후 출력한다. 시간초과가 나기 쉬우므로 메모이제이션을 한다.  코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;cstring&amp;gt;using namespace std;int N, M, s[302][22], dp[302][22], x[302][22];int q(int a, int c) {if (c &amp;gt; M)return 0;int &amp;amp;m = dp[a][c];if (m !</description>
    </item>
    
    <item>
      <title>[백준]1937 욕심쟁이 판다</title>
      <link>https://jyukki97.github.io/blog/2019-05-28-1937/</link>
      <pubDate>Tue, 28 May 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-05-28-1937/</guid>
      <description>https://www.acmicpc.net/problem/1937
풀이:  k[a][b]를 (a , b)지점에서 시작한 판다가 살아남은 최대 일수라고 한다. (a, b) 주변 십자가 방향 지점( (1,0), (-1, 0), (0, 1), (0, -1)) 에서 대나무의 양이 (a, b) 보다 낮다면 그 지점에 최대 일수에서 +1 한 값이 k[a][b] 값이 된다. 높은 값에서 낮은값으로 찾아가면서 최대 일수를 구한다. 시간초과가 날 수 있으므로 메모이제이션을 통해 시행횟수를 제한해준다.  코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;int n, s[510][510], k[510][510];int dx[] = { 1,0,0,-1 };int dy[] = { 0,1,-1,0 };int panda(int a, int b){for (int y = 0; y &amp;lt; 4; y++)if (a + dy[y] &amp;gt;= 0 &amp;amp;&amp;amp; a + dy[y] &amp;lt; n &amp;amp;&amp;amp; b + dx[y] &amp;gt;= 0 &amp;amp;&amp;amp; b + dx[y] &amp;lt; n)if (s[a][b] &amp;lt; s[a + dy[y]][b + dx[y]]) {if(k[a + dy[y]][b + dx[y]] == 1)k[a][b] = max(k[a][b], panda(a + dy[y], b + dx[y]) + 1);elsek[a][b] = max(k[a][b], k[a + dy[y]][b + dx[y]] + 1);}return k[a][b];}int main(void) {cin &amp;gt;&amp;gt; n;int m = 1;fill(&amp;amp;k[0][0], &amp;amp;k[n][n], 1);for (int i = 0; i &amp;lt; n; i++)for (int t = 0; t &amp;lt; n; t++)cin &amp;gt;&amp;gt; s[i][t];for (int i = 0; i &amp;lt; n; i++)for (int t = 0; t &amp;lt; n; t++)m = max(m, panda(i, t));cout &amp;lt;&amp;lt; m &amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
    <item>
      <title>[백준]5069 미로에 갇힌 상근</title>
      <link>https://jyukki97.github.io/blog/2019-05-27-5069/</link>
      <pubDate>Mon, 27 May 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-05-27-5069/</guid>
      <description>https://www.acmicpc.net/problem/5069
풀이:  s[n][t][y]를 n번 이동해서 (t, y)인 방으로 다시 돌아오는 경우의 수라고 한다. 처음 상근이가 있는 방을 (10, 10)이라고 한다(n의 최대 수가 14 이므로 10칸을 넘어가지 않기 때문에) s[n][10][10] 은 n번 이동해서 상근이가 있는 방으로 돌아와야하므로 상근이의 근처에 있는 모든 n-1번 이동하여 돌아오는 경우의 수들의 합과 같다. 즉 s[n][10][10] = s[n-1][10][11] + s[n-1][10][9] + s[n-1][11][11] + s[n-1][11][10] + s[n-1][9][9] + s[n-1][9][10]  코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;using namespace std;int s[15][21][21];int dy[] = { 0,0,1,1,-1,-1 };int dx[] = { 1,-1,1,0,-1,0 };int main(void) {int T, a;cin &amp;gt;&amp;gt; T;s[0][10][10] = 1;for (int i = 1; i &amp;lt; 15; i++)for (int t = 1; t &amp;lt; 21; t++)for (int y = 1; y &amp;lt; 21; y++)for (int u = 0; u &amp;lt; 6; u++)if (t + dx[u] &amp;gt; 0 &amp;amp;&amp;amp; t + dx[u] &amp;lt; 21 &amp;amp;&amp;amp; y + dy[u] &amp;gt; 0 &amp;amp;&amp;amp; y + dy[u] &amp;lt; 21)s[i][t][y] += s[i - 1][t + dx[u]][y + dy[u]];while (T--) {cin &amp;gt;&amp;gt; a;cout &amp;lt;&amp;lt; s[a][10][10] &amp;lt;&amp;lt; endl;}return 0;}</description>
    </item>
    
    <item>
      <title>[백준]1351 무한 수열</title>
      <link>https://jyukki97.github.io/blog/2019-03-29-1351/</link>
      <pubDate>Fri, 29 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-03-29-1351/</guid>
      <description>https://www.acmicpc.net/problem/1351
풀이:  N번째 수열부터 차례대로 찾아나간다. N번째 수열이 map 에 존재한다면 그대로 리턴, 없다면 N = a/b + a/c 로 돌아가서 찾기 N이 0이라면 1을 리턴 각각의 값이 매우 크므로 long long 사용 실패 코드 예시처럼 map을 쓰지않고 리턴을 할 경우 같은 수열이 여러번 중복되어 계산되기 때문에 시간초과가 날 수 있다.  코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;map&amp;gt;using namespace std;long long a, b, c;map&amp;lt;long long, long long&amp;gt; n;long long infi(long long q) {if (q == 0)return 1;if (n.</description>
    </item>
    
    <item>
      <title>[백준]1712 손익분기점</title>
      <link>https://jyukki97.github.io/blog/2018-03-16-1712/</link>
      <pubDate>Fri, 16 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2018-03-16-1712/</guid>
      <description>https://www.acmicpc.net/problem/1712
풀이:  고정비용을 노트북 가격에서 생산비인 가변 비용을 뺀 값으로 나눈 몫을 출력한다. 만약 가변비용이 노트북의 가격보다 높다면 -1을 출력한다.  코드: 사용언어 : Python 3
a,b,c=map(int,input().split())if b&amp;gt;=c:print(&amp;#34;-1&amp;#34;)else:print(a//(c-b)+1)</description>
    </item>
    
    <item>
      <title>[백준]1919 애너그램 만들기</title>
      <link>https://jyukki97.github.io/blog/2018-02-05-1919/</link>
      <pubDate>Mon, 05 Feb 2018 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2018-02-05-1919/</guid>
      <description>https://www.acmicpc.net/problem/1919
풀이:  a~z까지의 알파벳 중 문자열에 나온 개수를 확인 후 그 차이를 출력한다.  코드: 사용언어 : Python 3
a,b=input(),input()print(sum(abs(b.count(chr(i))-a.count(chr(i)))for i in range(97,123)))</description>
    </item>
    
    <item>
      <title>[백준]2338 긴자리 계산</title>
      <link>https://jyukki97.github.io/blog/2018-02-04-2338/</link>
      <pubDate>Sun, 04 Feb 2018 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2018-02-04-2338/</guid>
      <description>https://www.acmicpc.net/problem/2338
풀이:  두 수를 입력받는다. 두 수를 더한값, 뺀값, 곱한값을 각각 출력한다.  코드: 사용언어 : Python 3
a,b=int(input()),int(input())print(a+b,a-b,a*b,sep=&amp;#39;\n&amp;#39;)</description>
    </item>
    
    <item>
      <title>[백준]2154 수 이어 쓰기 3</title>
      <link>https://jyukki97.github.io/blog/2018-02-03-2154/</link>
      <pubDate>Sat, 03 Feb 2018 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2018-02-03-2154/</guid>
      <description>https://www.acmicpc.net/problem/2154
풀이:  전체 수를 string타입으로 나열한다. 그 숫자 중 제시된 숫자 n이 맨 처음으로 나오는 인덱스를 출력한다.  코드: 사용언어 : Python 3
n,s=int(input()),&amp;#34;&amp;#34;for i in range(1,n+1):s+=str(i)print(s.find(str(n))+1)</description>
    </item>
    
    <item>
      <title>[백준]2624 동전 바꿔주기</title>
      <link>https://jyukki97.github.io/blog/2018-01-11-2624/</link>
      <pubDate>Thu, 11 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2018-01-11-2624/</guid>
      <description>https://www.acmicpc.net/problem/2624
풀이:   coin[i] : i원의 지폐를 동전으로 교환할 수 있는 경우의 수
  지폐의 가격 + 동전의 가격 * 동전의 개수를 계속 쌓아간다.
  코드: #include &amp;lt;iostream&amp;gt;using namespace std;pair&amp;lt;int, int&amp;gt; a[101];int coin[10001] = { 0 };int main(void) {int T, k, n, m;cin &amp;gt;&amp;gt; T &amp;gt;&amp;gt; k;for (int i = 0; i &amp;lt; k; i++) {cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;a[i] = make_pair(n, m);}coin[0] = 1;for (int i = 0; i &amp;lt; k; i++)for (int t = T; t &amp;gt; 0 ; t--)for (int y = 1; y &amp;lt;= a[i].</description>
    </item>
    
    <item>
      <title>[백준]3908 서로 다른 소수의 합</title>
      <link>https://jyukki97.github.io/blog/2018-01-10-3908/</link>
      <pubDate>Wed, 10 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2018-01-10-3908/</guid>
      <description>https://www.acmicpc.net/problem/3908
풀이:  소수를 찾는다. 소수를 하나씩 추가해가면서 a[n][k]를 찾는다. a[n][k] : 양의 정수 n을 서로 다른 k개의 소수의 합으로 나타낼 수 있는 최대의 경우의 수  코드: #include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;math.h&amp;gt;#include &amp;lt;string.h&amp;gt;using namespace std;int	T, n, k, a[1122][16] = { 0 };bool isprime[1122];vector&amp;lt;int&amp;gt; b;int prime() {memset(isprime, 1, sizeof(isprime));isprime[0] = isprime[1] = false;for (int i = 2; i &amp;lt; sqrt(1122); i++)if(isprime[i])for (int t = i * i; t &amp;lt; 1122; t += i)isprime[t] = false;for (int i = 2; i &amp;lt; 1122; i++) if (isprime[i]) b.</description>
    </item>
    
    <item>
      <title>[백준]2748 피보나치 수 2</title>
      <link>https://jyukki97.github.io/blog/2018-01-05-2748/</link>
      <pubDate>Fri, 05 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2018-01-05-2748/</guid>
      <description>https://www.acmicpc.net/problem/2748
풀이:  a[i % 3] : n번째 피보나치 수 a[i % 3] = a[(i - 1) % 3] + a[(i - 2) % 3];  코드: #include &amp;lt;iostream&amp;gt;using namespace std;long long a[3] = { 0,1 }, n;int main() {cin &amp;gt;&amp;gt; n;for (int i = 2; i &amp;lt;= n; i++)a[i % 3] = a[(i - 1) % 3] + a[(i - 2) % 3];cout &amp;lt;&amp;lt; a[n % 3] &amp;lt;&amp;lt; endl;}</description>
    </item>
    
    <item>
      <title>[백준]11568 민균이의 계략</title>
      <link>https://jyukki97.github.io/blog/2018-01-02-11568/</link>
      <pubDate>Tue, 02 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2018-01-02-11568/</guid>
      <description>https://www.acmicpc.net/problem/11568
풀이:  11053 가장 긴 증가하는 부분 수열 의 문제와 같으므로 링크를 참고  코드: #include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;long long a[1001] = { 0 }, b[1001];int main(void) {long long n, temp;cin &amp;gt;&amp;gt; n;for (int i = 0; i &amp;lt; n; i++) {cin &amp;gt;&amp;gt; a[i];b[i] = 1;}for (int i = 0; i &amp;lt; n; i++) {temp = 0;for (int t = 0; t &amp;lt;= i; t++) {if (a[i] &amp;gt; a[i - t])temp = max(b[i - t], temp);}b[i] += temp;}for (int i = 0; i &amp;lt; n; i++) {temp = max(b[i], temp);}cout &amp;lt;&amp;lt; temp &amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
    <item>
      <title>[백준]2228 구간 나누기</title>
      <link>https://jyukki97.github.io/blog/2017-12-26-2228/</link>
      <pubDate>Tue, 26 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-12-26-2228/</guid>
      <description>https://www.acmicpc.net/problem/2228
풀이:   dp[n][m] : n개의 숫자를 m개의 구간으로 나눈 최대 합
  dp[i][t] = dp[i - 1][t] : i번째 수를 포함하지 않는 경우
  dp[i][t] = max(dp[i][t], (t == 1 ? 0 : dp[y - 1][t - 1]) + a[i] - a[y]) : i번째 수를 포함하는 경우 i번째를 포함하므로 구간을 하나 빼고 그것에 i번째 수를 포함하는 구간을 더한다.
  max함수를 쓰므로 dp 초기화를 잘해줘야한다.
  코드: #include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;int a[101] = { 0 }, dp[101][52] = { 0 };int main(void) {int n, m, temp;cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;fill(dp[0] + 1, dp[0] + m + 1, -2147483646);for (int i = 1; i &amp;lt;= n; i++) {cin &amp;gt;&amp;gt; temp;a[i] = a[i - 1] + temp;for (int t = 1; t &amp;lt;= m; t++) {dp[i][t] = dp[i - 1][t];for (int y = i - 1; y / 2 &amp;gt;= t - 1; y--) {dp[i][t] = max(dp[i][t], (t == 1 ?</description>
    </item>
    
    <item>
      <title>[백준]7579 앱</title>
      <link>https://jyukki97.github.io/blog/2017-12-21-7579/</link>
      <pubDate>Thu, 21 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-12-21-7579/</guid>
      <description>https://www.acmicpc.net/problem/7579
풀이:  처음 문제를 풀때는 DP[메모리]로 풀었더니 시간초과가 났다. 그래서 DP[c]로 풀게되었다. 가격이 0이고 메모리가 0인 지점부터 하나하나 더해가면서 만들어나간다. 그 후 가격이 낮은 곳부터 검사하면서 메모리가 M값보다 높아지면 출력한다. iter = a.end(); 를 처음에 iter = a.begin(); 으로 했을 때 출력이 잘못되는 것을 발견하였다. 아마 작은 값부터 더해가는 과정에 겹치는 값이 생겼을 것이라고 본다.  코드: #include &amp;lt;iostream&amp;gt;#include &amp;lt;map&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;map&amp;lt;int, int&amp;gt; a;int k[101], c[101];int main(void) {int n, m, size, temp;cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;a[0] = 0;for (int i = 0; i &amp;lt; n; i++)cin &amp;gt;&amp;gt; k[i];for (int i = 0; i &amp;lt; n; i++)cin &amp;gt;&amp;gt; c[i];map&amp;lt;int, int&amp;gt;::iterator iter;for (int i = 0; i &amp;lt; n; i++) {size = a.</description>
    </item>
    
    <item>
      <title>[백준]1038 감소하는 수</title>
      <link>https://jyukki97.github.io/blog/2017-12-20-1038/</link>
      <pubDate>Wed, 20 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-12-20-1038/</guid>
      <description>https://www.acmicpc.net/problem/1038
풀이:  10, 321 등 감소하는 수를 찾는 문제 감소하는 수를 하나씩 만들어 가면서 카운트를 증가시킨다. 카운트의 값이 제시된 N값과 일치하면 출력한다. 제시된 N값이 9876543210의 위치인 1022 보다 크다면 -1을 출력한다.  코드: #include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std;vector&amp;lt;int&amp;gt; a;int main(void) {int n;int cnt = 11;cin &amp;gt;&amp;gt; n;if (n &amp;lt; 11) {cout &amp;lt;&amp;lt; n &amp;lt;&amp;lt; endl;}else if (n &amp;gt; 1022)cout &amp;lt;&amp;lt; &amp;#34;-1&amp;#34; &amp;lt;&amp;lt; endl;else {a.</description>
    </item>
    
    <item>
      <title>[백준]2629 양팔저울</title>
      <link>https://jyukki97.github.io/blog/2017-12-19-2629/</link>
      <pubDate>Tue, 19 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-12-19-2629/</guid>
      <description>https://www.acmicpc.net/problem/2629
풀이:  양팔저울에 추를 매달아 구할 수 있는 무게를 알아내는 문제 양팔저울에 한 곳에 놓았을 때, 양쪽에 서로 따로 놓았을 때 두 가지의 경우가 있다. 이 때 같이놓으면 + 따로 놓은것은 -로 놓고 배열에 저장한다. 구슬의 무게에 맞는 배열의 값이 1이면 구할 수 있고, 1이 아닌경우 구할 수 없는 것으로 취급한다.  코드: #include &amp;lt;iostream&amp;gt;#include &amp;lt;map&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std;map&amp;lt;int, int&amp;gt; a;vector&amp;lt;int&amp;gt; b;int main(void) {int n, temp, k, size;cin &amp;gt;&amp;gt; n;for (int i = 0; i &amp;lt; n; i++) {cin &amp;gt;&amp;gt; temp;map&amp;lt;int, int&amp;gt;::iterator iter;size = a.</description>
    </item>
    
    <item>
      <title>[백준]2698 인접한 비트의 개수</title>
      <link>https://jyukki97.github.io/blog/2017-12-18-2698/</link>
      <pubDate>Mon, 18 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-12-18-2698/</guid>
      <description>https://www.acmicpc.net/problem/2698
풀이:  a[n][k][0] : 크기가 n이고 인접비트의 수가 k이며, 끝에 비트가 0인 수 a[n][k][1] : 크기가 n이고 인접비트의 수가 k이며, 끝에 비트가 1인 수 a[n][k][0] = a[n - 1][k][0] + a[n - 1][k][1] a[n][k][1] = a[n - 1][k][0] + a[n - 1][k - 1][1]  코드: #include &amp;lt;iostream&amp;gt;using namespace std;int a[102][102][2] = { 0 };int main(void) {int T, n, k;int cnt = 2;cin &amp;gt;&amp;gt; T;a[1][0][1] = 1; a[1][0][0] = 1;for (int i = 0; i &amp;lt; T; i++) {cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; k;for (int t = cnt; t &amp;lt; n + 1; t++) {for (int y = 0; y &amp;lt; t; y++) {a[t][y][0] = a[t - 1][y][0] + a[t - 1][y][1];a[t][y][1] = a[t - 1][y][0] + a[t - 1][y - 1][1];}}cout &amp;lt;&amp;lt; a[n][k][0] + a[n][k][1] &amp;lt;&amp;lt; endl;cnt = n;}return 0;}</description>
    </item>
    
    <item>
      <title>[백준]1793 타일링</title>
      <link>https://jyukki97.github.io/blog/2017-12-17-1793/</link>
      <pubDate>Sun, 17 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-12-17-1793/</guid>
      <description>https://www.acmicpc.net/problem/1793
풀이: 11727 2XN 타일링2
 DP는 링크와 같으므로 링크를 참고 링크의 코드와 다르게 int 보다 큰 값을 출력해야하므로 어려움이 있다. vector를 사용하여 int를 한자리수 씩 계산하는 방법으로 풀었다. 만약 자릿수의 값이 10보다 커지면 다음 자릿수의 값을 그만큼 올려주는 식으로 풀었다.  코드: #include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std;vector&amp;lt;int&amp;gt; a[251];int main(void) {int	n, temp;int cnt = 3;a[0].push_back(1);a[1].push_back(1);a[2].push_back(3);while(cin &amp;gt;&amp;gt; n){if (a[n].size() == 0) {for (int t = cnt; t &amp;lt; n + 1; t++) {int carry = 0;for (int y = 0; y &amp;lt; a[t - 2].</description>
    </item>
    
    <item>
      <title>[백준]2718 타일 채우기</title>
      <link>https://jyukki97.github.io/blog/2017-12-16-2718/</link>
      <pubDate>Sat, 16 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-12-16-2718/</guid>
      <description>https://www.acmicpc.net/problem/2718
풀이:  a[t] 는 4 x t 크기의 타일을 채울 수 있는 경우의 수 a[t] = a[t - 1] + a[t - 2] * 5 + a[t - 3] - a[t - 4];  코드: #include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;int a[30] = { 1,5,11,36 };int main(void) {int T,n,cnt;cnt = 5;cin &amp;gt;&amp;gt; T;for (int i = 0; i &amp;lt; T; i++) {cin &amp;gt;&amp;gt; n;if (a[n - 1] == 0)for (int t = cnt-1; t &amp;lt; n; t++) {a[t] = a[t - 1] + a[t - 2] * 5 + a[t - 3] - a[t - 4];}cout &amp;lt;&amp;lt; a[n - 1] &amp;lt;&amp;lt; endl;cnt = max(cnt, n);}return 0;}</description>
    </item>
    
    <item>
      <title>[백준]11722 가장 긴 감소하는 부분 수열</title>
      <link>https://jyukki97.github.io/blog/2017-12-15-11722/</link>
      <pubDate>Fri, 15 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-12-15-11722/</guid>
      <description>https://www.acmicpc.net/problem/11722
풀이:  11053 가장 긴 증가하는 부분 수열의 문제와 똑같으므로 링크를 참고  코드: #include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;int main(void) {int n, temp;cin &amp;gt;&amp;gt; n;int a[1001] = { 0 };int b[1001];for (int i = 0; i &amp;lt; n; i++) {cin &amp;gt;&amp;gt; a[i];b[i] = 1;}for (int i = 0; i &amp;lt; n; i++) {temp = 0;for (int t = 0; t &amp;lt;= i; t++) {if (a[i] &amp;lt; a[i - t])temp = max(b[i - t], temp);}b[i] += temp;}for (int i = 0; i &amp;lt; n; i++) {temp = max(b[i], temp);}cout &amp;lt;&amp;lt; temp &amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
    <item>
      <title>[백준]4883 삼각 그래프</title>
      <link>https://jyukki97.github.io/blog/2017-12-14-4883/</link>
      <pubDate>Thu, 14 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-12-14-4883/</guid>
      <description>https://www.acmicpc.net/problem/4883
풀이:  N X 3 행렬에서 맨 위 중앙에서 출발하여 맨 아래 중앙까지 가는 경로 중 가장 최소 비용을 찾는 문제 각 i행의 1,2,3번째 열의 각각 최소비용은 i-1 번째 행에서의 최소 비용을 더해준 값이다. 맨 마지막 행의 2번째 열을 출력한다. 0이 출력되면 끝나므로 if문으로 while 문을 빠져나갈 수 있게한다. 하나의 테스트케이스마다 숫자를 출력해야하므로 count 값을 각 케이스마다 ++해준다.  코드: #include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;int a[100005][3], b[100005][3];int main(void) {int count = 1;while (true) {int n, temp, temp2;cin &amp;gt;&amp;gt; n;if (n == 0)break;for (int i = 0; i &amp;lt; n; i++) {for (int t = 0; t &amp;lt; 3; t++) {cin &amp;gt;&amp;gt; a[i][t];b[i][t] = a[i][t];}}b[0][2] += b[0][1];b[1][0] += b[0][1];b[1][1] += min(min(b[0][1],b[1][0]), b[0][2]);b[1][2] += min(min(b[1][1], b[0][1]), b[0][2]);for (int i = 2; i &amp;lt; n; i++) {for (int t = 0; t &amp;lt; 3; t++) {if (t == 0)b[i][t] += min(b[i - 1][t], b[i - 1][t + 1]);else if (t == 1)b[i][t] += min(min(b[i - 1][t], b[i - 1][t + 1]), min(b[i - 1][t - 1], b[i][t - 1]));else if (t == 2)b[i][t] += min(min(b[i - 1][t - 1], b[i - 1][t]), b[i][t - 1]);}}cout &amp;lt;&amp;lt; count &amp;lt;&amp;lt; &amp;#34;.</description>
    </item>
    
    <item>
      <title>[백준]10164 격자상의 경로</title>
      <link>https://jyukki97.github.io/blog/2017-12-13-10164/</link>
      <pubDate>Wed, 13 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-12-13-10164/</guid>
      <description>https://www.acmicpc.net/problem/10164
풀이:  N X M 행렬에서 K번째 수를 꼭 지나치면서 오른쪽 맨 아래까지 가는 최대 경우의 수 1~K 까지 가는 경우의 수 * K~M*N 까지 가는 경우의 수 DP[i][t] i행 t열로 갈 수 있는 경우의 수 DP[i][t] = DP[i-1][t] + DP[i][t-1]  코드: #include &amp;lt;iostream&amp;gt;using namespace std;int a[16][16] = { 0 };int b[16][16] = { 0 };int main(void) {int n, m, k, q, w, e, r;cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m &amp;gt;&amp;gt; k;q = k / m + 1;w = k%m;if (k !</description>
    </item>
    
    <item>
      <title>[백준]11053 가장 긴 증가하는 부분 수열</title>
      <link>https://jyukki97.github.io/blog/2017-12-12-11053/</link>
      <pubDate>Tue, 12 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-12-12-11053/</guid>
      <description>https://www.acmicpc.net/problem/11053
풀이:  1965 상자넣기의 문제와 똑같으므로 링크를 참고  코드: #include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;int main(void) {int n, temp;cin &amp;gt;&amp;gt; n;int a[1001] = { 0 };int b[1001];for (int i = 0; i &amp;lt; n; i++) {cin &amp;gt;&amp;gt; a[i];b[i] = 1;}for (int i = 0; i &amp;lt; n; i++) {temp = 0;for (int t = 0; t &amp;lt;= i; t++) {if (a[i] &amp;gt; a[i - t])temp = max(b[i - t], temp);}b[i] += temp;}for (int i = 0; i &amp;lt; n; i++) {temp = max(b[i], temp);}cout &amp;lt;&amp;lt; temp &amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
    <item>
      <title>[백준]6603 로또</title>
      <link>https://jyukki97.github.io/blog/2017-12-12-6603/</link>
      <pubDate>Tue, 12 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-12-12-6603/</guid>
      <description>https://www.acmicpc.net/problem/6603
풀이:  N 개의 로또 번호 중 6개를 선택하여 로또를 만드는 프로그램 6개의 번호를 사전순으로 하나씩 선택하면서 출력한다. 출력 사이사이에 빈칸을 만들어주고, 하나의 테스트 케이스가 끝나면 빈 줄을 하나 출력한다. 0이 출력되면 끝나므로 while 문 안에 if문으로 제한을 넣어준다.  코드: #include &amp;lt;iostream&amp;gt;using namespace std;int a[13];int main(void) {while (true) {int n;cin &amp;gt;&amp;gt; n;if (n == 0)break;for (int i = 0; i &amp;lt; n; i++) {cin &amp;gt;&amp;gt; a[i];}int b[6] = { 0,1,2,3,4,5 };while (true) {cout &amp;lt;&amp;lt; a[b[0]] &amp;lt;&amp;lt; &amp;#34;&amp;#34; &amp;lt;&amp;lt; a[b[1]] &amp;lt;&amp;lt; &amp;#34;&amp;#34; &amp;lt;&amp;lt; a[b[2]] &amp;lt;&amp;lt; &amp;#34;&amp;#34; &amp;lt;&amp;lt; a[b[3]] &amp;lt;&amp;lt; &amp;#34;&amp;#34; &amp;lt;&amp;lt; a[b[4]] &amp;lt;&amp;lt; &amp;#34;&amp;#34; &amp;lt;&amp;lt; a[b[5]] &amp;lt;&amp;lt; endl;if (b[0] &amp;gt;= n - 6)break;else if (b[1] &amp;gt;= n - 5) {b[0]++;for (int i = 0; i &amp;lt; 5; i++) {b[i + 1] = b[i] + 1;}}else if (b[2] &amp;gt;= n - 4) {b[1]++;for (int i = 1; i &amp;lt; 5; i++) {b[i + 1] = b[i] + 1;}}else if (b[3] &amp;gt;= n - 3) {b[2]++;for (int i = 2; i &amp;lt; 5; i++) {b[i + 1] = b[i] + 1;}}else if (b[4] &amp;gt;= n - 2) {b[3]++;for (int i = 3; i &amp;lt; 5; i++) {b[i + 1] = b[i] + 1;}}else if (b[5] &amp;gt;= n - 1) {b[4]++;b[5] = b[4] + 1;}elseb[5]++;}cout &amp;lt;&amp;lt; endl;}return 0;}</description>
    </item>
    
    <item>
      <title>[백준]11060 점프 점프</title>
      <link>https://jyukki97.github.io/blog/2017-12-10-11060/</link>
      <pubDate>Sun, 10 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-12-10-11060/</guid>
      <description>https://www.acmicpc.net/problem/11060
풀이:  cnt[i] 는 i번째 에서의 최소 가짓수 cnt를 모두 최댓값으로 채운 후 a[i] 이하의 값으로 점프할 때 마다 cnt[i + t] 값을 min(cnt[i + t], cnt[i] + 1) 로 해줌으로써 최소 가짓수를 찾는다 만약 도착점의 값이 처음 채운 1001과 같다면 갈 수 없는 경우이므로 -1을 출력한다.  코드: #include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;int a[1001], cnt[1001];int main(void) {int n;cin &amp;gt;&amp;gt; n;fill_n(cnt, n, 1001);for (int i = 0; i &amp;lt; n; i++) {cin &amp;gt;&amp;gt; a[i];}cnt[0] = 0;for (int i = 0; i &amp;lt; n; i++) {for (int t = 1; t &amp;lt;= a[i]; t++) {cnt[i + t] = min(cnt[i + t], cnt[i] + 1);}}if (cnt[n - 1] == 1001)cout &amp;lt;&amp;lt; &amp;#34;-1&amp;#34; &amp;lt;&amp;lt; endl;elsecout &amp;lt;&amp;lt; cnt[n - 1] &amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
    <item>
      <title>[백준]9084 동전</title>
      <link>https://jyukki97.github.io/blog/2017-12-09-9084/</link>
      <pubDate>Sat, 09 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-12-09-9084/</guid>
      <description>https://www.acmicpc.net/problem/9084
풀이:  첫번째 동전부터 경우의 수를 더해감.  코드: #include &amp;lt;iostream&amp;gt;using namespace std;int coin[10001] = { 0 };int main(void){int n, a, num;cin &amp;gt;&amp;gt; n;for (int t = 0; t &amp;lt; n; t++) {fill_n(coin, 10000, 0);cin &amp;gt;&amp;gt; a;int *q = new int[a];for (int i = 0; i &amp;lt; a; i++) {cin &amp;gt;&amp;gt; q[i];}cin &amp;gt;&amp;gt; num;for (int i = 0; i &amp;lt;= num; i++) {if (i%q[0] == 0)coin[i]++;}for (int i = 1; i &amp;lt; a; i++) {for (int t = q[i]; t &amp;lt;= num; t++) {coin[t] += coin[t - q[i]];}}cout &amp;lt;&amp;lt; coin[num] &amp;lt;&amp;lt; endl;}return 0;}</description>
    </item>
    
    <item>
      <title>[백준]1904 01타일</title>
      <link>https://jyukki97.github.io/blog/2017-12-08-1904/</link>
      <pubDate>Fri, 08 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-12-08-1904/</guid>
      <description>https://www.acmicpc.net/problem/1904
풀이:  a[i] 는 길이가 i인 모든 이진수열의 개수 a[i] = a[i - 1] + a[i - 2] 주어진 조건에 맞게 15746 으로 나눈 나머지를 출력  코드: #include &amp;lt;iostream&amp;gt;using namespace std;int a[1000001] = { 1,2 };int main(void) {int n;cin &amp;gt;&amp;gt; n;for (int i = 2; i &amp;lt; n; i++) {a[i] = (a[i - 1] % 15746 + a[i - 2] % 15746) % 15746;}cout &amp;lt;&amp;lt; a[n - 1] &amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
    <item>
      <title>[백준]11055 가장 큰 증가 부분 수열</title>
      <link>https://jyukki97.github.io/blog/2017-12-07-11055/</link>
      <pubDate>Thu, 07 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-12-07-11055/</guid>
      <description>https://www.acmicpc.net/problem/11055
풀이:  배열의 이전을 돌며 가장 합이 큰 값을 더함  코드: #include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;int a[1002], maxA[1002];int main(void) {int n;cin &amp;gt;&amp;gt; n;int maximum = 0;for (int i = 0; i &amp;lt; n; i++) {cin &amp;gt;&amp;gt; a[i];maxA[i] = a[i];}for (int i = 0; i &amp;lt; n; i++) {int temp = 0;for (int t = i-1; t &amp;gt;= 0; t--) {if (a[t] &amp;lt; a[i]) {temp = max(temp, maxA[t]);}}maxA[i] += temp;maximum = max(maximum, maxA[i]);}cout &amp;lt;&amp;lt; maximum &amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
    <item>
      <title>[백준]2957 이진 탐색 트리</title>
      <link>https://jyukki97.github.io/blog/2017-12-05-2957/</link>
      <pubDate>Tue, 05 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-12-05-2957/</guid>
      <description>https://www.acmicpc.net/problem/2957
풀이:  트리의 루트에서 부터 왼쪽 오른쪽에 삽입할때 마다 높이를 1씩 증가시켜 준다. cin , cout을 사용할 경우 시간초과가 나므로 scanf, printf 를 사용하도록 하자 출력의 사이즈가 int 사이즈를 넘어가므로 long long 을 사용하자  코드: #include &amp;lt;iostream&amp;gt;#include &amp;lt;map&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;stdio.h&amp;gt;using namespace std;int main(void) {int n, num;cin &amp;gt;&amp;gt; n;map&amp;lt;int, long long int&amp;gt; a;a[300001] = -1;a[0] = -1;long long temp = 0;for (int i = 0; i &amp;lt; n; i++) {scanf_s(&amp;#34;%d&amp;#34;, &amp;amp;num);a[num] = max((--a.</description>
    </item>
    
    <item>
      <title>[백준]2225 합분해</title>
      <link>https://jyukki97.github.io/blog/2017-12-03-2225/</link>
      <pubDate>Sun, 03 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-12-03-2225/</guid>
      <description>https://www.acmicpc.net/problem/2225
풀이:  a[i][t] 는 0~i+1 까지 정수 t+1 개를 더하여 그 합이 i+1 이 되는 경우의 수 이다. a[i][t] = a[i-1][t] + a[i][t-1] 로 나타낼 수 있다. 이때 수의 값이 너무 커져 오버플로우가 발생할 수 있으므로 1000000000으로 나눈 나머지를 출력한다.  코드: #include &amp;lt;iostream&amp;gt;using namespace std;long long a[201][201];int main(void) {int n, k;cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; k;for (int i = 0; i &amp;lt; n; i++) {a[i][0] = 1;for (int t = 1; t &amp;lt; k; t++) {if (i == 0)a[i][t] = t + 1;elsea[i][t] = ((a[i - 1][t]) % 1000000000 + (a[i][t - 1]) % 1000000000) % 1000000000;}}cout &amp;lt;&amp;lt; a[n - 1][k - 1] &amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
    <item>
      <title>[백준]11051 이항계수2</title>
      <link>https://jyukki97.github.io/blog/2017-12-02-11051/</link>
      <pubDate>Sat, 02 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-12-02-11051/</guid>
      <description>https://www.acmicpc.net/problem/11051
풀이:  nCk 를 나타내는 함수 Comb() 를 만든다. 재귀함수의 특성상 시간초과 때문에 배열에 값을 저장해놓는다.  참고: 1010 다리놓기 코드: #include &amp;lt;iostream&amp;gt;using namespace std;long long cnt[1001][1001] = { 0 };int Comb(int n, int r) {if (r == 0 || r == n)return 1;else if (r == n - 1 || r == 1)return n;if (cnt[n - 1][r] == 0)cnt[n - 1][r] = Comb(n - 1, r);if (cnt[n - 1][r - 1] == 0)cnt[n - 1][r - 1] = Comb(n - 1, r - 1);return (cnt[n - 1][r] % 10007 + cnt[n - 1][r - 1] % 10007) % 100007;}int main(void) {int n, k;cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; k;cout &amp;lt;&amp;lt; Comb(n, k) % 10007&amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
    <item>
      <title>[백준]1890 점프</title>
      <link>https://jyukki97.github.io/blog/2017-12-02-1890/</link>
      <pubDate>Sat, 02 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-12-02-1890/</guid>
      <description>https://www.acmicpc.net/problem/1890
풀이:  cnt[[x][y] 는 x열 y행 에서의 최대 경로의 개수 시간초과를 막기위해 if (cnt[x][y] &amp;gt;= 0) 를 넣어 중복을 피함  코드: #include &amp;lt;iostream&amp;gt;using namespace std;int n, a[101][101];long long cnt[101][101];long long jump(int x, int y) {if (x == n - 1 &amp;amp;&amp;amp; y == n - 1)return 1;if (cnt[x][y] &amp;gt;= 0)return cnt[x][y];cnt[x][y] = 0;if (a[x][y] + x &amp;lt; n)cnt[x][y] += jump(a[x][y] + x, y);if (a[x][y] + y &amp;lt; n)cnt[x][y] += jump(x, a[x][y] + y);return cnt[x][y];}int main(void) {cin &amp;gt;&amp;gt; n;for (int i = 0; i &amp;lt; n; i++) {for (int t = 0; t &amp;lt; n; t++) {cin &amp;gt;&amp;gt; a[i][t];}}fill(cnt[0], cnt[100], -1);cout &amp;lt;&amp;lt; jump(0, 0) &amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
    <item>
      <title>[백준]2096 내려가기</title>
      <link>https://jyukki97.github.io/blog/2017-12-02-2096/</link>
      <pubDate>Sat, 02 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-12-02-2096/</guid>
      <description>https://www.acmicpc.net/problem/2096
풀이:  b[i][0] 은 i번째 수를 골랐을 때의 최댓값 b[i][0] 은 i번째 수를 골랐을 때의 최솟값  참고: 1149 RGB거리 코드: #include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;int a[3],c[3];int main(void) {int n,temp;cin &amp;gt;&amp;gt; n;int b[2][3] = { 0 };for (int i = 0; i &amp;lt; n; i++) {cin &amp;gt;&amp;gt; a[0] &amp;gt;&amp;gt; a[1] &amp;gt;&amp;gt; a[2];c[0] = b[0][0];c[1] = b[0][1];c[2] = b[0][2];temp = max(c[1], c[0]);b[0][0] = a[0] + temp;b[0][1] = a[1] + max(temp, c[2]);b[0][2] = a[2] + max(c[1], c[2]);c[0] = b[1][0];c[1] = b[1][1];c[2] = b[1][2];temp = min(c[1], c[0]);b[1][0] = a[0] + temp;b[1][1] = a[1] + min(temp, c[2]);b[1][2] = a[2] + min(c[1], c[2]);}temp = max(b[0][1], b[0][0]);cout &amp;lt;&amp;lt; max(temp, b[0][2]) &amp;lt;&amp;lt; &amp;#34;&amp;#34;;temp = min(b[1][1], b[1][0]);cout &amp;lt;&amp;lt; min(temp, b[1][2]) &amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
    <item>
      <title>[백준]1309 동물원</title>
      <link>https://jyukki97.github.io/blog/2017-12-01-1309/</link>
      <pubDate>Fri, 01 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-12-01-1309/</guid>
      <description>https://www.acmicpc.net/problem/1309
풀이:  a[i] 가 2 x i 칸에 채울 수 있는 배치의 최댓값이라 하자. a[i] = 2 * a[i - 1] + a[i - 2] 로 구할 수 있다.  코드: #include &amp;lt;iostream&amp;gt;using namespace std;int main(void) {int n;cin &amp;gt;&amp;gt; n;int a[100001] = { 3,7,0 };for (int i = 2; i &amp;lt; n; i++) {a[i] = (2* a[i - 1] + a[i - 2]) % 9901;}cout &amp;lt;&amp;lt; a[n - 1] % 9901 &amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
    <item>
      <title>[백준]1520 내리막 길</title>
      <link>https://jyukki97.github.io/blog/2017-12-01-1520/</link>
      <pubDate>Fri, 01 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-12-01-1520/</guid>
      <description>https://www.acmicpc.net/problem/1520
풀이:  cnt[i][t] 가 i행 t열을 골랐을 때 최대 경로의 수 이다. 왼쪽 위 부터 차례대로 방문한다. 왼쪽, 오른쪽, 위, 아래 를 모두 검사하여 지금 계단의 지점보다 낮은 지점을 찾는다. 계속 검사하면서 가다가 오른쪽 끝 즉, (n,m) 을 만나면 return 1을 해준다. 시간초과 때문에 재방문을 피하기위해 cnt의 값을 모두 -1로 바꿔놓고 0이상이면 검사를 끝내도록 하였다.  코드: #include &amp;lt;iostream&amp;gt;using namespace std;int n, m;int a[501][501];int cnt[501][501];int downhill(int q, int w) {if (q == n &amp;amp;&amp;amp; w == m)return 1;if (cnt[q][w] &amp;gt;= 0)return cnt[q][w];cnt[q][w] = 0;int x[5] = { 0, 1, 0, -1, 0 };int y[5] = { 0, 0, 1, 0, -1 };for (int i = 0; i &amp;lt; 5; i++) {if (q + x[i] &amp;gt; 0 &amp;amp;&amp;amp; q + x[i] &amp;lt;= n &amp;amp;&amp;amp; w + y[i] &amp;gt; 0 &amp;amp;&amp;amp; w + y[i] &amp;lt;= m &amp;amp;&amp;amp; a[q + x[i]][w + y[i]] &amp;lt; a[q][w]) {cnt[q][w] += downhill(q + x[i], w + y[i]);}}return cnt[q][w];}int main(void) {cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;for (int i = 1; i &amp;lt;= n; i++) {for (int t = 1; t &amp;lt;= m; t++) {cin &amp;gt;&amp;gt; a[i][t];}}fill(cnt[0],cnt[500], -1);cout &amp;lt;&amp;lt; downhill(1,1) &amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
    <item>
      <title>[백준]1965 상자넣기</title>
      <link>https://jyukki97.github.io/blog/2017-12-01-1965/</link>
      <pubDate>Fri, 01 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-12-01-1965/</guid>
      <description>https://www.acmicpc.net/problem/1965
풀이:  b[i] 가 i 번째 상자를 골랐을 때의 상자의 최대 갯수라고 하자. b[i] = b[i] + 0~i 번째 까지 중 가장 큰 값 이다.  코드: #include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;int main(void) {int n,temp;cin &amp;gt;&amp;gt; n;int a[1001] = { 0 };int b[1001];for (int i = 0; i &amp;lt; n; i++) {cin &amp;gt;&amp;gt; a[i];b[i] = 1;}for (int i = 0; i &amp;lt; n; i++) {temp = 0;for (int t = 0; t &amp;lt;= i; t++) {if (a[i] &amp;gt; a[i - t])temp = max(b[i - t], temp);}b[i] += temp;}for (int i = 0; i &amp;lt; n; i++) {temp = max(b[i], temp);}cout &amp;lt;&amp;lt; temp &amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
    <item>
      <title>[백준]2133 타일 채우기</title>
      <link>https://jyukki97.github.io/blog/2017-12-01-2133/</link>
      <pubDate>Fri, 01 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-12-01-2133/</guid>
      <description>https://www.acmicpc.net/problem/2133
풀이:  N이 홀수라면 타일을 채울 수 없으므로 언제나 0을 출력한다. 짝수일경우 i를 N/2-1 로 생각하고 a[i] = 4 * a[i - 1] - a[i - 2] 로 구한다.  코드: #include &amp;lt;iostream&amp;gt;#include &amp;lt;math.h&amp;gt;using namespace std;int main(void) {int n;long long a[30] = { 3,11,0 };cin &amp;gt;&amp;gt; n;if (n % 2 == 1)cout &amp;lt;&amp;lt; &amp;#34;0&amp;#34; &amp;lt;&amp;lt; endl;else {for (int t = 2; t &amp;lt; n/2; t++) {a[t] = 4*a[t-1] - a[t-2];}cout &amp;lt;&amp;lt; a[n/2-1] &amp;lt;&amp;lt; endl;}return 0;}</description>
    </item>
    
    <item>
      <title>[백준]6359 만취한 상범</title>
      <link>https://jyukki97.github.io/blog/2017-12-01-6359/</link>
      <pubDate>Fri, 01 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-12-01-6359/</guid>
      <description>https://www.acmicpc.net/problem/6359
풀이:  n 개의 방이 있을 때 탈출할 수 있는 사람의 수는 sqrt(n)명이다.  코드: #include &amp;lt;iostream&amp;gt;#include &amp;lt;math.h&amp;gt;using namespace std;int main(void) {int n,T;cin &amp;gt;&amp;gt; T;for (int i = 0; i &amp;lt; T; i++) {cin &amp;gt;&amp;gt; n;cout &amp;lt;&amp;lt; (int)sqrt(n) &amp;lt;&amp;lt; endl;}return 0;}</description>
    </item>
    
    <item>
      <title>[백준]10844 쉬운 계단 수</title>
      <link>https://jyukki97.github.io/blog/2017-11-30-10844/</link>
      <pubDate>Thu, 30 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-11-30-10844/</guid>
      <description>https://www.acmicpc.net/problem/10844
풀이:  a[i][t] 는 길이가 i인 숫자에서 1의 자릿 수가 t일 때의 경우의 수 t가 0 이면 a[i][t] = a[i - 1][t + 1] t가 9 이면 a[i][t] = a[i - 1][t - 1] 둘다 아니면 a[i][t] = (a[i - 1][t - 1] + a[i - 1][t + 1]) 이 때 오버플로우가 발생하므로 각각의 계산에 1000000000을 나눠준다.  코드: #include &amp;lt;iostream&amp;gt;using namespace std;long long a[101][10] = { 0 };int main(void) {int n;cin &amp;gt;&amp;gt; n;long long cnt = 0;for (int i = 1; i &amp;lt; 10; i++) {a[0][i] = 1;}for (int i = 1; i &amp;lt; n; i++) {for (int t = 0; t &amp;lt; 10; t++) {if (t == 0)a[i][t] = a[i - 1][t + 1] % 1000000000;else if (t == 9)a[i][t] = a[i - 1][t - 1] % 1000000000;elsea[i][t] = (a[i - 1][t - 1] + a[i - 1][t + 1]) % 1000000000;}}for (int i = 0; i &amp;lt; 10; i++) {cnt += a[n - 1][i] % 1000000000;}cout &amp;lt;&amp;lt; cnt % 1000000000 &amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
    <item>
      <title>[백준]11057 오르막수</title>
      <link>https://jyukki97.github.io/blog/2017-11-30-11057/</link>
      <pubDate>Thu, 30 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-11-30-11057/</guid>
      <description>https://www.acmicpc.net/problem/11057
풀이:  a[i][t] 는 길이가 i인 수에서 1의 자리가 t인 수의 오르막 수의 개수 a[i][t] += max(a[i - 1][t], a[i][t - 1]);  코드: #include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;int a[1002][1002] = { 0 };int main(void) {int n, m;cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;for (int i = 1; i &amp;lt;= n; i++) {for (int t = 1; t &amp;lt;= m; t++) {cin &amp;gt;&amp;gt; a[i][t];}}for (int i = 1; i &amp;lt;= n; i++) {for (int t = 1; t &amp;lt;= m; t++) {a[i][t] += max(a[i - 1][t], a[i][t - 1]);}}cout &amp;lt;&amp;lt; a[n][m] &amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
    <item>
      <title>[백준]11727 2xN 타일링2</title>
      <link>https://jyukki97.github.io/blog/2017-11-30-11727/</link>
      <pubDate>Thu, 30 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-11-30-11727/</guid>
      <description>https://www.acmicpc.net/problem/11727
풀이:  a[i] 는 타일이 2xi 일때의 경우의 수 a[i] = (2 * a[i - 2] + a[i - 1] 주어진 조건에서 10007으로 나눈 나머지를 출력하라고 하였으므로 나눠줌.  코드: #include &amp;lt;iostream&amp;gt;using namespace std;int a[1001] = { 1,3,0 };int main(void) {int n;cin &amp;gt;&amp;gt; n;for (int i = 2; i &amp;lt; n; i++) {a[i] = (2 * a[i - 2] + a[i - 1])%10007;}cout &amp;lt;&amp;lt; a[n - 1] &amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
    <item>
      <title>[백준]1699 제곱수의 합</title>
      <link>https://jyukki97.github.io/blog/2017-11-30-1699/</link>
      <pubDate>Thu, 30 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-11-30-1699/</guid>
      <description>https://www.acmicpc.net/problem/1699
풀이:  q[i] 는 i 일 때 제곱수로 나타낼 수 있는 최소의 경우의 수 n 이 i + t^2 으로 나타내 질 때, 최소의 경우의 수를 찾음  코드: #include &amp;lt;iostream&amp;gt;#include &amp;lt;math.h&amp;gt;int q[100002] = { 0 };using namespace std;int main(void) {int n,a;cin &amp;gt;&amp;gt; n;a = sqrt(n);for (int i = 1; i &amp;lt;= n; i++){q[i] = 10001;for (int t = 1; t &amp;lt;= a; t++){if (i == t*t)q[i] = 1;}}for (int i = 1; i &amp;lt;= n; i++){for (int t = 1; t &amp;lt;= a; t++){if (i + (t*t) &amp;lt;= n &amp;amp;&amp;amp; q[i + (t*t)] &amp;gt; q[i] + 1)q[i + (t*t)] = q[i] + 1;}}cout &amp;lt;&amp;lt; q[n] &amp;lt;&amp;lt; endl;}</description>
    </item>
    
    <item>
      <title>[백준]1912 연속합</title>
      <link>https://jyukki97.github.io/blog/2017-11-30-1912/</link>
      <pubDate>Thu, 30 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-11-30-1912/</guid>
      <description>https://www.acmicpc.net/problem/1912
풀이:  a[i] 는 i번째를 골랐을 때, 최대값 만약 a[i-1] 이 0 보다 크다면, a[i] += a[i-1]  코드: #include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;int a[100001] = { 0 };int main(void) {int n;cin &amp;gt;&amp;gt; n;for (int i = 0; i &amp;lt; n; i++) {cin &amp;gt;&amp;gt; a[i];}int temp = a[0];for (int i = 1; i &amp;lt; n; i++) {if(a[i-1] &amp;gt; 0)a[i] += a[i - 1];temp = max(temp, a[i]);}cout &amp;lt;&amp;lt; temp &amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
    <item>
      <title>[백준]2163 초콜릿 자르기</title>
      <link>https://jyukki97.github.io/blog/2017-11-30-2163/</link>
      <pubDate>Thu, 30 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-11-30-2163/</guid>
      <description>https://www.acmicpc.net/problem/2163
풀이:  N x M 크기의 초콜릿을 자르는 최소의 경우의 수 N * M - 1  코드: #include &amp;lt;iostream&amp;gt;using namespace std;int main(void) {int n, m;cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;cout &amp;lt;&amp;lt; n*m - 1 &amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
    <item>
      <title>[백준]9461 파도반 수열</title>
      <link>https://jyukki97.github.io/blog/2017-11-30-9461/</link>
      <pubDate>Thu, 30 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-11-30-9461/</guid>
      <description>https://www.acmicpc.net/problem/9461
풀이:  a[i] 는 i 번째 수열 a[i] = a[i-1] + a[i-5]  코드: #include &amp;lt;iostream&amp;gt;using namespace std;long long a[101] = { 1,1,1,2,2,0 };int main(void) {int T,n;cin &amp;gt;&amp;gt; T;for (int i = 0; i &amp;lt; T; i++) {cin &amp;gt;&amp;gt; n;for (int t = 5; t &amp;lt; n; t++) {a[t] = a[t - 1] + a[t - 5];}cout &amp;lt;&amp;lt; a[n - 1] &amp;lt;&amp;lt; endl;}return 0;}</description>
    </item>
    
    <item>
      <title>[백준]2156 포도주 시식</title>
      <link>https://jyukki97.github.io/blog/2017-11-29-2156/</link>
      <pubDate>Wed, 29 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-11-29-2156/</guid>
      <description>https://www.acmicpc.net/problem/2156
풀이:  b[i][0] 은 i번째를 골랐을 때, i-1번째를 안고른 경우의 수 b[i][1] 은 i번째를 골랐을 때, i-1번째를 고른 경우의 수 b[i][2] 은 i번째를 골랐을 때, i-2번째를 안고른 경우의 수  코드: #include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;int main(void) {int n;cin &amp;gt;&amp;gt; n;int a[10001];for (int i = 0; i &amp;lt; n; i++) {cin &amp;gt;&amp;gt; a[i];}int b[10001][3] = { a[0],a[0],a[0],a[1],a[0] + a[1],a[1],0 };int temp;for (int i = 2; i &amp;lt; n; i++) {for (int t = 0; t &amp;lt; 3; t++) {if (t == 0) {temp = max(b[i - 2][0], b[i - 2][1]);b[i][t] = max(temp, b[i - 2][2]) + a[i];}if (t == 1)b[i][t] = max(b[i - 1][0], b[i - 1][2]) + a[i];if (t == 2)b[i][t] = b[i - 3][1] + a[i];}}temp = max(b[n - 1][0], b[n - 2][1]);temp = max(temp, b[n - 1][1]);cout &amp;lt;&amp;lt; max(temp, b[n - 1][2]) &amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
    <item>
      <title>[백준]1003 피보나치 함수</title>
      <link>https://jyukki97.github.io/blog/2017-11-28-1003/</link>
      <pubDate>Tue, 28 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-11-28-1003/</guid>
      <description>https://www.acmicpc.net/problem/1003
풀이:  0이 쓰이면 카운트 0을 ++ 1이 쓰이면 카운트 1을 ++  코드: #include &amp;lt;iostream&amp;gt;	// 재귀를 이용using namespace std;int cnt[2] = { 0 };int fibonacci(int n) {if (n == 0) {cnt[0]++;return 0;}else if (n == 1) {cnt[1]++;return 1;}elsereturn fibonacci(n-1) + fibonacci(n-2);}int main(void) {int T,n;cin &amp;gt;&amp;gt; T;for (int i = 0; i &amp;lt; T; i++) {cin &amp;gt;&amp;gt; n;cnt[0] = 0;cnt[1] = 0;fibonacci(n);cout &amp;lt;&amp;lt; cnt[0] &amp;lt;&amp;lt; &amp;#34;&amp;#34; &amp;lt;&amp;lt; cnt[1] &amp;lt;&amp;lt; endl;}return 0;}}#include &amp;lt;iostream&amp;gt;	// 포문 이용using namespace std;int main(void) {int T, n;int a[41] = { 0 };int b[41] = { 0 };cin &amp;gt;&amp;gt; T;for (int i = 0; i &amp;lt; T; i++) {cin &amp;gt;&amp;gt; n;a[0] = 1;a[1] = 0;b[0] = 0;b[1] = 1;for (int t = 2; t &amp;lt;= n; t++) {a[t] = a[t - 1] + a[t - 2];b[t] = b[t - 1] + b[t - 2];}cout &amp;lt;&amp;lt; a[n] &amp;lt;&amp;lt; &amp;#34;&amp;#34; &amp;lt;&amp;lt; b[n] &amp;lt;&amp;lt; endl;}}</description>
    </item>
    
    <item>
      <title>[백준]11726 2×n 타일링</title>
      <link>https://jyukki97.github.io/blog/2017-11-28-11726/</link>
      <pubDate>Tue, 28 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-11-28-11726/</guid>
      <description>https://www.acmicpc.net/problem/11726
풀이:  정수 i를 1,2 의 조합으로 나타낼 수 있는 경우의 수 a[i-1] a[i] = a[i-1] + a[i-2] 으로 구할 수 있다.  코드: #include &amp;lt;iostream&amp;gt;using namespace std;int main(void) {int n;int a[1001] = { 1,2,0 };cin &amp;gt;&amp;gt; n;for (int t = 2; t &amp;lt; n; t++) {a[t] = (a[t - 1] + a[t - 2]) % 10007;}cout &amp;lt;&amp;lt; a[n - 1]&amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
    <item>
      <title>[백준]1463 1로 만들기</title>
      <link>https://jyukki97.github.io/blog/2017-11-28-1463/</link>
      <pubDate>Tue, 28 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-11-28-1463/</guid>
      <description>https://www.acmicpc.net/problem/1463
풀이:  i 일때 연산 횟수를 a[i] 라고 둔다. 2와 3으로 동시에 나눠질때, 따로 나눠질때, 나눠지지 않을때로 나눠서 계산한다. n번까지 연산 후 a[n]을 출력한다.  코드: #include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;int a[1000002] = { 0 };int main(void) {int n;cin &amp;gt;&amp;gt; n;for (int i = 2; i &amp;lt;= n; i++) {if (i % 2 == 0 &amp;amp;&amp;amp; i % 3 == 0) {int temp = min(a[i / 2], a[i / 3]);a[i] = min(temp, a[i - 1]) + 1;}else if(i % 2 == 0 &amp;amp;&amp;amp; i % 3 !</description>
    </item>
    
    <item>
      <title>[백준]9095 1, 2, 3 더하기</title>
      <link>https://jyukki97.github.io/blog/2017-11-28-9095/</link>
      <pubDate>Tue, 28 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-11-28-9095/</guid>
      <description>https://www.acmicpc.net/problem/9095
풀이:  정수 i를 1,2,3의 조합으로 나타낼 수 있는 경우의 수 a[i-1] a[i] = a[i-1] + a[i-2] + a[i-3] 으로 구할 수 있다.  코드: #include &amp;lt;iostream&amp;gt;using namespace std;int main(void) {int T,n;cin &amp;gt;&amp;gt; T;for (int i = 0; i &amp;lt; T; i++) {int a[11] = { 1,2,4,0 };cin &amp;gt;&amp;gt; n;for (int t = 3; t &amp;lt; n; t++) {a[t] = a[t - 1] + a[t - 2] + a[t - 3];}cout &amp;lt;&amp;lt; a[n - 1] &amp;lt;&amp;lt; endl;}return 0;}</description>
    </item>
    
    <item>
      <title>[백준]1149 RGB거리</title>
      <link>https://jyukki97.github.io/blog/2017-11-27-1149/</link>
      <pubDate>Mon, 27 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-11-27-1149/</guid>
      <description>https://www.acmicpc.net/problem/1149
풀이:  r,g,b를 각각 b[0], b[1], b[2] 로 둠. r을 선택했다면 이전에서 g,b 중 작은값에 이번에 r값을 더하는 식으로 r,g,b 반복 r,g,b 최종값에서 가장 최소값 출력  코드: #include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;int main(void) {int n;cin &amp;gt;&amp;gt; n;int a[3001];int b[3];for (int i = 0; i &amp;lt; n*3; i++) {cin &amp;gt;&amp;gt; a[i];}for (int i = 1; i &amp;lt; n; i++) {b[0] = a[0];b[1] = a[1];b[2] = a[2];a[0] = min(b[1], b[2]) + a[i * 3];a[1] = min(b[0], b[2]) + a[(i * 3) + 1];a[2] = min(b[0], b[1]) + a[(i * 3) + 2];}int temp = min(a[0], a[1]);cout &amp;lt;&amp;lt; min(temp, a[2]) &amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
    <item>
      <title>[백준]11052 붕어빵 판매하기</title>
      <link>https://jyukki97.github.io/blog/2017-11-26-11052/</link>
      <pubDate>Sun, 26 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-11-26-11052/</guid>
      <description>https://www.acmicpc.net/problem/11052
풀이:  붕어의 개수가 i개 일 때를 b[i] 라고 놓고 b[i] = (t개 일때 가격 + 남은 붕어 빵의 가격) 과 b[i] 개중 큰값을 넣음. 구하고자 하는 n개 즉 b[n]을 찾음.  코드: #include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;int main(void) {int n, m, w;int a[1002];int b[1002] = { 0 };cin &amp;gt;&amp;gt; n;for (int i = 1; i &amp;lt;= n; i++) {cin &amp;gt;&amp;gt; a[i];}for (int i = 1; i &amp;lt;= n; i++) {for (int t = 0; t &amp;lt; i; t++) {b[i] = max(b[i], b[t] + a[i - t]);}}cout &amp;lt;&amp;lt; b[n] &amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
    <item>
      <title>[백준]1004 어린왕자</title>
      <link>https://jyukki97.github.io/blog/2017-11-25-1004/</link>
      <pubDate>Sat, 25 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-11-25-1004/</guid>
      <description>https://www.acmicpc.net/problem/1004
풀이:  시작점과 도착점이 같이 원안에 있지않을 때, 시작점, 도착점이 원 안에 있다면 카운트를 ++  코드: #include &amp;lt;iostream&amp;gt;#include &amp;lt;math.h&amp;gt;using namespace std;int main(void) {int T;cin &amp;gt;&amp;gt; T;for (int i = 0; i &amp;lt; T; i++) {int n, x1, x2, y1, y2;int x[50];int y[50];int r[50];int count = 0;cin &amp;gt;&amp;gt; x1 &amp;gt;&amp;gt; y1 &amp;gt;&amp;gt; x2 &amp;gt;&amp;gt; y2 &amp;gt;&amp;gt; n;for (int t = 0; t &amp;lt; n; t++) {cin &amp;gt;&amp;gt; x[t] &amp;gt;&amp;gt; y[t] &amp;gt;&amp;gt; r[t];}for (int t = 0; t &amp;lt; n; t++) {if (sqrt((x1 - x[t])*(x1 - x[t]) + (y1 - y[t])*(y1 - y[t])) &amp;lt; r[t]) {if (sqrt((x2 - x[t])*(x2 - x[t]) + (y2 - y[t])*(y2 - y[t])) &amp;gt;= r[t])count++;}if (sqrt((x2 - x[t])*(x2 - x[t]) + (y2 - y[t])*(y2 - y[t])) &amp;lt; r[t]) {if (sqrt((x1 - x[t])*(x1 - x[t]) + (y1 - y[t])*(y1 - y[t])) &amp;gt;= r[t])count++;}}cout &amp;lt;&amp;lt; count &amp;lt;&amp;lt; endl;}return 0;}</description>
    </item>
    
    <item>
      <title>[백준]1010 다리놓기</title>
      <link>https://jyukki97.github.io/blog/2017-11-25-1010/</link>
      <pubDate>Sat, 25 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-11-25-1010/</guid>
      <description>https://www.acmicpc.net/problem/1010
풀이:  서쪽 다리(N)에서 동쪽 다리(M)로 연결 이므로 조합인 mCn 을 사용  코드: #include &amp;lt;iostream&amp;gt;using namespace std;int Comb(int n, int r) {if (r == 0 || r == n)return 1;else if (r == n - 1 || r == 1)return n;return Comb(n - 1, r) + Comb(n - 1, r - 1);}int main(void) {int T,n,m;cin &amp;gt;&amp;gt; T;for (int i = 0; i &amp;lt; T; i++) {cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;cout &amp;lt;&amp;lt; Comb(m, n) &amp;lt;&amp;lt; endl;}return 0;}</description>
    </item>
    
    <item>
      <title>[백준]1718 암호</title>
      <link>https://jyukki97.github.io/blog/2017-11-25-1718/</link>
      <pubDate>Sat, 25 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-11-25-1718/</guid>
      <description>https://www.acmicpc.net/problem/1718
풀이:  평문에서 암호문을 뺀다. 만약 뺀 값이 0 이하일경우 z로 돌아간다.  코드: #include &amp;lt;iostream&amp;gt;#include &amp;lt;string&amp;gt;using namespace std;int main(void) {string a;getline(cin, a);string key;cin &amp;gt;&amp;gt; key;char cy[30001] = { NULL };for (int i = 0; i &amp;lt; a.length(); i++) {if (a[i] == &amp;#39;&amp;#39;)cy[i] = &amp;#39;&amp;#39;;else if ((int)a[i] - (int)key[i%key.length()] &amp;lt;= 0)cy[i] = (char)((int)a[i] - (int)key[i%key.length()] + 122);elsecy[i] = (char)((int)a[i] - (int)key[i%key.</description>
    </item>
    
    <item>
      <title>[백준]2578 빙고</title>
      <link>https://jyukki97.github.io/blog/2017-11-25-2578/</link>
      <pubDate>Sat, 25 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-11-25-2578/</guid>
      <description>https://www.acmicpc.net/problem/2578
풀이:  빙고를 저장 사회자가 말하는 번호에 빙고판에 1 저장 빙고판 가로 세로 대각선 2개 판별 빙고가 3개 넘어가면 끝  코드: #include &amp;lt;iostream&amp;gt;#include &amp;lt;map&amp;gt;using namespace std;int main(void) {map&amp;lt;int, int&amp;gt; a;int b[25] = { 0 };int c[25];int num;int count = 0;for (int i = 0; i &amp;lt; 25; i++) {cin &amp;gt;&amp;gt; num;a[num] = i;}for (int i = 0; i &amp;lt; 25; i++) {cin &amp;gt;&amp;gt; num;b[a[num]] = 1;if (b[(a[num] / 5) * 5] == 1 &amp;amp;&amp;amp; b[((a[num] / 5) * 5) + 1] == 1 &amp;amp;&amp;amp; b[((a[num] / 5) * 5) + 2] == 1 &amp;amp;&amp;amp; b[((a[num] / 5) * 5) + 3] == 1 &amp;amp;&amp;amp; b[((a[num] / 5) * 5) + 4] == 1)count++;if (b[a[num] % 5] == 1 &amp;amp;&amp;amp; b[a[num] % 5 + 5] == 1 &amp;amp;&amp;amp; b[a[num] % 5 + 10] == 1 &amp;amp;&amp;amp; b[a[num] % 5 + 15] == 1 &amp;amp;&amp;amp; b[a[num] % 5 + 20] == 1)count++;if ((a[num] % 4 == 0 &amp;amp;&amp;amp; a[num] !</description>
    </item>
    
    <item>
      <title>[백준]1932 숫자삼각형</title>
      <link>https://jyukki97.github.io/blog/2017-11-24-1932/</link>
      <pubDate>Fri, 24 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-11-24-1932/</guid>
      <description>https://www.acmicpc.net/problem/1932
풀이:  첫 줄부터 밑에줄까지 내려가면서 값을 더해감 더한 값중 제일 큰 값을 찾음  코드: #include &amp;lt;iostream&amp;gt;using namespace std;int q[501][501];int good[501][501];int main(void){int num;int big = 0;cin &amp;gt;&amp;gt; num;for (int i = 0; i &amp;lt; num; i++){for (int t = 0; t &amp;lt; i + 1; t++){cin &amp;gt;&amp;gt; q[i][t];}}good[0][0] = q[0][0];for (int i = 1; i &amp;lt; num; i++){for (int t = 0; t &amp;lt; i+1; t++){if(t==0)good[i][t] = good[i - 1][t] + q[i][t];else if (i == t)good[i][t] = good[i - 1][t - 1] + q[i][t];else{if (good[i - 1][t - 1] &amp;gt; good[i - 1][t])good[i][t] = good[i - 1][t - 1] + q[i][t];elsegood[i][t] = good[i - 1][t] + q[i][t];}}}for (int i = 0; i &amp;lt; num; i++){if (good[num - 1][i] &amp;gt; big)big = good[num - 1][i];}cout &amp;lt;&amp;lt; big &amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
    <item>
      <title>[백준]2293 동전1</title>
      <link>https://jyukki97.github.io/blog/2017-11-23-2293/</link>
      <pubDate>Thu, 23 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-11-23-2293/</guid>
      <description>https://www.acmicpc.net/problem/2293
풀이:  첫번째 동전부터 경우의 수를 더해감.  코드: #include &amp;lt;iostream&amp;gt;using namespace std;int coin[10001] = { 0 };int main(void){int a;int num;cin &amp;gt;&amp;gt; a;cin &amp;gt;&amp;gt; num;int *q = new int[a];for (int i = 0; i &amp;lt; a; i++){cin &amp;gt;&amp;gt; q[i];}for (int i = 0; i &amp;lt;= num; i++){if (i%q[0] == 0)coin[i]++;}for (int i = 1; i &amp;lt; a; i++){for (int t = q[i]; t &amp;lt;= num; t++){coin[t] += coin[t - q[i]];}}cout &amp;lt;&amp;lt; coin[num] &amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
    <item>
      <title>[백준]3613 Java vs C&#43;&#43;</title>
      <link>https://jyukki97.github.io/blog/2017-11-22-3613/</link>
      <pubDate>Wed, 22 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-11-22-3613/</guid>
      <description>https://www.acmicpc.net/problem/3613
풀이:  java 변수면 c++로 c++ 이면 java로 변경 예외처리  코드: #include &amp;lt;iostream&amp;gt;#include &amp;lt;string.h&amp;gt;using namespace std;int main(void) {char a[201];char b[201] = {&amp;#39;\n&amp;#39;};bool java = false;bool cplus = false;bool ero = true;cin &amp;gt;&amp;gt; a;int t = 0;for (int i = 0; i &amp;lt; strlen(a); i++) {if (65 &amp;lt;= (int)a[i] &amp;amp;&amp;amp; (int)a[i] &amp;lt;= 90) {if (i == 0 || cplus == true) {ero = false;break;}b[t] = &amp;#39;_&amp;#39;;t++;b[t] = a[i] + 32;java = true;}else if (a[i] == &amp;#39;_&amp;#39;) {if (i == 0 || i == strlen(a)-1 || a[i + 1] == &amp;#39;_&amp;#39; || java == true || (65 &amp;lt;= (int)a[i + 1] &amp;amp;&amp;amp; (int)a[i + 1] &amp;lt;= 90)) {ero = false;break;}b[t] = a[i + 1] - 32;i++;cplus = true;}else b[t] = a[i];t++;}if (ero == false)cout &amp;lt;&amp;lt; &amp;#34;Error!</description>
    </item>
    
    <item>
      <title>[백준]1065 한수</title>
      <link>https://jyukki97.github.io/blog/2017-11-20-1065/</link>
      <pubDate>Mon, 20 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-11-20-1065/</guid>
      <description>https://www.acmicpc.net/problem/1065
풀이: 한수이면 카운트를 ++ 하는 함수를 만듦
코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;using namespace std;int hannum(int n, int c) {int b = (n % 1000) / 100;int d = ((n % 1000) % 100) / 10;int f = ((n % 1000) % 100) % 10;if (n &amp;gt; 99) {if ((b - d == d - f) &amp;amp;&amp;amp; n != 1000)c++;}elsec++;if (n == 1)return c;elsereturn hannum(n - 1, c);}int main(void) {int a;cin &amp;gt;&amp;gt; a;cout &amp;lt;&amp;lt; hannum(a, 0);return 0;}</description>
    </item>
    
    <item>
      <title>[백준]1475 방번호</title>
      <link>https://jyukki97.github.io/blog/2017-11-20-1475/</link>
      <pubDate>Mon, 20 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-11-20-1475/</guid>
      <description>https://www.acmicpc.net/problem/1475
풀이:  방번호를 string에 저장 string 첫번째 자릿수부터 숫자를 확인 숫자에 맞는 배열에 ++ 배열에서 가장 큰 숫자를 가지고 있는 값을 출력  코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;string&amp;gt;using namespace std;int main(void) {string a;int b[10] = { 0 };cin &amp;gt;&amp;gt; a;for (int i = 0; i &amp;lt; a.length(); i++) {if (((int)a[i] - 48) == 6 &amp;amp;&amp;amp; b[6] &amp;gt; b[9])b[9] ++;else if (((int)a[i] - 48) == 9 &amp;amp;&amp;amp; b[6] &amp;lt; b[9])b[6] ++;elseb[(int)a[i] - 48]++;}int count = 0;for (int i = 0; i &amp;lt; 10; i++) {if (b[i] &amp;gt; count)count = b[i];}cout &amp;lt;&amp;lt; count &amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
    <item>
      <title>[백준]2098 외판원 순회</title>
      <link>https://jyukki97.github.io/blog/2019-06-01-2098/</link>
      <pubDate>Mon, 20 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-06-01-2098/</guid>
      <description>https://www.acmicpc.net/problem/2098
풀이:  dp[a][b]를 현제 위치가 a이고, 이때까지 방문한 도시들의 목록이 b인 여행비용의 최솟값이라고 한다. 방문한 도시들을 쉽게 나타내기 위해 비트마스크를 사용하였다. 최솟값을 구하는 문제이므로 r을 최대한 큰 수로 두고 min함수를 이용한다. 도시의 비용이 0인 경우 방문할 수 없으므로 제외시킨다. 방문 횟수가 많아 시간초과가 날 수 있으므로 메모이제이션을 한다. 순회 문제이기 때문에 시작위치는 상관없으므로 실행시간을 늘리지 않도록 주의한다.  코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;int w[17][17],d[17][100000], n;int T(int a, int b) {if ((1 &amp;lt;&amp;lt; n) - 1 == b &amp;amp;&amp;amp; w[a][0] !</description>
    </item>
    
    <item>
      <title>[백준]9507 Generations of Tribbles</title>
      <link>https://jyukki97.github.io/blog/2017-12-18-9507/</link>
      <pubDate>Mon, 20 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-12-18-9507/</guid>
      <description>https://www.acmicpc.net/problem/9507
풀이:  문제에 DP가 주어져 있으므로 그대로 하면된다. 다만 큰 수가 나오므로 long long을 써야할 것이다.  코드: #include &amp;lt;iostream&amp;gt;using namespace std;long long a[70] = {1,1,2,4,0};int main(void) {int T,n;int cnt = 4;cin &amp;gt;&amp;gt; T;for (int i = 0; i &amp;lt; T; i++) {cin &amp;gt;&amp;gt; n;for (int t = cnt; t &amp;lt; n + 1; t++) {a[t] = a[t - 1] + a[t - 2] + a[t - 3] + a[t - 4];}cout &amp;lt;&amp;lt; a[n] &amp;lt;&amp;lt; endl;cnt = n + 1;}return 0;}</description>
    </item>
    
    <item>
      <title>start</title>
      <link>https://jyukki97.github.io/blog/2017-11-19-start/</link>
      <pubDate>Sun, 19 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-11-19-start/</guid>
      <description>안녕하세요.</description>
    </item>
    
  </channel>
</rss>