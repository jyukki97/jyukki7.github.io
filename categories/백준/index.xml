<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>백준 on 1 Day 1 Problem</title>
    <link>https://jyukki97.github.io/categories/%EB%B0%B1%EC%A4%80/</link>
    <description>Recent content in 백준 on 1 Day 1 Problem</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>kr-ko</language>
    <lastBuildDate>Thu, 20 Jun 2019 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://jyukki97.github.io/categories/%EB%B0%B1%EC%A4%80/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>[백준]11399 ATM</title>
      <link>https://jyukki97.github.io/blog/2019-06-20-11399/</link>
      <pubDate>Thu, 20 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-06-20-11399/</guid>
      <description>https://www.acmicpc.net/problem/11399
풀이:  돈을 인출하는데 필요한 시간을 입력받는다. 입력받은 시간을 정렬한다. 정렬한 값을 n-i를 곱해서 더해준다.  코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;int main() {int n,r=0,a[1001];cin &amp;gt;&amp;gt; n;for (int i = 0; i &amp;lt; n; i++)cin &amp;gt;&amp;gt; a[i];sort(&amp;amp;a[0], &amp;amp;a[n]);for (int i = 0; i &amp;lt; n; i++)r += a[i] * (n - i);cout &amp;lt;&amp;lt; r &amp;lt;&amp;lt; endl;}</description>
    </item>
    
    <item>
      <title>[백준]2609 최대공약수와 최소공배수</title>
      <link>https://jyukki97.github.io/blog/2019-06-19-2609/</link>
      <pubDate>Wed, 19 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-06-19-2609/</guid>
      <description>https://www.acmicpc.net/problem/2609
풀이:  두 수를 입력받는다. 두 수의 최대공약수와 최소공배수를 출력한다.  코드: 사용언어 : Python 3
import matha,b=map(int,input().split())c=math.gcd(a,b)print(c,a//c*b)</description>
    </item>
    
    <item>
      <title>[백준]14490 백대열</title>
      <link>https://jyukki97.github.io/blog/2019-06-18-14490/</link>
      <pubDate>Tue, 18 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-06-18-14490/</guid>
      <description>https://www.acmicpc.net/problem/14490
풀이:  두 수를 입력받는다(:을 사이에 두고 주어지므로 주의) 두 수의 최대공약수를 구한다. 두 수를 최대공약수로 나눠서 출력한다(최대한으로 약분은 최대공약수로 나누어주면 가능하다)(이때 :을 사이에 두고 출력한다.)  코드: 사용언어 : Python 3
import matha,b=map(int,input().split(&amp;#39;:&amp;#39;))c=math.gcd(a,b)print(a//c,b//c,sep=&amp;#39;:&amp;#39;)</description>
    </item>
    
    <item>
      <title>[백준]1850 최대공약수</title>
      <link>https://jyukki97.github.io/blog/2019-06-17-1850/</link>
      <pubDate>Mon, 17 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-06-17-1850/</guid>
      <description>https://www.acmicpc.net/problem/1850
풀이:  두 수를 입력받는다 두 수의 최대공약수를 구한다. 최대공약수만큼 1을 반복해서 출력한다.  코드: 사용언어 : Python 3
a,b=map(int,input().split())while b: a,b=b,a%bprint(&amp;#39;1&amp;#39;*a)</description>
    </item>
    
    <item>
      <title>[백준]10757 큰 수 A&#43;B</title>
      <link>https://jyukki97.github.io/blog/2019-06-16-10757/</link>
      <pubDate>Sun, 16 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-06-16-10757/</guid>
      <description>https://www.acmicpc.net/problem/10757
풀이:  두 수를 입력받은 후 더해서 출력한다.  코드: 사용언어 : Python 3
print(sum(map(int,input().split())))</description>
    </item>
    
    <item>
      <title>[백준]10826 피보나치 수 4</title>
      <link>https://jyukki97.github.io/blog/2019-06-15-10826/</link>
      <pubDate>Sat, 15 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-06-15-10826/</guid>
      <description>https://www.acmicpc.net/problem/10826
풀이:  n을 입력받는다 n번째 피보나치 수를 출력한다  코드: 사용언어 : Python 3
s,t=0,1for i in range(int(input())):t,s=s,s+tprint(s)</description>
    </item>
    
    <item>
      <title>[백준]11050 이항 계수 1</title>
      <link>https://jyukki97.github.io/blog/2019-06-14-11050/</link>
      <pubDate>Fri, 14 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-06-14-11050/</guid>
      <description>https://www.acmicpc.net/problem/11050
풀이:  n, k 를 입력받고, nCk를 출력한다  코드: 사용언어 : Python 3
n,k=map(int,input().split())r=1for i in range(k): r*=(n-i)/(i+1)print((int)(r))</description>
    </item>
    
    <item>
      <title>[백준]11365 !밀비 급일</title>
      <link>https://jyukki97.github.io/blog/2019-06-13-11365/</link>
      <pubDate>Thu, 13 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-06-13-11365/</guid>
      <description>https://www.acmicpc.net/problem/11365
풀이:  문자열을 입력받고, 그 문자열을 뒤집어서 출력한다. 문자열이 END라면 반복을 중지한다.  코드: 사용언어 : Python 3
while 1:a=input()if a==&#39;END&#39;:breakprint(a[::-1])</description>
    </item>
    
    <item>
      <title>[백준]10952 A&#43;B - 5</title>
      <link>https://jyukki97.github.io/blog/2019-06-12-10952/</link>
      <pubDate>Wed, 12 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-06-12-10952/</guid>
      <description>https://www.acmicpc.net/problem/10952
풀이:  반복 횟수를 무한히 한 후 입력받은 두 수의 합을 출력 입력받은 두 수가 0 0 이라면 반복문을 빠져나간다.  코드: 사용언어 : Python 3
while 1:a,b=map(int,input().split())if a==0:breakprint(a+b)</description>
    </item>
    
    <item>
      <title>[백준]15552 빠른 A&#43;B</title>
      <link>https://jyukki97.github.io/blog/2019-06-11-15552/</link>
      <pubDate>Tue, 11 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-06-11-15552/</guid>
      <description>https://www.acmicpc.net/problem/15552
풀이:  반복 횟수를 입력받은 후 입력받은 두 수의 합을 출력 간단한 문제이지만 매우 많은 테스트케이스의 수가 있으므로 input() 대신 sys.stdin().readline()을 사용한다.  코드: 사용언어 : Python 3
import sysfor i in range(int(input())):print(sum(map(int,sys.stdin.readline().split())))</description>
    </item>
    
    <item>
      <title>[백준]10950 A&#43;B - 3</title>
      <link>https://jyukki97.github.io/blog/2019-06-10-10950/</link>
      <pubDate>Mon, 10 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-06-10-10950/</guid>
      <description>https://www.acmicpc.net/problem/10950
풀이:  반복 횟수를 입력받은 후 입력받은 두 수의 합을 출력  코드: 사용언어 : Python 3
for i in range(int(input())):print(sum(map(int,input().split())))</description>
    </item>
    
    <item>
      <title>[백준]10971 외판원 순회 2</title>
      <link>https://jyukki97.github.io/blog/2019-06-09-10971/</link>
      <pubDate>Sun, 09 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-06-09-10971/</guid>
      <description>https://www.acmicpc.net/problem/10971
풀이:  https://jyukki97.github.io/2098/ 과 같으므로 참고  코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;int w[17][17],d[17][100000], n;int T(int a, int b) {if ((1 &amp;lt;&amp;lt; n) - 1 == b &amp;amp;&amp;amp; w[a][0] != 0)return w[a][0];int &amp;amp;r = d[a][b];if (r &amp;gt; 0)return r;r = 100000000;for (int i = 0; i &amp;lt; n; i++)if (w[a][i] != 0 &amp;amp;&amp;amp; (b &amp;amp; (1 &amp;lt;&amp;lt; i)) == 0)r = min(r, w[a][i] + T(i, b | (1 &amp;lt;&amp;lt; i)));return r;}int main(void) {cin &amp;gt;&amp;gt; n;for (int i = 0; i &amp;lt; n; i++)for (int t = 0; t &amp;lt; n; t++)cin &amp;gt;&amp;gt; w[i][t];cout &amp;lt;&amp;lt; T(0, 1) &amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
    <item>
      <title>[백준]11047 동전 0</title>
      <link>https://jyukki97.github.io/blog/2019-06-08-11047/</link>
      <pubDate>Sat, 08 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-06-08-11047/</guid>
      <description>https://www.acmicpc.net/problem/11047
풀이:  동전에 가격이 높은 것 부터 내가 필요한 가격에서 빼준다. 빼준 횟수만큼 카운트를 높여준다. 카운트를 출력한다. ( i ≥ 2인 경우에 Ai는 Ai-1의 배수) 조건으로 인해 그냥 높은 것 부터 빼줘도 문제가 생기지않는다.  코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;using namespace std;int main() {int n, k, s[12], c = 0;cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; k;while (n--)cin &amp;gt;&amp;gt; s[n];while (k) {c += k / s[++n]; k %= s[n];}cout &amp;lt;&amp;lt; c &amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
    <item>
      <title>[백준]2164 카드2</title>
      <link>https://jyukki97.github.io/blog/2019-06-07-2164/</link>
      <pubDate>Fri, 07 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-06-07-2164/</guid>
      <description>https://www.acmicpc.net/problem/2164
풀이:  카드의 갯수가 2 ^ i 개일 경우 남게 되는 카드의 번호는 2 ^ i 이다. 카드의 갯수가 (2 ^ i) + n 개 일 경우 남게 되는 카드의 번호는 2 * n 이다.  코드: 사용언어 : Python 3
n,s=int(input()),1while s&amp;lt;n:s*=2print(s if s==n else 2*n-s)</description>
    </item>
    
    <item>
      <title>[백준]12015 가장 긴 증가하는 부분 수열 2</title>
      <link>https://jyukki97.github.io/blog/2019-06-06-12015/</link>
      <pubDate>Thu, 06 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-06-06-12015/</guid>
      <description>https://www.acmicpc.net/problem/12015
풀이:  https://jyukki97.github.io/2352/ 와 같은 문제이므로 참고  코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std;vector&amp;lt;int&amp;gt;d;int main(void) {int n, s, l;cin &amp;gt;&amp;gt; n;while (n--) {cin &amp;gt;&amp;gt; s;l = lower_bound(d.begin(), d.end(), s) - d.begin();if (l == d.size())d.push_back(s);elsed[l] = s;}cout &amp;lt;&amp;lt; d.size() &amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
    <item>
      <title>[백준]1365 꼬인 전깃줄</title>
      <link>https://jyukki97.github.io/blog/2019-06-05-1365/</link>
      <pubDate>Wed, 05 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-06-05-1365/</guid>
      <description>https://www.acmicpc.net/problem/1365
풀이:  https://jyukki97.github.io/2352/ 와 같은 문제이므로 참고  코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std;vector&amp;lt;int&amp;gt;d;int main(void) {int n, s, l;cin &amp;gt;&amp;gt; n;for (int i = 0; i &amp;lt; n; i++) {cin &amp;gt;&amp;gt; s;l = lower_bound(d.begin(), d.end(), s) - d.begin();if (l == d.size())d.push_back(s);elsed[l] = s;}cout &amp;lt;&amp;lt; n - d.size() &amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
    <item>
      <title>[백준]2352 반도체 설계</title>
      <link>https://jyukki97.github.io/blog/2019-06-04-2352/</link>
      <pubDate>Tue, 04 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2019-06-04-2352/</guid>
      <description>https://www.acmicpc.net/problem/2352
풀이:  맨 처음 값부터 하나 하나 입력받는다. 입력받은 값이 벡터 안에 있는 값들 보다 크다면 벡터에 맨 뒤에 넣는다. 벡터의 처음부터 검색했을 때, 입력받은 값보다 큰 값이 있다면, 그 값과 교체한다. 벡터의 원소 갯수를 출력한다. 일반적으로 for문을 두개 쓴 O(n^2)의 코드는 시간초과가 나므로 주의하자  코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std;vector&amp;lt;int&amp;gt;d;int main(void) {int n, s, l;cin &amp;gt;&amp;gt; n;while(n--) {cin &amp;gt;&amp;gt; s;l = lower_bound(d.</description>
    </item>
    
    <item>
      <title>[백준]10844 쉬운 계단 수</title>
      <link>https://jyukki97.github.io/blog/2017-11-30-10844/</link>
      <pubDate>Thu, 30 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-11-30-10844/</guid>
      <description>https://www.acmicpc.net/problem/10844
풀이:  a[i][t] 는 길이가 i인 숫자에서 1의 자릿 수가 t일 때의 경우의 수 t가 0 이면 a[i][t] = a[i - 1][t + 1] t가 9 이면 a[i][t] = a[i - 1][t - 1] 둘다 아니면 a[i][t] = (a[i - 1][t - 1] + a[i - 1][t + 1]) 이 때 오버플로우가 발생하므로 각각의 계산에 1000000000을 나눠준다.  코드: #include &amp;lt;iostream&amp;gt;using namespace std;long long a[101][10] = { 0 };int main(void) {int n;cin &amp;gt;&amp;gt; n;long long cnt = 0;for (int i = 1; i &amp;lt; 10; i++) {a[0][i] = 1;}for (int i = 1; i &amp;lt; n; i++) {for (int t = 0; t &amp;lt; 10; t++) {if (t == 0)a[i][t] = a[i - 1][t + 1] % 1000000000;else if (t == 9)a[i][t] = a[i - 1][t - 1] % 1000000000;elsea[i][t] = (a[i - 1][t - 1] + a[i - 1][t + 1]) % 1000000000;}}for (int i = 0; i &amp;lt; 10; i++) {cnt += a[n - 1][i] % 1000000000;}cout &amp;lt;&amp;lt; cnt % 1000000000 &amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
    <item>
      <title>[백준]11057 오르막수</title>
      <link>https://jyukki97.github.io/blog/2017-11-30-11057/</link>
      <pubDate>Thu, 30 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-11-30-11057/</guid>
      <description>https://www.acmicpc.net/problem/11057
풀이:  a[i][t] 는 길이가 i인 수에서 1의 자리가 t인 수의 오르막 수의 개수 a[i][t] += max(a[i - 1][t], a[i][t - 1]);  코드: #include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;int a[1002][1002] = { 0 };int main(void) {int n, m;cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;for (int i = 1; i &amp;lt;= n; i++) {for (int t = 1; t &amp;lt;= m; t++) {cin &amp;gt;&amp;gt; a[i][t];}}for (int i = 1; i &amp;lt;= n; i++) {for (int t = 1; t &amp;lt;= m; t++) {a[i][t] += max(a[i - 1][t], a[i][t - 1]);}}cout &amp;lt;&amp;lt; a[n][m] &amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
    <item>
      <title>[백준]11727 2xN 타일링2</title>
      <link>https://jyukki97.github.io/blog/2017-11-30-11727/</link>
      <pubDate>Thu, 30 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-11-30-11727/</guid>
      <description>https://www.acmicpc.net/problem/11727
풀이:  a[i] 는 타일이 2xi 일때의 경우의 수 a[i] = (2 * a[i - 2] + a[i - 1] 주어진 조건에서 10007으로 나눈 나머지를 출력하라고 하였으므로 나눠줌.  코드: #include &amp;lt;iostream&amp;gt;using namespace std;int a[1001] = { 1,3,0 };int main(void) {int n;cin &amp;gt;&amp;gt; n;for (int i = 2; i &amp;lt; n; i++) {a[i] = (2 * a[i - 2] + a[i - 1])%10007;}cout &amp;lt;&amp;lt; a[n - 1] &amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
    <item>
      <title>[백준]1699 제곱수의 합</title>
      <link>https://jyukki97.github.io/blog/2017-11-30-1699/</link>
      <pubDate>Thu, 30 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-11-30-1699/</guid>
      <description>https://www.acmicpc.net/problem/1699
풀이:  q[i] 는 i 일 때 제곱수로 나타낼 수 있는 최소의 경우의 수 n 이 i + t^2 으로 나타내 질 때, 최소의 경우의 수를 찾음  코드: #include &amp;lt;iostream&amp;gt;#include &amp;lt;math.h&amp;gt;int q[100002] = { 0 };using namespace std;int main(void) {int n,a;cin &amp;gt;&amp;gt; n;a = sqrt(n);for (int i = 1; i &amp;lt;= n; i++){q[i] = 10001;for (int t = 1; t &amp;lt;= a; t++){if (i == t*t)q[i] = 1;}}for (int i = 1; i &amp;lt;= n; i++){for (int t = 1; t &amp;lt;= a; t++){if (i + (t*t) &amp;lt;= n &amp;amp;&amp;amp; q[i + (t*t)] &amp;gt; q[i] + 1)q[i + (t*t)] = q[i] + 1;}}cout &amp;lt;&amp;lt; q[n] &amp;lt;&amp;lt; endl;}</description>
    </item>
    
    <item>
      <title>[백준]1912 연속합</title>
      <link>https://jyukki97.github.io/blog/2017-11-30-1912/</link>
      <pubDate>Thu, 30 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-11-30-1912/</guid>
      <description>https://www.acmicpc.net/problem/1912
풀이:  a[i] 는 i번째를 골랐을 때, 최대값 만약 a[i-1] 이 0 보다 크다면, a[i] += a[i-1]  코드: #include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;int a[100001] = { 0 };int main(void) {int n;cin &amp;gt;&amp;gt; n;for (int i = 0; i &amp;lt; n; i++) {cin &amp;gt;&amp;gt; a[i];}int temp = a[0];for (int i = 1; i &amp;lt; n; i++) {if(a[i-1] &amp;gt; 0)a[i] += a[i - 1];temp = max(temp, a[i]);}cout &amp;lt;&amp;lt; temp &amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
    <item>
      <title>[백준]2163 초콜릿 자르기</title>
      <link>https://jyukki97.github.io/blog/2017-11-30-2163/</link>
      <pubDate>Thu, 30 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-11-30-2163/</guid>
      <description>https://www.acmicpc.net/problem/2163
풀이:  N x M 크기의 초콜릿을 자르는 최소의 경우의 수 N * M - 1  코드: #include &amp;lt;iostream&amp;gt;using namespace std;int main(void) {int n, m;cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;cout &amp;lt;&amp;lt; n*m - 1 &amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
    <item>
      <title>[백준]9461 파도반 수열</title>
      <link>https://jyukki97.github.io/blog/2017-11-30-9461/</link>
      <pubDate>Thu, 30 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-11-30-9461/</guid>
      <description>https://www.acmicpc.net/problem/9461
풀이:  a[i] 는 i 번째 수열 a[i] = a[i-1] + a[i-5]  코드: #include &amp;lt;iostream&amp;gt;using namespace std;long long a[101] = { 1,1,1,2,2,0 };int main(void) {int T,n;cin &amp;gt;&amp;gt; T;for (int i = 0; i &amp;lt; T; i++) {cin &amp;gt;&amp;gt; n;for (int t = 5; t &amp;lt; n; t++) {a[t] = a[t - 1] + a[t - 5];}cout &amp;lt;&amp;lt; a[n - 1] &amp;lt;&amp;lt; endl;}return 0;}</description>
    </item>
    
    <item>
      <title>[백준]2156 포도주 시식</title>
      <link>https://jyukki97.github.io/blog/2017-11-29-2156/</link>
      <pubDate>Wed, 29 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-11-29-2156/</guid>
      <description>https://www.acmicpc.net/problem/2156
풀이:  b[i][0] 은 i번째를 골랐을 때, i-1번째를 안고른 경우의 수 b[i][1] 은 i번째를 골랐을 때, i-1번째를 고른 경우의 수 b[i][2] 은 i번째를 골랐을 때, i-2번째를 안고른 경우의 수  코드: #include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;int main(void) {int n;cin &amp;gt;&amp;gt; n;int a[10001];for (int i = 0; i &amp;lt; n; i++) {cin &amp;gt;&amp;gt; a[i];}int b[10001][3] = { a[0],a[0],a[0],a[1],a[0] + a[1],a[1],0 };int temp;for (int i = 2; i &amp;lt; n; i++) {for (int t = 0; t &amp;lt; 3; t++) {if (t == 0) {temp = max(b[i - 2][0], b[i - 2][1]);b[i][t] = max(temp, b[i - 2][2]) + a[i];}if (t == 1)b[i][t] = max(b[i - 1][0], b[i - 1][2]) + a[i];if (t == 2)b[i][t] = b[i - 3][1] + a[i];}}temp = max(b[n - 1][0], b[n - 2][1]);temp = max(temp, b[n - 1][1]);cout &amp;lt;&amp;lt; max(temp, b[n - 1][2]) &amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
    <item>
      <title>[백준]11726 2×n 타일링</title>
      <link>https://jyukki97.github.io/blog/2017-11-28-11726/</link>
      <pubDate>Tue, 28 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-11-28-11726/</guid>
      <description>https://www.acmicpc.net/problem/11726
풀이:  정수 i를 1,2 의 조합으로 나타낼 수 있는 경우의 수 a[i-1] a[i] = a[i-1] + a[i-2] 으로 구할 수 있다.  코드: #include &amp;lt;iostream&amp;gt;using namespace std;int main(void) {int n;int a[1001] = { 1,2,0 };cin &amp;gt;&amp;gt; n;for (int t = 2; t &amp;lt; n; t++) {a[t] = (a[t - 1] + a[t - 2]) % 10007;}cout &amp;lt;&amp;lt; a[n - 1]&amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
    <item>
      <title>[백준]1463 1로 만들기</title>
      <link>https://jyukki97.github.io/blog/2017-11-28-1463/</link>
      <pubDate>Tue, 28 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-11-28-1463/</guid>
      <description>https://www.acmicpc.net/problem/1463
풀이:  i 일때 연산 횟수를 a[i] 라고 둔다. 2와 3으로 동시에 나눠질때, 따로 나눠질때, 나눠지지 않을때로 나눠서 계산한다. n번까지 연산 후 a[n]을 출력한다.  코드: #include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;int a[1000002] = { 0 };int main(void) {int n;cin &amp;gt;&amp;gt; n;for (int i = 2; i &amp;lt;= n; i++) {if (i % 2 == 0 &amp;amp;&amp;amp; i % 3 == 0) {int temp = min(a[i / 2], a[i / 3]);a[i] = min(temp, a[i - 1]) + 1;}else if(i % 2 == 0 &amp;amp;&amp;amp; i % 3 !</description>
    </item>
    
    <item>
      <title>[백준]9095 1, 2, 3 더하기</title>
      <link>https://jyukki97.github.io/blog/2017-11-28-9095/</link>
      <pubDate>Tue, 28 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-11-28-9095/</guid>
      <description>https://www.acmicpc.net/problem/9095
풀이:  정수 i를 1,2,3의 조합으로 나타낼 수 있는 경우의 수 a[i-1] a[i] = a[i-1] + a[i-2] + a[i-3] 으로 구할 수 있다.  코드: #include &amp;lt;iostream&amp;gt;using namespace std;int main(void) {int T,n;cin &amp;gt;&amp;gt; T;for (int i = 0; i &amp;lt; T; i++) {int a[11] = { 1,2,4,0 };cin &amp;gt;&amp;gt; n;for (int t = 3; t &amp;lt; n; t++) {a[t] = a[t - 1] + a[t - 2] + a[t - 3];}cout &amp;lt;&amp;lt; a[n - 1] &amp;lt;&amp;lt; endl;}return 0;}</description>
    </item>
    
    <item>
      <title>[백준]11052 붕어빵 판매하기</title>
      <link>https://jyukki97.github.io/blog/2017-11-26-11052/</link>
      <pubDate>Sun, 26 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-11-26-11052/</guid>
      <description>https://www.acmicpc.net/problem/11052
풀이:  붕어의 개수가 i개 일 때를 b[i] 라고 놓고 b[i] = (t개 일때 가격 + 남은 붕어 빵의 가격) 과 b[i] 개중 큰값을 넣음. 구하고자 하는 n개 즉 b[n]을 찾음.  코드: #include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;using namespace std;int main(void) {int n, m, w;int a[1002];int b[1002] = { 0 };cin &amp;gt;&amp;gt; n;for (int i = 1; i &amp;lt;= n; i++) {cin &amp;gt;&amp;gt; a[i];}for (int i = 1; i &amp;lt;= n; i++) {for (int t = 0; t &amp;lt; i; t++) {b[i] = max(b[i], b[t] + a[i - t]);}}cout &amp;lt;&amp;lt; b[n] &amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
    <item>
      <title>[백준]1004 어린왕자</title>
      <link>https://jyukki97.github.io/blog/2017-11-25-1004/</link>
      <pubDate>Sat, 25 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-11-25-1004/</guid>
      <description>https://www.acmicpc.net/problem/1004
풀이:  시작점과 도착점이 같이 원안에 있지않을 때, 시작점, 도착점이 원 안에 있다면 카운트를 ++  코드: #include &amp;lt;iostream&amp;gt;#include &amp;lt;math.h&amp;gt;using namespace std;int main(void) {int T;cin &amp;gt;&amp;gt; T;for (int i = 0; i &amp;lt; T; i++) {int n, x1, x2, y1, y2;int x[50];int y[50];int r[50];int count = 0;cin &amp;gt;&amp;gt; x1 &amp;gt;&amp;gt; y1 &amp;gt;&amp;gt; x2 &amp;gt;&amp;gt; y2 &amp;gt;&amp;gt; n;for (int t = 0; t &amp;lt; n; t++) {cin &amp;gt;&amp;gt; x[t] &amp;gt;&amp;gt; y[t] &amp;gt;&amp;gt; r[t];}for (int t = 0; t &amp;lt; n; t++) {if (sqrt((x1 - x[t])*(x1 - x[t]) + (y1 - y[t])*(y1 - y[t])) &amp;lt; r[t]) {if (sqrt((x2 - x[t])*(x2 - x[t]) + (y2 - y[t])*(y2 - y[t])) &amp;gt;= r[t])count++;}if (sqrt((x2 - x[t])*(x2 - x[t]) + (y2 - y[t])*(y2 - y[t])) &amp;lt; r[t]) {if (sqrt((x1 - x[t])*(x1 - x[t]) + (y1 - y[t])*(y1 - y[t])) &amp;gt;= r[t])count++;}}cout &amp;lt;&amp;lt; count &amp;lt;&amp;lt; endl;}return 0;}</description>
    </item>
    
    <item>
      <title>[백준]1010 다리놓기</title>
      <link>https://jyukki97.github.io/blog/2017-11-25-1010/</link>
      <pubDate>Sat, 25 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-11-25-1010/</guid>
      <description>https://www.acmicpc.net/problem/1010
풀이:  서쪽 다리(N)에서 동쪽 다리(M)로 연결 이므로 조합인 mCn 을 사용  코드: #include &amp;lt;iostream&amp;gt;using namespace std;int Comb(int n, int r) {if (r == 0 || r == n)return 1;else if (r == n - 1 || r == 1)return n;return Comb(n - 1, r) + Comb(n - 1, r - 1);}int main(void) {int T,n,m;cin &amp;gt;&amp;gt; T;for (int i = 0; i &amp;lt; T; i++) {cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;cout &amp;lt;&amp;lt; Comb(m, n) &amp;lt;&amp;lt; endl;}return 0;}</description>
    </item>
    
    <item>
      <title>[백준]1718 암호</title>
      <link>https://jyukki97.github.io/blog/2017-11-25-1718/</link>
      <pubDate>Sat, 25 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-11-25-1718/</guid>
      <description>https://www.acmicpc.net/problem/1718
풀이:  평문에서 암호문을 뺀다. 만약 뺀 값이 0 이하일경우 z로 돌아간다.  코드: #include &amp;lt;iostream&amp;gt;#include &amp;lt;string&amp;gt;using namespace std;int main(void) {string a;getline(cin, a);string key;cin &amp;gt;&amp;gt; key;char cy[30001] = { NULL };for (int i = 0; i &amp;lt; a.length(); i++) {if (a[i] == &amp;#39;&amp;#39;)cy[i] = &amp;#39;&amp;#39;;else if ((int)a[i] - (int)key[i%key.length()] &amp;lt;= 0)cy[i] = (char)((int)a[i] - (int)key[i%key.length()] + 122);elsecy[i] = (char)((int)a[i] - (int)key[i%key.</description>
    </item>
    
    <item>
      <title>[백준]2578 빙고</title>
      <link>https://jyukki97.github.io/blog/2017-11-25-2578/</link>
      <pubDate>Sat, 25 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-11-25-2578/</guid>
      <description>https://www.acmicpc.net/problem/2578
풀이:  빙고를 저장 사회자가 말하는 번호에 빙고판에 1 저장 빙고판 가로 세로 대각선 2개 판별 빙고가 3개 넘어가면 끝  코드: #include &amp;lt;iostream&amp;gt;#include &amp;lt;map&amp;gt;using namespace std;int main(void) {map&amp;lt;int, int&amp;gt; a;int b[25] = { 0 };int c[25];int num;int count = 0;for (int i = 0; i &amp;lt; 25; i++) {cin &amp;gt;&amp;gt; num;a[num] = i;}for (int i = 0; i &amp;lt; 25; i++) {cin &amp;gt;&amp;gt; num;b[a[num]] = 1;if (b[(a[num] / 5) * 5] == 1 &amp;amp;&amp;amp; b[((a[num] / 5) * 5) + 1] == 1 &amp;amp;&amp;amp; b[((a[num] / 5) * 5) + 2] == 1 &amp;amp;&amp;amp; b[((a[num] / 5) * 5) + 3] == 1 &amp;amp;&amp;amp; b[((a[num] / 5) * 5) + 4] == 1)count++;if (b[a[num] % 5] == 1 &amp;amp;&amp;amp; b[a[num] % 5 + 5] == 1 &amp;amp;&amp;amp; b[a[num] % 5 + 10] == 1 &amp;amp;&amp;amp; b[a[num] % 5 + 15] == 1 &amp;amp;&amp;amp; b[a[num] % 5 + 20] == 1)count++;if ((a[num] % 4 == 0 &amp;amp;&amp;amp; a[num] !</description>
    </item>
    
    <item>
      <title>[백준]1932 숫자삼각형</title>
      <link>https://jyukki97.github.io/blog/2017-11-24-1932/</link>
      <pubDate>Fri, 24 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-11-24-1932/</guid>
      <description>https://www.acmicpc.net/problem/1932
풀이:  첫 줄부터 밑에줄까지 내려가면서 값을 더해감 더한 값중 제일 큰 값을 찾음  코드: #include &amp;lt;iostream&amp;gt;using namespace std;int q[501][501];int good[501][501];int main(void){int num;int big = 0;cin &amp;gt;&amp;gt; num;for (int i = 0; i &amp;lt; num; i++){for (int t = 0; t &amp;lt; i + 1; t++){cin &amp;gt;&amp;gt; q[i][t];}}good[0][0] = q[0][0];for (int i = 1; i &amp;lt; num; i++){for (int t = 0; t &amp;lt; i+1; t++){if(t==0)good[i][t] = good[i - 1][t] + q[i][t];else if (i == t)good[i][t] = good[i - 1][t - 1] + q[i][t];else{if (good[i - 1][t - 1] &amp;gt; good[i - 1][t])good[i][t] = good[i - 1][t - 1] + q[i][t];elsegood[i][t] = good[i - 1][t] + q[i][t];}}}for (int i = 0; i &amp;lt; num; i++){if (good[num - 1][i] &amp;gt; big)big = good[num - 1][i];}cout &amp;lt;&amp;lt; big &amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
    <item>
      <title>[백준]2293 동전1</title>
      <link>https://jyukki97.github.io/blog/2017-11-23-2293/</link>
      <pubDate>Thu, 23 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-11-23-2293/</guid>
      <description>https://www.acmicpc.net/problem/2293
풀이:  첫번째 동전부터 경우의 수를 더해감.  코드: #include &amp;lt;iostream&amp;gt;using namespace std;int coin[10001] = { 0 };int main(void){int a;int num;cin &amp;gt;&amp;gt; a;cin &amp;gt;&amp;gt; num;int *q = new int[a];for (int i = 0; i &amp;lt; a; i++){cin &amp;gt;&amp;gt; q[i];}for (int i = 0; i &amp;lt;= num; i++){if (i%q[0] == 0)coin[i]++;}for (int i = 1; i &amp;lt; a; i++){for (int t = q[i]; t &amp;lt;= num; t++){coin[t] += coin[t - q[i]];}}cout &amp;lt;&amp;lt; coin[num] &amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
    <item>
      <title>[백준]3613 Java vs C&#43;&#43;</title>
      <link>https://jyukki97.github.io/blog/2017-11-22-3613/</link>
      <pubDate>Wed, 22 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-11-22-3613/</guid>
      <description>https://www.acmicpc.net/problem/3613
풀이:  java 변수면 c++로 c++ 이면 java로 변경 예외처리  코드: #include &amp;lt;iostream&amp;gt;#include &amp;lt;string.h&amp;gt;using namespace std;int main(void) {char a[201];char b[201] = {&amp;#39;\n&amp;#39;};bool java = false;bool cplus = false;bool ero = true;cin &amp;gt;&amp;gt; a;int t = 0;for (int i = 0; i &amp;lt; strlen(a); i++) {if (65 &amp;lt;= (int)a[i] &amp;amp;&amp;amp; (int)a[i] &amp;lt;= 90) {if (i == 0 || cplus == true) {ero = false;break;}b[t] = &amp;#39;_&amp;#39;;t++;b[t] = a[i] + 32;java = true;}else if (a[i] == &amp;#39;_&amp;#39;) {if (i == 0 || i == strlen(a)-1 || a[i + 1] == &amp;#39;_&amp;#39; || java == true || (65 &amp;lt;= (int)a[i + 1] &amp;amp;&amp;amp; (int)a[i + 1] &amp;lt;= 90)) {ero = false;break;}b[t] = a[i + 1] - 32;i++;cplus = true;}else b[t] = a[i];t++;}if (ero == false)cout &amp;lt;&amp;lt; &amp;#34;Error!</description>
    </item>
    
    <item>
      <title>[백준]1065 한수</title>
      <link>https://jyukki97.github.io/blog/2017-11-20-1065/</link>
      <pubDate>Mon, 20 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-11-20-1065/</guid>
      <description>https://www.acmicpc.net/problem/1065
풀이: 한수이면 카운트를 ++ 하는 함수를 만듦
코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;using namespace std;int hannum(int n, int c) {int b = (n % 1000) / 100;int d = ((n % 1000) % 100) / 10;int f = ((n % 1000) % 100) % 10;if (n &amp;gt; 99) {if ((b - d == d - f) &amp;amp;&amp;amp; n != 1000)c++;}elsec++;if (n == 1)return c;elsereturn hannum(n - 1, c);}int main(void) {int a;cin &amp;gt;&amp;gt; a;cout &amp;lt;&amp;lt; hannum(a, 0);return 0;}</description>
    </item>
    
    <item>
      <title>[백준]1475 방번호</title>
      <link>https://jyukki97.github.io/blog/2017-11-20-1475/</link>
      <pubDate>Mon, 20 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-11-20-1475/</guid>
      <description>https://www.acmicpc.net/problem/1475
풀이:  방번호를 string에 저장 string 첫번째 자릿수부터 숫자를 확인 숫자에 맞는 배열에 ++ 배열에서 가장 큰 숫자를 가지고 있는 값을 출력  코드: 사용언어 : c++
#include &amp;lt;iostream&amp;gt;#include &amp;lt;string&amp;gt;using namespace std;int main(void) {string a;int b[10] = { 0 };cin &amp;gt;&amp;gt; a;for (int i = 0; i &amp;lt; a.length(); i++) {if (((int)a[i] - 48) == 6 &amp;amp;&amp;amp; b[6] &amp;gt; b[9])b[9] ++;else if (((int)a[i] - 48) == 9 &amp;amp;&amp;amp; b[6] &amp;lt; b[9])b[6] ++;elseb[(int)a[i] - 48]++;}int count = 0;for (int i = 0; i &amp;lt; 10; i++) {if (b[i] &amp;gt; count)count = b[i];}cout &amp;lt;&amp;lt; count &amp;lt;&amp;lt; endl;return 0;}</description>
    </item>
    
    <item>
      <title>start</title>
      <link>https://jyukki97.github.io/blog/2017-11-19-start/</link>
      <pubDate>Sun, 19 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/blog/2017-11-19-start/</guid>
      <description>안녕하세요.</description>
    </item>
    
  </channel>
</rss>