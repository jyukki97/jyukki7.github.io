<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Learn on 1 Day 1 Problem</title>
    <link>https://jyukki97.github.io/learn/</link>
    <description>Recent content in Learn on 1 Day 1 Problem</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>kr-ko</language>
    <lastBuildDate>Thu, 27 Feb 2020 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://jyukki97.github.io/learn/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>[C&#43;&#43;]플로이드-와샬 알고리즘(Floyd-Warshall Algorithm)</title>
      <link>https://jyukki97.github.io/learn/2020-02-27-floydwarshall/</link>
      <pubDate>Thu, 27 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/learn/2020-02-27-floydwarshall/</guid>
      <description>플로이드-와샬 알고리즘(Floyd-Warshall Algorithm)
플로이드-와샬 알고리즘(Floyd-Warshall Algorithm) 한번의 실행으로 &amp;ldquo;모든 노드&amp;rdquo; 간 최단 경로를 구하는 알고리즘. 시간복잡도 $$ O(n^3) $$
위 그림의 초기값은 다음과 같다.
   0 5 ∞ 9 1     5 0 2 ∞ ∞   ∞ 2 0 7 ∞   9 ∞ 7 0 2   1 ∞ ∞ 2 0    이때,
1 번 노드를 중간 노드로 한다면,</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;]벨만-포드 알고리즘(Bellman-Ford Algorithm)</title>
      <link>https://jyukki97.github.io/learn/2020-02-25-bellmanford/</link>
      <pubDate>Tue, 25 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/learn/2020-02-25-bellmanford/</guid>
      <description>벨만-포드 알고리즘(Bellman-Ford Algorithm)
벨만-포드 알고리즘(Bellman-Ford Algorithm) 특정 노드에서부터 모든 노드로 가는 최단 경로를 구하는 알고리즘. 그래프에 &amp;ldquo;음수 사이클&amp;quot;이 있는 경우 찾아낼 수 있음. 시간복잡도는 O(nm) 음수 사이클 음수 사이클이 있는지 판단하기 위해서는 n번의 라운드를 추가로 진행해 주면된다. 만약, n번째 라운드에서도 감소하는 경우가 있다면, 음수 사이클이 있다고 판단할 수 있다. 코드 for (i = 0; i &amp;lt;= V; i++)d.push_back(INF);d[x] = 0;for(int i = 1; i &amp;lt;= n - 1; i++)for(auto t : edge(a,b,c)) // a 에서 b로 가는 간선, 가중치 c  d[b] = min(d[b], d[a] + c);</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;]다익스트라 알고리즘(Dijkstra Algorithm)</title>
      <link>https://jyukki97.github.io/learn/2020-02-24-dijkstra/</link>
      <pubDate>Mon, 24 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/learn/2020-02-24-dijkstra/</guid>
      <description>다익스트라 알고리즘(Dijkstra Algorithm)
다익스트라 알고리즘(Dijkstra Algorithm) 특정 노드에서부터 모든 노드로 가는 최단 경로를 구하는 알고리즘. 가중치가 음수인 간선이 없는 경우에만 사용할 수 있다. 시간복잡도 : O(n + mlog m) (n : 노드의 개수, m : 간선의 갯수) 코드 for (i = 0; i &amp;lt;= V; i++)d.push_back(INF);d[k] = 0;p.push({ 0, k });while (!p.empty()) {w = p.top().second;p.pop();if (b[w])	continue;b[w] = true;for (auto t : a[w]) {u = t.</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;]lower_bound, upper_bound</title>
      <link>https://jyukki97.github.io/learn/2020-02-19-bound/</link>
      <pubDate>Wed, 19 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/learn/2020-02-19-bound/</guid>
      <description>lower_bound, upper_bound
- 기본적으로 두개 모두 &amp;ldquo;이진 탐색(Binary Serch)&amp;rdquo; 기반의 탐색방법 lower_bound lower_bound(arr, arr + n, key);- key 값의 가장 낮은 위치를 찾는다. - key 값이 없다면 key 값보다 큰 가장 작은 정수의 위치를 반환한다. - 반환값이 &amp;ldquo;iterator&amp;rdquo; 이다. upper_bound upper_bound(arr, arr + n, key);- key 값을 초과하는 가장 첫번째 원소의 위치. - 반환값이 &amp;ldquo;iterator&amp;rdquo; 이다. </description>
    </item>
    
    <item>
      <title>[C&#43;&#43;]set predicate</title>
      <link>https://jyukki97.github.io/learn/2020-02-16-setpredicate/</link>
      <pubDate>Sun, 16 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/learn/2020-02-16-setpredicate/</guid>
      <description>set predicate
set 이라는 컨테이너는 기본적으로 &amp;ldquo;오름차순&amp;rdquo; 으로 정렬된다.
이를 바꾸기 위해 정렬 기준을 바꿔 주어야한다.
정렬기준은
bool compare(const key_type key_typeA, const key_type key_typeB){return key_typeA &amp;lt; key_typeB;}와 같이 bool 형식을 통해 바꿀 수 있다.
정렬기준을 적용하는 방법은
set&amp;lt;key_type, decltype(&amp;amp;compare)&amp;gt; a(&amp;amp;compare)과 같이 하면된다.</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;]transform</title>
      <link>https://jyukki97.github.io/learn/2020-02-07-transform/</link>
      <pubDate>Fri, 07 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/learn/2020-02-07-transform/</guid>
      <description>transform
#include&amp;lt;algorithm&amp;gt;사용하기 위해서는 algorithm을 include해준다.
기본적인 사용법은 이렇게된다.
transform(a.begin(), a.end(), a.begin(), fuc());// transform(시작주소, 끝 주소, 저장할 곳의 시작 주소, 함수);ex)
배열 a의 모든 값을 3씩 증가시키기
#include &amp;lt;iostream&amp;gt; #include &amp;lt;vector&amp;gt;#include &amp;lt;algorithm&amp;gt; using namespace std; int func(int n) { return n + 3;} int main() {vector&amp;lt;int&amp;gt; a;for(int i = 0; i &amp;lt; 5; i++)a.push_back(i);transform(a.begin(), a.end(), a.begin(), func);for(int i : a)cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; endl;return 0;}출력)</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;]정렬</title>
      <link>https://jyukki97.github.io/learn/2020-01-29-sort/</link>
      <pubDate>Wed, 29 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/learn/2020-01-29-sort/</guid>
      <description>정렬 ( sort )
#include&amp;lt;algorithm&amp;gt;사용하기 위해서는 algorithm을 include해준다.
기본적인 사용법은 이렇게된다.
sort(a.begin(), a.end());기본적인 방식은 오름차순 정렬이다.
정렬의 방식을 바꾸기 위해서는 다음과 같은 방식을 사용한다.
sort(a.begin(), a.end(), compare);이 때, compare 함수는 따로 만들어 주어야한다.
예를들어
내림차 순으로 정렬하기 위해서는
bool compare(int a, int b){return a &amp;gt; b;}과 같이 만들어 주면 된다.
이를 응용한다면
bool compare(pair&amp;lt;int, int&amp;gt; a, pair&amp;lt;int, int&amp;gt; b){return a.second &amp;gt; b.second;}과 같이 응용할 수도 있다.</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;]순열 </title>
      <link>https://jyukki97.github.io/learn/2020-01-28-next_permutation/</link>
      <pubDate>Tue, 28 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/learn/2020-01-28-next_permutation/</guid>
      <description>순열 ( next_permutation )
#include&amp;lt;iostream&amp;gt;#include&amp;lt;string&amp;gt;#include&amp;lt;algorithm&amp;gt;using namespace std;int main() { string str = &amp;#34;123&amp;#34;; sort(str.begin(), str.end());do {for (int i = 1; i &amp;lt;= str.size(); ++i) {int n = stoi(str.substr(0, i));cout &amp;lt;&amp;lt; n &amp;lt;&amp;lt; endl; } }while (next_permutation(str.begin(), str.end())); return 0;}출력 :
112123113132221213223231331312332321</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;]문자열 분리 </title>
      <link>https://jyukki97.github.io/learn/2020-01-27-stringstream/</link>
      <pubDate>Mon, 27 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/learn/2020-01-27-stringstream/</guid>
      <description>문자열 분리 ( stringstream, strtok )
stringstream - 공백을 기준으로 분리 stringstream s_stream(string a);s_stream에 a에 있는 문장을 공백을 기준으로 분리해서 넣는다.
#include &amp;lt;sstream&amp;gt;사용하기 위해서는 sstream을 include해서 사용하자.
string a = &amp;#34;a b c d&amp;#34;;stringstream s_stream(a);string c;while(s_stream &amp;gt;&amp;gt; c){cout &amp;lt;&amp;lt; c &amp;lt;&amp;lt; endl;}출력 :
abcdstrtok - 주어진 문자를 기준으로 분리 strtok(char* a, char* b);a를 b를 기준으로 분리한다.
이때, b는 한 단어가 아닌 문장이어도 성립한다.</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;]대소문자, 숫자 구분함수 </title>
      <link>https://jyukki97.github.io/learn/2020-01-02-distinguishstring/</link>
      <pubDate>Thu, 02 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jyukki97.github.io/learn/2020-01-02-distinguishstring/</guid>
      <description>숫자판단, 문자판단, 대소문자 판단 ( isalpha, isupper, islower, isdigit, toupper, tolower )
isalpha - 알파벳 문자 판별 int isalpha(int c);c가 알파벳 문자인지 아닌지 판별해준다. int형인 이유는 아스키코드를 판별하기 떄문!!
단, 사용 할 때 알파벳을 직접 넣어줘도 된다.
int isalpha(97);int isalpha(&amp;#39;a&amp;#39;);밑에 &amp;lsquo;a&amp;rsquo; 가 아스키코드로 97이므로 결국 두 문장은 같은 문장이다.
return은 타입이 int형 이기에 알파벳이 아니라면 0 을 알파벳이라면 0이아닌 정수를 리턴한다.
  비쥬얼 스튜디오 기준
​	알파벳이 아닐경우 - 0</description>
    </item>
    
  </channel>
</rss>